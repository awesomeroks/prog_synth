given an array of numbers var0 . assign the length of var0 to var1 . var2 is a new integer array of length var1 . for each var3 between 0 and var1 assign var8 - th element of var0 to var2 [ var3 ] , while incrementing var8 . sort var2 . set var5 to 1 . while var1 is greater than or equal to var5 repeat store var5 in var6 , assign var1 - 1 to var7 , while var6 is greater than zero repeat increment var4 by var2 [ var7 ] and then decrement var7 , decrement var6 and then assign var5 * 4 to var5 . you have to return var4
given numbers var0 and var1 . var7 is a new integer array . initialize var2 to zero . let var4 : = 2 + 100000 . 0 . append var0 to var7 , return var7 if var0 doesn ' t exceed var1 . assign var0 - var1 to var5 . while var3 doesn ' t exceed var4 repeat store in var6 the value of var4 - var3 divided by two + var3 , if ( 1 + var6 ) multiplied by var6 multiplied by 1 / 2 is greater than or equal to var5 you have to store var6 in var2 , you have to store var6 - 1 in var4 , and you have to store var6 + 1 in var3 otherwise . append var1 * 1 + var2 to the end of var7 . return var7
we are given an array of numbers var0 . initialize var7 to 0 . assign len of var0 to var1 . var2 is a new array of length var1 . iterate var4 from 0 to var1 , inside the loop assign var7 - th element of var0 to var2 [ var4 ] , while incrementing var7 . sort var2 . let var5 : = var1 . while var5 is greater than zero for var6 in range from 1 to var5 ( inclusive ) increment var3 by var2 [ var1 - var6 ] , reduce var5 in 4 times . you have to return var3
given a string var0 and a string var1 . var6 is new array of strings . var2 is a new array of numbers of length the length of var0 . initialize var3 to zero . add NO to var6 , you have to return var6 if the length of var0 is not equal to the length of var1 . for each position var5 in var0 if var0 [ var5 ] is equal to 49 initialize var3 to 1 , if var1 [ var5 ] is equal to 49 set var4 to 1 . if var3 = var4 add YES to var6 , and add NO to var6 otherwise . you have to return var6
we are given an array of integers var0 . assign the length of var0 to var1 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) assign var9 - th element of var0 to var2 [ var3 ] , also increment var9 . sort var2 . you have to set var4 to var2 [ var1 - 1 ] . initialize var6 to 1 . if var1 is equal to one return var2 [ var1 - 1 ] , and set var7 to 1 , while var6 is less than or equal to var1 repeat set var8 to the length of var2 - 1 , while var1 - var6 is less than or equal to var8 repeat increase var5 by var2 [ var8 ] and then decrement var8 , after the loop is ended , increment var7 , assign 4 * var6 to var6 , you have to return var5 otherwise
given numbers var0 and var1 . initialize var2 to 0 . let var3 be 2000000000 . 0 . while var2 is less than or equal to var3 repeat store var3 + var2 divided by two in var4 , set var6 to half of var4 * ( 1 + var4 ) , if var0 - var1 doesn ' t exceed var6 let var5 : = var4 , store in var3 the value of var4 - 1 else store 1 + var4 in var2 . return var0 if var0 doesn ' t exceed var1 , otherwise var5 + var1
given an integer var0 , integer arrays var1 and var2 . set var3 to the length of var1 . initialize var4 to - 2147483648 . iterate var5 from 0 to var3 , inside the loop let var4 be var1 [ var5 ] minus var0 if var1 [ var5 ] - var2 [ var5 ] ( 0 - based indices ) - var0 > var4 else var4 if var2 [ var5 ] is greater than var0 , otherwise set var4 to var1 [ var5 ] if var1 [ var5 ] is bigger than var4 else var4 . you have to return var4
given an array of arrays of characters var0 . var8 is new array of strings . assign the length of var0 to var1 . you have to store var1 - 2 in var3 . while var3 is non negative repeat let var4 be minimum between the length of var0 [ var3 ] and the length of var0 [ var3 + 1 ] , set var5 to false , for each var6 between 1 and var4 ( exclusive ) set var5 to true , if var0 [ var3 ] [ var6 ] exceeds var0 [ var3 + 1 ] [ var6 ] let var0 [ var3 ] be substring of var0 [ var3 ] from 0 to var6 , break if var0 [ var3 ] [ var6 ] is not equal to var0 [ 1 + var3 ] [ var6 ] , if not var5 store substring of var0 [ var3 ] from 0 to minimum between the length of var0 [ var3 ] and the length of var0 [ 1 + var3 ] in var0 [ var3 ] and then decrement var3 . for every var7 in var0 add var7 to var8 . return var8
you are given the number var0 , an array of integers var1 and an array of integers var2 . set var3 to the length of var1 . var4 is a new array of length var3 . for each var5 between 0 and var3 ( exclusive ) [ ] . for var6 in range from 0 to var3 ( exclusive ) if var2 [ var6 ] is larger than var0 assign var1 [ var6 ] minus var2 [ var6 ] - var0 to var4 [ var6 ] , and assign var1 [ var6 ] to var4 [ var6 ] otherwise . set var7 to var4 [ 0 ] . for each var8 between 0 and var3 you have to set var7 to var4 [ var8 ] if var4 [ var8 ] is larger than var7 . you have to return var7
you are given a number var0 , arrays of numbers var1 and var2 . initialize var8 to zero . assign the length of var1 to var3 . assign 0 - 1000000000 . 0 to var4 . for var5 in range from 0 to var3 let the var1 [ var8 ] be equal to var6 , also increment var8 , assign var9 - th element of var2 to var7 , also increment var9 , if var4 is smaller than var0 - var7 plus var6 and var7 is bigger than var0 set var4 to var6 + var0 - var7 , if var7 doesn ' t exceed var0 and var6 is bigger than var4 assign var6 to var4 . return var4
you are given integer var0 , an array of integers var1 and an array of integers var2 . let var3 : = len ( var1 ) . you have to set var4 to 0 - 2000000000 . for var5 in range from 0 to var3 ( exclusive ) let the var1 [ var9 ] be equal to var6 , also increment var9 , let the var10 - th element of var2 be equal to var7 , also increment var10 , set var8 to var6 , if var7 is bigger than var0 reduce var8 by var7 - var0 , let var4 be maximum of var4 and var8 . return var4
you are given character arrays var0 and var1 . var2 is an empty array of strings . add NO to var2 , you have to return var2 if the length of var1 is not equal to the length of var0 . add NO to var2 , you have to return var2 if var0 contain " 1 " and not var1 contain " 1 " . if not var0 contain " 1 " as substring and " 1 " is in var1 add NO to var2 , you have to return var2 . add YES to var2 . return var2
you are given integer var0 , integer arrays var1 , var2 . you have to set var9 to zero . let var3 : = the length of var1 . initialize var4 to - 2147483648 . iterate var5 from 0 to var3 , inside the loop assign var8 - th element of var1 to var6 , also increment var8 , assign var9 - th element of var2 to var7 , while incrementing var9 , if var7 is larger than var0 you have to store maximum of var4 and var6 - var7 - var0 in var4 , and set var4 to maximum of var4 and var6 otherwise . you have to return var4
you are given integer var0 , arrays of numbers var1 and var2 . you have to set var11 to zero . you have to store the length of var1 in var3 . set var4 to - 2147483648 . iterate var5 from 0 to var3 , inside the loop assign var10 - th element of var1 to var6 , also increment var10 , assign var11 - th element of var2 to var7 , while incrementing var11 , in var8 you have to store var7 minus var0 , if var8 is positive store var6 - var8 in var9 , and let var9 be var6 otherwise , if var9 is larger than var4 let var4 : = var9 . you have to return var4
you are given numbers var1 and var2 . in __globals__.__init__ set __globals__.var0 to 1000000007 . initialize var3 to 1 . for each var4 between 0 and var2 - 1 ( exclusive ) set var3 to var3 multiplied by var2 modulo __globals__.var0 . after the loop is ended , for var5 in range from 0 to var1 - var2 set var3 to ( var1 - var2 ) * var3 % __globals__.var0 if var1 - var2 is positive . you have to return var3
you are given a character array var0 . for each element of the array var0 at indices between 0 and the length of var0 , exclusive , if it equals to 114 then let var1 be concatenation of concatenation of var1 and string representation of 1 + var2 and 10 . set var3 to the length of var0 - 1 . while var3 is non - negative repeat if var0 [ var3 ] is equal to 108 assign concatenation of concatenation of var1 and string representation of var3 + 1 and 10 to var1 and then decrement var3 . return var1
we are given integer var0 , an array of numbers var1 . in func0 let var3 be the length of var1 ; you have to store in var4 the value of var0 ; var5 is a new array of numbers of length var3 ; iterate var6 from 0 to var3 ( exclusive ) assign var2 - th element of var1 to var5 [ var6 ] , while incrementing var2 ; let var7 be 1 plus var3 minus var4 ; set the value of var9 to be the sum of elements in var5 ; set var8 to var9 ; set var11 to 1 ; while var11 plus var4 - 1 is smaller than var3 repeat reduce var9 by var5 [ var11 - 1 ] , increase var9 by var5 [ var4 + var11 - 1 ] , increase var8 by var9 and then increment var11 ; you have to return var8 / var7 . initialize var2 to zero . you have to return call function func0 with arguments var0 , var1 , var2
you are given integer var0 , integer arrays var1 , var2 . you have to set var9 to zero . let var3 : = the length of var1 . initialize var4 to - 2147483648 . iterate var5 from 0 to var3 , inside the loop assign var8 - th element of var1 to var6 , also increment var8 , assign var9 - th element of var2 to var7 , while incrementing var9 , if var7 is larger than var0 you have to store maximum of var4 and var6 - var7 - var0 in var4 , and set var4 to maximum of var4 and var6 otherwise . you have to return var4
you are given integers var2 and var3 . in __globals__.__init__ you have to store 0 in __globals__.var1 ; let __globals__.var0 be 0 . let __globals__.var1 be var2 . you have to store var3 in __globals__.var0 . in var4 you have to store __globals__.var0 . initialize var5 to 1 . set var6 to 2000000000 . 0 . store in var7 the value of - 1 . while var5 doesn ' t exceed var6 assign shift var6 + var5 right 1 bits to var8 , set var9 to __globals__.var0 + half of var8 * ( var8 - 1 ) + var8 , if __globals__.var0 is less than or equal to var9 you have to store var8 in var7 , you have to store var8 - 1 in var6 , set var5 to var8 + 1 otherwise . increment var4 by var7 . return minimum between __globals__.var1 and var4
we are given integer var0 , arrays of numbers var1 , var2 . initialize var10 to zero . you have to set var9 to zero . set var3 to the length of var1 . initialize var7 to - 2147483648 . for each var6 between 0 and var3 assign var9 - th element of var1 to var4 , also increment var9 , assign var10 - th element of var2 to var5 , also increment var10 , if var5 minus var0 is non - negative you have to store var4 - var5 - var0 in var8 , set var7 to maximum of var8 and var7 , set var7 to maximum of var4 and var7 otherwise . return var7
we are given integer var0 , integer arrays var1 and var2 . let var3 be the length of var1 . assign 0 - 1000000000 to var4 . for var5 in range from 0 to var3 if var2 [ var5 ] ( indexing is 0 - based ) is greater than var0 decrement var1 [ var5 ] by var2 [ var5 ] - var0 , set var4 to minimum between var4 and var1 [ var5 ] . you have to return var4
given an array of integers var0 . initialize var6 to 0 . assign the length of var0 to var1 . initialize var2 to 0 . for all var4 from 0 to var1 do the following . add var6 - th element of array var0 to var2 . for each var5 between 1 and 5 ( inclusive ) if ( var2 + var5 ) modulo ( 1 + var1 ) is not equal to 1 increment var3 . return var3
we are given arrays of numbers var0 and var1 . set var2 to the length of var0 . for each var3 between 0 and var2 ( exclusive ) [ ] . iterate var4 from 0 to var2 ( exclusive ) [ ] . create an array var5 with size var2 of type integer . assign 0 to var5 [ 0 ] . var6 is a new array of numbers of length var2 . set var7 to 1 . initialize var8 to 1 . iterate var8 from 0 to var2 , inside the loop store minimum between var9 and var7 - 1 in var9 , while var1 [ var6 [ var9 ] ] ( 0 - based indices ) ] * var0 [ var8 ] + var5 [ var6 [ var9 plus 1 ] ] is less than or equal to var0 [ var8 ] + var5 [ var6 [ var9 ] ] and 1 + var5 [ var6 [ var9 ] ] is less than or equal to var0 [ var8 ] * var1 [ var6 [ var9 ] ] increment var9 , increase var5 [ var6 [ var9 ] ] by var0 [ var8 ] ( 0 - based indices ) * var1 [ var6 [ var9 ] ] , while var1 [ var6 [ var7 - 2 ] ] * ( - 1 ) / ( var5 [ var6 [ var7 minus 1 ] ] - var5 [ var6 [ var7 - 2 ] ] ) is greater than or equal to the result of division of ( - 1 ) multiplied by ( var5 [ var8 ] minus var5 [ var6 [ var7 minus 2 ] ) by ( 0 - 1 ) - var1 [ var6 [ var7 minus 2 ] ] ) and var7 exceeds 1 decrement var7 , assign var8 to var6 [ var7 ] , increment var7 . return var5 [ var2 - 1 ]
you are given numbers var7 and var8 . in __globals__.__init__ you have to set __globals__.var0 to 0 ; you have to store 0 in __globals__.var1 . in func0 if var3 is equal to var2 you have to return var2 ; let var4 : = var2 + var3 divided by two ; set var5 to __globals__.var1 minus ( 1 + var4 ) * var4 divided by two ; set var6 to var4 + 1 + __globals__.var0 ; return value returned by function func0 ( var2 , var4 ) if var5 is less than or equal to var6 , otherwise call func0 with ( 1 + var4 , var3 ) . let __globals__.var0 : = var7 . you have to set __globals__.var1 to var8 . set var9 to __globals__.var0 if __globals__.var0 is less than or equal to __globals__.var1 , otherwise assign square root of 2 * __globals__.var0 to var3 , you have to store value returned by function func0 ( 0 , var3 ) in var10 , you have to store in var9 the value of 1 + __globals__.var0 + var10 . you have to return var9
you are given integers var0 , var1 , an array of numbers var2 and an array of numbers var3 . in var4 you have to store len of var2 . decrement var0 . decrement var1 . initialize var5 to 0 . set var7 to false . for var8 in range from 0 to var4 if var8 is greater than or equal to var0 and var8 doesn ' t exceed var1 continue , if var2 [ var8 ] is not equal to var3 [ var8 ] initialize var7 to true , stop iterating if var7 . return " <unk> " if var7 , otherwise " <unk> "
given integers var0 , var1 , arrays of numbers var2 and var3 . var10 is an empty array of strings . let var4 : = the length of var2 . you have to set var5 to zero . iterate var8 from 0 to var0 - 1 , inside the loop if var2 [ var8 ] is not equal to var3 [ var8 ] initialize var5 to 1 . for each var9 between var1 and var4 ( exclusive ) if var2 [ var9 ] is not equal to var3 [ var9 ] initialize var5 to 1 . if var5 is equal to 1 add " <unk> " to var10 . add " <unk> " to var10 if var5 is equal to 0 . you have to return var10
we are given integers var0 , var1 . var4 is an empty array of strings . append string value of minimum of var1 and var0 + 1 to var4 . assign var0 to var2 . while var2 is non negative and var3 doesn ' t exceed var1 repeat add concatenation of concatenation of string value of var2 and space and string representation of var3 to var4 and then decrement var2 , increment var3 . you have to return var4
we are given an array of numbers var1 . in __globals__.__init__ __globals__.var0 is a new integer array . let var2 be len ( var1 ) . for var3 in range from 0 to var2 append var1 [ var4 ] while incrementing var4 to __globals__.var0 . sort __globals__.var0 . return - 1 if __globals__.var0 [ 0 ] is equal to one , otherwise 1
you are given a number var0 , an array of numbers var1 . var10 is array of strings , which has no elements . let var2 : = the length of var1 . var3 is a new integer array . for var4 in range from 1 to var0 ( inclusive ) append var4 to var3 . for var7 in range from 0 to var2 ( exclusive ) let var8 be the length of var3 , assign ( var1 [ var7 ] + var6 ) % var8 to var9 , add concatenation of string value of var3 [ var9 ] and space to var10 , remove element at position var9 from var3 , let var6 be var9 % the length of var3 . you have to return var10
we are given an array of integers var1 . in func0 set var3 to the length of var1 ; var4 is a new array of numbers of length var3 ; iterate var5 from 0 to var3 , in each iteration you have to do the following : assign var2 - th element of var1 to var4 [ var5 ] , while incrementing var2 ; sort var4 ; if var3 is equal to one set var6 to var4 [ 0 ] , and set var7 to 1 , while var7 doesn ' t exceed var3 repeat you have to store in var8 the value of var3 - 1 , while var3 - var7 doesn ' t exceed var8 repeat add var4 [ var8 ] * 1 to var6 and then decrement var8 and then store 4 * var7 in var7 otherwise ; you have to return var6 . return call func0 with ( 1 , var1 , var2 )
you are given numbers var0 and var1 . var4 is array of strings , which has no elements . you have to store var1 in var3 . append string value of minimum between var0 and var1 + 1 to var4 . while var2 is less than or equal to var0 and var3 is non negative repeat add concatenation of concatenation of string value of var2 and space and string representation of var3 to var4 , increment var2 , decrement var3 . return var4
you are given integer var0 , arrays of integers var1 , var2 . initialize var10 to zero . you have to set var9 to zero . you have to store len of var1 in var3 . set var4 to - 2147483648 . iterate var5 from 0 to var3 , in each iteration you have to do the following : assign var9 - th element of var1 to var6 , also increment var9 , assign var10 - th element of var2 to var7 , while incrementing var10 , let var8 be var6 - maximum of 0 and var7 - var0 , you have to store maximum of var8 and var4 in var4 . after the loop is ended , you have to return var4
you are given numbers var2 , var3 and var4 . in __globals__.__init__ assign - 1 to __globals__.var0 ; assign 0 to __globals__.var1 . assign var3 / var2 to var5 . set var6 to var4 / var2 . if var3 is smaller than var2 and var4 is smaller than var2 return - 1 , return - 1 if var6 is equal to zero and var3 is not divisible by var2 or var4 is not divisible by var2 and var5 is equal to 0 otherwise reduce var3 by var5 * var2 , reduce var4 by var6 * var2 , increment __globals__.var0 by var5 + var6 , while var4 is greater than or equal to var2 or var2 doesn ' t exceed var3 repeat if var3 is greater than or equal to var2 subtract var2 from var3 , increment __globals__.var0 , reduce var4 by var2 , increment __globals__.var1 if var4 is greater than or equal to var2 , return __globals__.var1 otherwise
we are given a string var0 . var1 is a new integer array . let var2 be len ( var0 ) - 1 . while var2 is non negative repeat append var2 to var1 if 108 is equal to var0 [ var2 ] , otherwise insert var2 into var1 at position 0 and then decrement var2 . for every var4 in var1 concatenate concatenation of string value of 1 + var4 and " \ n " to var3 . return var3
given integers var0 and var1 . return var0 if var1 is greater than or equal to var0 , otherwise subtract var1 from var0 , initialize var2 to 1 , initialize var3 to 2000000000 , while var3 is not equal to var2 repeat let var4 be var2 + var3 divided by two , let var5 : = ( var4 + 1 ) times var4 divided by 2 , if var0 doesn ' t exceed var5 let var3 : = var4 , and set var2 to var4 + 1 otherwise , return var1 + var2
you are given integer arrays var0 , var1 and var2 . var12 is array of strings , which has no elements . you have to set var11 to zero . assign the length of var0 to var3 . you have to set var4 to zero . initialize var6 to 0 . store len of var1 in var7 . for var8 in range from 0 to var7 ( exclusive ) assign var10 - th element of var1 to var5 , while incrementing var10 , assign var11 - th element of var2 to var6 , also increment var11 , if var5 is equal to one add empty string to var12 , and increment var0 [ var5 - 2 ] by var6 - 1 otherwise , if var5 is equal to var3 add empty string to var12 , and increase var0 [ var5 ] by var0 [ var5 - 1 ] minus var6 otherwise , let var0 [ var5 - 1 ] be 0 . for each position var9 in var0 append string value of var0 [ var9 ] to the end of var12 . you have to return var12
given the number var0 , arrays of integers var1 and var2 . in func0 let var5 : = the length of var1 ; assign var0 to var6 ; set var7 to - 9223372036854775808 ; for var8 in range from 0 to var5 ( exclusive ) assign var3 - th element of var1 to var9 , also increment var3 , let the var2 [ var4 ] be equal to var10 , also increment var4 , if var6 is greater than or equal to var10 set var7 to maximum between var7 and var9 , and you have to set var7 to maximum of var9 - var10 - var6 and var7 otherwise ; you have to return var7 . you have to set var4 to zero . you have to return call function func0 with arguments var0 , var1 , var2 , var3 , var4
given a number var1 , an array of numbers var2 and an array of numbers var3 . in __globals__.__init__ assign 1000000007 to __globals__.var0 . in func0 you have to store in var6 the value of the length of var2 ; in var7 you have to store var1 ; set var8 to - 2147483648 ; iterate var9 from 0 to var6 assign var4 - th element of var2 to var10 , also increment var4 , assign var5 - th element of var3 to var11 , also increment var5 , let var8 be maximum between var8 and var10 - var11 plus var7 if var11 is bigger than var7 else var10 ; return var8 . initialize var5 to 0 . return value returned by function func0 ( var1 , var2 , var3 , var4 , var5 )
you are given integer var0 , integer arrays var1 , var2 . initialize var10 to 0 . let var3 be the length of var1 . you have to store 0 - <unk> in var4 . for var5 in range from 0 to var3 ( exclusive ) let the var1 [ var9 ] be equal to var6 , also increment var9 , let the var2 [ var10 ] be equal to var7 , also increment var10 , let var8 be var6 - var7 minus var0 if var7 is greater than var0 else var6 , set var4 to maximum of var8 and var4 . return var4
you are given arrays of integers var0 , var1 . initialize var2 to zero . initialize var3 to zero . assign the length of var0 to var4 . iterate var5 from 0 to var4 , inside the loop [ ] . assign len ( var1 ) to var6 . for all var7 from 0 to var6 do the following . [ ] . for each var8 and var9 in range from 0 to var6 continue if var1 [ var9 ] is not divisible by var0 [ var8 ] , if var1 [ var9 ] / var0 [ var8 ] is larger than var2 let var2 : = var1 [ var9 ] / var0 [ var8 ] , initialize var3 to 1 , and increment var3 if var2 is equal to var1 [ var9 ] / var0 [ var8 ] otherwise . you have to return var3
we are given a character array var0 . var3 is a new array of numbers . for each element of the array var0 at indices between 0 and the length of var0 , exclusive , if it equals to 114 then append 1 + var1 to var3 . assign the length of var0 - 1 to var2 . while var2 is non negative repeat if var0 [ var2 ] = 108 append var2 plus 1 to the end of var3 and then decrement var2 . return var3
we are given an integer var0 , an array of numbers var1 . var9 is an empty array of strings . let var2 be len of var1 . create an array var3 with size var2 * var0 of type boolean . iterate var4 from 0 to var2 , in each iteration you have to do the following : assign true to var3 [ var1 [ var4 ] minus 1 ] . for each var6 between 0 and var2 ( exclusive ) append string representation of var1 [ var6 ] to var9 , let var3 [ var1 [ var6 ] - 1 ] be true , iterate var7 from 0 to var0 - 1 , in each iteration you have to do the following : iterate var8 from var5 to var2 * var0 , in each iteration you have to do the following : if var3 [ var8 ] set var5 to var8 , and set var3 [ var8 ] to true , add concatenation of space and string value of 1 plus var8 to var9 , in var5 you have to store var8 , break otherwise . you have to return var9
given numbers var0 , var1 . set var2 to var0 . assign var1 to var3 . assign <unk> - var3 to var4 . initialize var5 to 1 . for as long as var5 is smaller than var2 and var4 - 5 times var5 is non - negative decrement var4 by var5 * 5 , increment var5 . return var5 if var5 is equal to var2 and var4 - var5 * 5 is non - negative , otherwise var5 - 1
we are given a string var0 and a string var1 . initialize var2 to true . if the length of var1 is not equal to the length of var0 set var2 to false , if var0 is equal to var1 initialize var2 to true , set var2 to false , set var2 to true if var0 contain " 1 " and var1 contain " 1 " otherwise otherwise . you have to return YES if var2 else NO
you are given character arrays var1 and var2 . in func0 let var3 be var1 ; assign var2 to var4 ; if the length of var3 is not equal to the length of var4 you have to return NO , initialize var5 to true , set var6 to true , for every element in var3 at index var7 if var3 [ var7 ] is not equal to 48 set var5 to false , if 48 is not equal to var4 [ var7 ] ( indexing is 0 - based ) initialize var6 to false , return YES if var5 is equal to var6 else NO otherwise . return call function func0 with arguments 1 , var1 , var2
you are given integer var0 , integer arrays var1 , var2 . initialize var9 to zero . initialize var8 to zero . set var3 to len of var1 . initialize var4 to - 2147483648 . iterate var5 from 0 to var3 , in each iteration you have to do the following : assign var8 - th element of var1 to var6 , while incrementing var8 , let the var2 [ var9 ] be equal to var7 , also increment var9 , if var7 is larger than var0 you have to store maximum of var4 and var6 + var0 minus var7 in var4 , and assign maximum of var4 and var6 to var4 otherwise . return var4
you are given arrays of integers var0 , var1 and var2 . var12 is a new array of numbers . you have to set var11 to zero . assign the length of var0 to var3 . set var4 to 1 . initialize var5 to 0 . assign len of var1 to var6 . for each var7 between 0 and var6 ( exclusive ) assign var10 - th element of var1 to var8 , while incrementing var10 , let the var2 [ var11 ] be equal to var9 , also increment var11 , append maximum of var0 [ 0 ] and var0 [ var8 - 1 ] to the end of var12 , assign var9 + maximum of var0 [ 0 ] and var0 [ var8 - 1 ] to var0 [ 0 ] . return var12
you are given arrays of integers var0 and var1 . initialize var11 to zero . initialize var10 to zero . you have to store in var2 the value of len of var0 . iterate var6 from 0 to var2 ( exclusive ) assign var10 - th element of var0 to var3 , while incrementing var10 , let the var11 - th element of var1 be equal to var4 , also increment var11 , you have to store in var7 the value of var3 plus 1 , initialize var9 to 1 , while var9 is less than var4 repeat let var9 be 4 * var9 , increment var8 , after the loop is ended , you have to store var8 + var3 in var7 if var4 is greater than 1 , set var5 to maximum of var5 and var7 . return var5
given a character array var0 . var2 is a new array of numbers . for each position var3 in var0 add concatenation of string representation of 1 + var3 and " \ n " to var1 if 114 = var0 [ var3 ] otherwise if var0 [ var3 ] is equal to 108 append 1 + var3 to var2 . you have to store the length of var2 - 1 in var4 . while var4 is non negative repeat add concatenation of string representation of var2 [ var4 ] and " \ n " to var1 and then decrement var4 . return var1
we are given integers var0 , var1 , arrays of numbers var2 , var3 . var14 is array of strings , which has no elements . let var4 : = the length of var2 . var5 is a new array of length var4 . var6 is a new array of length var4 . for var9 in range from 0 to var4 ( exclusive ) add var3 [ var9 ] to var5 [ var9 ] , add var3 [ var9 ] to var6 [ var9 ] . sort var6 . assign var6 [ 0 ] to var10 . store in var11 the value of var6 [ the length of var6 - 1 ] . append string representation of - 1 to var14 if var11 - var10 exceeds var1 - var0 , otherwise let var12 be var0 - var10 , iterate var13 from 0 to var4 , inside the loop if var13 is equal to zero append string representation of var12 + var5 [ var13 ] to the end of var14 , add concatenation of space and string representation of var5 [ var13 ] + var12 to var14 otherwise . you have to return var14
we are given the number var1 , arrays of integers var2 and var3 . in func0 assign the length of var2 to var6 ; let var7 : = var1 ; assign 0 - 1000000000 to var9 ; for each var10 between 0 and var6 assign var4 - th element of var2 to var11 , while incrementing var4 , assign var5 - th element of var3 to var12 , while incrementing var5 , if var12 exceeds var7 set var8 to var11 - var12 - var7 , you have to set var8 to var11 otherwise , store in var9 the value of maximum of var9 and var8 ; return var9 . initialize var4 to zero . return call function func0 with arguments 1 , var1 , var2 , var3 , var4 , var5
you are given arrays of numbers var0 and var1 . set var2 to the length of var0 . initialize var3 to 0 . you have to set var4 to the length of var1 . initialize var6 to 0 . for each var8 in range from 0 to var2 and var9 from 0 to var4 if var1 [ var9 ] is divisible by var0 [ var8 ] let var10 : = var1 [ var9 ] / var0 [ var8 ] , if var10 is bigger than var6 store var10 in var6 , initialize var7 to 1 , and increment var7 if var10 is equal to var6 otherwise . return var7
given a number var1 , an array of numbers var2 and an array of numbers var3 . in func0 you have to store len of var2 in var6 ; you have to store var1 in var7 ; initialize var8 to - 2147483648 ; for each var9 between 0 and var6 ( exclusive ) assign var4 - th element of var2 to var10 , while incrementing var4 , assign var5 - th element of var3 to var11 , while incrementing var5 , set var8 to maximum between var10 - maximum of var11 - var7 and 0 and var8 ; return var8 . return call function func0 with arguments 1 , var1 , var2 , var3 , var4 , var5
you are given integers var0 , var1 , var2 , var3 , var4 , var5 , var6 , var7 , var8 , var9 , var10 and var11 . initialize var12 to 0 . if var1 is negative add var6 to var12 . if var1 is greater than var4 add var7 to var12 . if var2 is negative add var8 to var12 . if var2 is greater than var5 increase var12 by var9 . increment var12 by var10 if var0 is less than zero . if var0 is greater than var3 increment var12 by var11 . you have to return var12
given a string var0 and a string var1 . set var2 to the length of var0 . set var3 to the length of var1 . let var4 : = var0 . set var5 to var1 . if var3 ! = var2 return NO , and initialize var6 to false , set var7 to false , for each var8 between 0 and var2 ( exclusive ) set var6 to true if var4 [ var8 ] = 49 , set var7 to true if var5 [ var8 ] is equal to 49 , if var6 and var7 return YES , and return YES if not var7 and not var6 , otherwise NO otherwise otherwise
we are given a number var0 , an array of numbers var1 and an array of numbers var2 . initialize var10 to zero . let var3 be the length of var1 . you have to create an array of numbers var5 of length var3 . for each var6 between 0 and var3 ( exclusive ) let the var1 [ var9 ] be equal to var7 , also increment var9 , assign var10 - th element of var2 to var8 , while incrementing var10 , if var8 doesn ' t exceed var0 assign var7 to var5 [ var6 ] else assign var7 - the difference of var8 and var0 to var5 [ var6 ] . sort var5 . return var5 [ var3 - 1 ]
given a number var4 , arrays of integers var5 and var6 . in __globals__.__init__ you have to store 0 in __globals__.var2 ; let __globals__.var0 be 0 ; store None in __globals__.var3 ; let __globals__.var1 be 7 + 1000000000 . 0 . initialize var14 to zero . you have to set var13 to zero . you have to store len ( var5 ) in var7 . initialize var8 to - 2147483648 . iterate var9 from 0 to var7 ( exclusive ) let the var5 [ var13 ] be equal to var10 , also increment var13 , assign var14 - th element of var6 to var11 , also increment var14 , let var12 be var10 - var11 - var4 if var11 exceeds var4 else var10 , let var8 : = maximum of var8 and var12 . return var8
you are given a number var0 . var5 is a new array of numbers . increment var0 . while true repeat let var1 : = last number of var0 in decimal notation , let var2 : = last digit of var0 / 10 , you have to store in var3 the value of last digit of var0 / 100 , assign var0 / 1000 to var4 , append var0 to the end of var5 , stop iterating if var3 is not equal to var4 and var2 is not equal to var4 and var1 is not equal to var3 and var1 is not equal to var2 and var1 is not equal to var4 and var3 is not equal to var2 , increment var0 . you have to return var5
given numbers var0 and var1 . return var0 if var0 doesn ' t exceed var1 , otherwise in var2 you have to store 2 * ( var0 - var1 ) , initialize var3 to 0 , you have to set var4 to <unk> . 0 , while var3 is smaller than var4 repeat assign var3 + var4 minus var3 divided by two to var5 , if ( var5 + 1 ) * var5 > = var2 you have to store var5 in var4 , and you have to set var3 to var5 + 1 otherwise , return var3 + var1
you are given integer var0 , an array of numbers var1 and an array of numbers var2 . you have to set var10 to zero . you have to set var9 to zero . you have to store in var3 the value of the length of var1 . initialize var4 to - 2147483648 . for var6 in range from 0 to var3 ( exclusive ) let the var1 [ var9 ] be equal to var7 , also increment var9 , assign var10 - th element of var2 to var8 , also increment var10 , if var8 is bigger than var0 you have to store in var5 the value of var7 - var8 - var0 , and assign var7 to var5 otherwise , you have to set var4 to maximum of var4 and var5 . you have to return var4
you are given integer var1 , a string var2 . in func0 set var4 to var1 ; you have to store var2 in var5 ; var6 is a new integer array ; append - 1 to var6 ; for each element of the array var5 at indices between 0 and len of var5 , exclusive , if it equals to 49 then append var7 to var6 ; append the length of var5 to var6 ; assign var6 to var8 ; set var9 to the length of var8 - 2 ; set var10 to 1 , while var10 + var4 is smaller than the length of var8 increment var3 by ( var8 [ var10 ] - var8 [ the difference of var10 and 1 ] ) * ( var8 [ var4 + var10 ] - var8 [ var10 + var4 - 1 ] ) , increment var10 if var4 is greater than zero , otherwise set var11 to 1 , while var11 is smaller than len of var8 repeat in var12 you have to store var8 [ var11 ] - var8 [ var11 - 1 ] - 1 , add var12 multiplied by ( 1 + var12 ) / 2 to var3 , increment var11 ; return var3 . return call function func0 with arguments 1 , var1 , var2
we are given an array of strings var0 . in func0 return 1 if var0 is bigger than var1 else - 1 if var0 is less than var1 else 0 . var11 is array of strings , which has no elements . assign the length of var0 to var2 . assign var2 - 2 to var4 . while var4 is nonnegative repeat set var5 to 1 , set var6 to the length of var0 [ var4 ] , initialize var7 to 1 , for var8 in range from 0 to 25 ( exclusive ) you have to store var5 + var6 divided by two in var9 , if call func0 with ( substring of var0 [ var4 ] from 0 to var9 , var0 [ 1 + var4 ] ) is greater than zero store var9 - 1 in var6 , and assign 1 + var9 to var5 , set var7 to var9 otherwise , let var0 [ var4 ] be substring of var0 [ var4 ] from 0 to var7 and then decrement var4 . for all var10 from 0 to var2 do the following . add var0 [ var10 ] to var11 . after the loop is ended , return var11
you are given an integer var0 , integer arrays var1 , var2 . initialize var3 to - 2147483648 . you have to store in var4 the value of the length of var1 . for each var7 between 0 and var4 ( exclusive ) assign var9 - th element of var1 to var5 , while incrementing var9 , let the var10 - th element of var2 be equal to var6 , also increment var10 , if var6 is greater than var0 you have to store in var8 the value of var5 - var6 - var0 , set var3 to var8 if var8 is bigger than var3 , and if var5 is greater than var3 set var3 to var5 otherwise . you have to return var3
you are given arrays of numbers var0 and var1 . set var2 to the length of var0 . you have to set var3 to zero . set var4 to the length of var1 . initialize var6 to 0 . for each var8 and var9 in range from 0 to var4 if var1 [ var9 ] is divisible by var0 [ var8 ] set var10 to var1 [ var9 ] / var0 [ var8 ] , if var10 exceeds var6 assign var10 to var6 , initialize var7 to 1 , and increment var7 if var10 is equal to var6 otherwise if var0 [ var8 ] doesn ' t exceed var1 [ var9 ] . return var7
we are given an array of integers var0 , integers var1 , var2 , var3 , var4 and an integer var5 . var15 is array of strings , which has no elements . assign the length of var0 to var6 . initialize var7 to zero . you have to set var12 to zero . for all var14 from 0 to var6 do the following . increment var13 by var0 [ var14 ] , increase var12 by var13 / var5 , reduce var13 by var5 * var13 / var5 , increment var11 by var13 / var4 , reduce var13 by var4 * var13 divided by var4 , add var13 / var3 to var10 , decrement var13 by var3 multiplied by var13 / var3 , increase var9 by var13 / var2 , reduce var13 by var2 * var13 / var2 , increase var8 by var13 / var1 , subtract var13 / var1 * var1 from var13 . add concatenation of concatenation of concatenation of concatenation of concatenation of concatenation of string value of var8 and space and string value of var9 and space and string value of var10 and space and string value of var11 and space and string value of var12 to var15 . append string representation of var13 to the end of var15 . you have to return var15
given an array var0 . initialize var6 to 0 . store len of var0 in var1 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) assign var6 - th element of var0 to var2 [ var3 ] , while incrementing var6 . sort var2 . iterate var5 from 0 to var1 ( exclusive ) increment var4 by var2 [ var1 - 1 - var5 ] * var2 [ var5 ] % <unk> . set var4 to var4 % <unk> . return var4
you are given an array of integers var0 . set var1 to the length of var0 . var2 is a new array of numbers . for each var3 between 0 and var1 append var8 - th element of array var0 ( increment var8 ) to the end of var2 . sort var2 . initialize var5 to <unk> . for var6 in range from 0 to var1 ( exclusive ) set var7 to var2 [ var6 ] modulo var5 * var2 [ var1 - var6 - 1 ] modulo var5 , increase var4 by var7 , set var4 to var4 modulo var5 . you have to return var4
you are given integer var0 , an array of numbers var1 . var9 is an empty array of strings . let var2 : = the length of var1 . create an array var3 with size var2 multiplied by var0 of type boolean . iterate var4 from 0 to var2 , in each iteration you have to do the following : assign true to var3 [ var1 [ var4 ] - 1 ] . initialize var5 to 0 . for as long as var6 is smaller than var2 concatenate concatenation of string representation of var1 [ var6 ] and space to var7 , initialize var8 to 1 , for as long as var8 is smaller than var0 if not var3 [ var5 ] increment var8 , add concatenation of string value of var5 + 1 and space to var7 , increment var5 , add var7 to var9 . you have to return var9
we are given the number var0 . store in var1 the value of var0 . for as long as var0 is not equal to 1 initialize var2 to 1 , for var3 in range from 2 to square root of var0 ( inclusive ) if var0 is divisible by var3 let var2 be maximum between maximum of var3 and var0 / var3 and var2 , add var2 to var1 , let var0 : = var2 . you have to return var1
you are given integer var0 . set var3 to var0 . while var0 is greater than 1 repeat for var1 in range from 2 to var0 / 2 ( inclusive ) reduce var0 in var1 times , increment var3 by var0 , set var2 to 1 , break if var0 is divisible by var1 , increment var3 , stop iterating if var2 is not equal to 1 . you have to return var3
we are given an integer var0 , an array of characters var1 . var2 is a new array of numbers of length the length of var1 + 1 . assign 1 to var2 [ 0 ] ( 0 - based indices ) . for each position var5 in var1 if var1 [ var5 ] is equal to 49 increment var4 , if var0 doesn ' t exceed var4 increment var3 by var2 [ var4 - var0 ] , increment var2 [ var4 ] . return var3
we are given numbers var0 , var1 . var4 is array of strings , which has no elements . let var2 be minimum between var0 and var1 . append string value of 1 plus var2 to var4 . for var3 in range from 0 to var2 ( inclusive ) add concatenation of concatenation of string representation of var3 and space and string value of var2 - var3 to var4 . return var4
you are given numbers var0 , var1 , an array of integers var2 and an array of integers var3 . set var4 to the length of var2 . decrement var0 . decrement var1 . initialize var7 to 0 . for var9 in range from 0 to var4 ( exclusive ) if var9 is smaller than var0 or var9 is bigger than var1 initialize var7 to 1 if var2 [ var9 ] is not equal to var3 [ var9 ] , and you have to store var8 xor var2 [ var9 ] bitwise in var8 , set var8 to var8 xor var3 [ var9 ] bitwise otherwise . return " <unk> " if var7 is equal to one or var8 is not equal to 0 , otherwise " <unk> "
we are given numbers var0 , var1 and var2 . you have to return - 1 if maximum of var2 and var1 is less than var0 otherwise if var2 is bigger than var1 if var0 is less than or equal to var1 increment var3 by var2 divided by var0 ( rounded down ) , increase var3 by var1 divided by var0 , and let var3 : = - 1 if var2 is not divisible by var0 , otherwise add var2 / var0 to var3 , increment var3 by var1 divided by var0 otherwise , assign var2 to var4 , set var2 to var1 , assign var4 to var1 , increment var3 by var2 / var0 , increment var3 by the result of division of var1 by var0 if var0 doesn ' t exceed var1 , otherwise if var2 is not divisible by var0 assign - 1 to var3 , add var2 / var0 to var3 , increment var3 by var1 / var0 otherwise otherwise , you have to return var3 otherwise
given integers var0 , var1 and var2 . var3 is a new integer array . append - 1 to the end of var3 , return var3 if var0 is greater than var2 and var1 is not divisible by var0 or var0 is less than 1 and var1 is larger than var2 or var0 is larger than var1 and var0 is equal to zero or var1 + var2 is negative or var2 is not divisible by var0 and var0 is greater than var1 . append var2 divided by var0 ( rounded down ) + var1 / var0 to the end of var3 . you have to return var3
we are given integers var0 and var3 . in func0 assign var0 to var1 ; set var2 to 2 ; while var2 squared doesn ' t exceed var0 repeat while var0 is divisible by var2 repeat reduce var0 in var2 times , decrement var1 by var1 / var2 if var0 is divisible by var2 and then increment var2 ; reduce var1 by var1 / var0 if var0 is bigger than 1 ; return var1 . set var1 to var0 . set var3 to 1 + var3 / 2 . while var3 is greater than zero repeat set var1 to value returned by function func0 ( var1 ) , if var1 is equal to one stop iterating , decrement var3 . you have to return var1 % 1000000007
you are given arrays of numbers var0 , var1 and var2 . initialize var11 to zero . initialize var9 to 0 . set var3 to the length of var0 . initialize var4 to 0 . iterate var5 from 0 to var3 , in each iteration you have to do the following : set var6 to var9 - th element of array var0 ( increment var9 ) is equal to one , you have to set var7 to var10 - th element of array var1 ( increment var10 ) is equal to one , let var8 be var11 - th element of array var2 ( increment var11 ) is equal to one , increment var4 if var7 and var8 or var6 and var8 or var7 and var6 . return var4
you are given an array of integers var1 . in __globals__.__init__ set __globals__.var0 to <unk> . let var2 : = len of var1 . var3 is a new integer array . for var4 in range from 0 to var2 ( exclusive ) let the var9 - th element of var1 be equal to var5 , also increment var9 , append var5 to the end of var3 . sort var3 . for each var7 between 0 and var2 assign var3 [ var7 ] * var3 [ var2 - var7 - 1 ] % __globals__.var0 to var8 , set var6 to ( var6 + var8 ) % __globals__.var0 . return var6
we are given an integer var0 , a string var1 . let var2 be var0 . let var3 be var1 . while not var3 = empty string repeat set var6 to the length of var3 - 1 , while var6 is non - negative and len of var3 - var6 is less than or equal to the length of var2 and substring of var3 from var6 to the length of var3 is less than var2 decrement var6 , increment var6 , while the length of substring of var3 from var6 to the length of var3 is bigger than 1 and var3 [ var6 ] is equal to 48 increment var6 , assign substring of var3 from var6 to the length of var3 to var7 , store substring of var3 from 0 to var6 in var3 , set var8 to 1 , iterate var9 from 0 to var5 , inside the loop set var8 to var8 * var2 , increase var4 by var8 * var7 , increment var5 . after the loop ends you have to return var4
we are given integer var0 . var7 is new array of strings . var1 is a new var0 by var0 matrix . let var2 : = var0 - 1 . let var3 be var0 divided by 2 . assign 1 to var1 [ var2 ] [ var3 ] . for each var4 between 2 and var0 squared ( inclusive ) if var1 [ ( var2 + 1 ) % var0 ] [ ( var3 + 1 ) modulo var0 ] is equal to 0 assign ( 1 + var2 ) modulo var0 to var2 , assign ( 1 + var3 ) % var0 to var3 else set var2 to ( var0 + var2 - 1 ) % var0 , assign var4 to var1 [ var2 ] [ var3 ] . for each var5 and var6 in range from 0 to var0 add concatenation of string representation of var1 [ var5 ] [ var6 ] and space to var7 . you have to return var7
you are given an array of integers var0 . you have to set var6 to zero . set var1 to len of var0 . initialize var4 to 3 . for var5 in range from 0 to var1 ( exclusive ) assign var6 - th element of var0 to var3 , also increment var6 , if var3 is equal to var4 and var3 is not equal to 3 , and if 3 is not equal to var4 and var3 is equal to 3 reduce var3 by var4 otherwise , increment var2 if var3 is equal to 0 , let var4 be var3 . you have to return var2
you are given integers var4 , var5 and an integer var6 . in __globals__.__init__ create an array __globals__.var0 , containing elements : 8 , 10 , 88 , <unk> , 10000000 , <unk> , <unk> , 10000000 , <unk> , 10000000 , 1 , 10000000 , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> ; create an array __globals__.var1 of type integer , containing elements : 1 , 1 , 62 , <unk> , <unk> , <unk> , <unk> , <unk> , 1 , <unk> , 1 , <unk> , <unk> , 1 , <unk> , 1 , <unk> , 2 , 1 , <unk> , <unk> , 1 , <unk> , 2 , <unk> , 1 , <unk> , <unk> , <unk> , 1 , <unk> , 100000000 , <unk> , 1 , <unk> , <unk> , <unk> , 1 , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , 88 . var8 is a new array of numbers . iterate over all positions var7 in __globals__.var0 append __globals__.var0 [ var7 ] to the end of var8 , you have to return var8 if __globals__.var0 [ var7 ] is equal to var5 and __globals__.var3 [ var7 ] is equal to var4 and var6 = __globals__.var3 [ var7 ] . you have to return var8
we are given a number var0 . var3 is array of strings , which has no elements . append string value of - 1 to the end of var3 , you have to return var3 if var0 is equal to 1 or 2 = var0 . if var0 is less than or equal to 2 add " - 1 " to var3 , and if var0 is even you have to store in var2 the value of ( square of var0 - 4 ) / 4 , add concatenation of concatenation of string representation of var2 and space and string value of var2 + 2 to var3 , set var2 to var0 squared - 1 divided by two , add concatenation of concatenation of string representation of var2 and space and string representation of var2 plus 1 to var3 otherwise otherwise . return var3
you are given an integer var0 , an array of integers var1 . in func0 let var3 : = the length of var1 ; assign var0 - 1 to var4 ; var5 is an empty array of integers ; for each var6 between 0 and var3 ( exclusive ) append var1 [ var2 ] while incrementing var2 to the end of var5 ; sort var5 ; assign var4 / var3 to var7 ; assign call func1 with ( var5 , var7 ) to var8 ; you have to set var9 to ( var4 - var8 [ 0 ] * the length of var5 ) / ( the difference of var8 [ 1 ] and var8 [ 0 ] ) ; return concatenation of concatenation of string representation of var5 [ var7 ] and space and string representation of var5 [ var9 ] . in func1 you have to store in var10 the value of var7 - 1 ; while var10 is non negative and var5 [ var10 ] is equal to var5 [ var7 ] repeat decrement var10 ; you have to store in var11 the value of var7 + 1 ; while var5 [ var11 ] is equal to var5 [ var7 ] and var11 is less than the length of var5 repeat increment var11 ; you have to return ( var10 + 1 , var11 ) . return call function func0 with arguments var0 , var1 , var2
you are given integer var0 , a character array var1 . initialize var2 to zero . var3 is a new array of length len of var1 + 1 . store 1 in var3 [ 0 ] . for every element in var1 at index var5 increment var2 by var1 [ var5 ] minus 48 , increase var4 by var3 [ var2 - var0 ] if var2 - var0 is non - negative , increment var3 [ var2 ] . return var4
we are given an array of numbers var1 . in __globals__.__init__ set __globals__.var0 to <unk> . let var2 : = the length of var1 . initialize var3 to array of integers with length equal to var2 . initialize var4 to array of integers with length equal to var2 . for each var5 between 0 and var2 let the var1 [ var10 ] be equal to var3 [ var5 ] , also increment var10 . after the loop is ended , sort var3 . iterate var6 from 0 to var2 , inside the loop store in var4 [ var6 ] the value of var3 [ var6 ] . for var8 in range from 0 to var2 let var9 be var4 [ var2 minus 1 - var8 ] % __globals__.var0 times var3 [ var8 ] % __globals__.var0 modulo __globals__.var0 , increment var7 by var9 . return var7 modulo __globals__.var0
we are given the number var0 . var14 is array of strings , which has no elements . if var0 is even and var0 is not equal to 2 assign var0 to var1 , assign var1 to the power of 2 to var2 , let var3 be " 4 " , set var4 to var2 / var3 , assign " 1 " to var5 , assign var4 - var5 to var6 , you have to set var7 to var4 + var5 , append string representation of var6 to var14 , append string value of var7 to var14 , and if var0 is odd and var0 is not equal to 1 assign var0 to var8 , you have to store in var9 the value of var8 to the power of 2 , you have to set var10 to " 2 " , assign var9 divided by var10 ( rounded down ) to var11 , assign " 1 " to var12 , set var13 to var11 plus var12 , append string representation of var11 to var14 , append string value of var13 to var14 else add " - 1 " to var14 otherwise . you have to return var14
given arrays of numbers var0 , var1 . let var2 be the length of var0 . store in var3 the value of len of var1 . initialize var6 to 0 . initialize var9 to 0 . for each var8 between 0 and var2 ( exclusive ) for var7 in range from var9 to var3 ( exclusive ) let var10 be minimum of abs of var1 [ var7 ] - var0 [ var8 ] and absolute value of var0 [ var8 ] - var1 [ maximum of 0 and var7 - 1 ] ( 0 - based indices ) , let var6 be var6 if var10 is smaller than var6 else var10 , set var9 to var7 , stop iterating if var1 [ var7 ] is bigger than var0 [ var8 ] or var7 is equal to var3 - 1 . return var6
we are given integer var0 , an array of characters var1 . assign var1 to var2 . set var3 to new char % with ( [ ] ) . set var4 to new < char | int > with ( [ ] ) . iterate var5 from 0 to var0 , inside the loop add var2 [ var5 ] into var3 . initialize var6 to 2147483647 . iterate var8 from 0 to var0 , inside the loop if not var2 [ var8 ] is in var4 insert 0 in var4 at var2 [ var8 ] , insert 1 + value of var2 [ var8 ] in var4 in var4 at var2 [ var8 ] , continue if the length of var4 is less than the length of var3 , otherwise for as long as value of var2 [ var7 ] ( 0 - based indices ) in var4 is greater than 1 insert value of var2 [ var7 ] in var4 minus 1 in var4 at var2 [ var7 ] , increment var7 , you have to store minimum between var6 and 1 + var8 minus var7 in var6 . return var6
we are given the number var0 . if var0 is smaller than 3 return string representation of - 1 , set var1 to 1 , while var0 is even repeat assign 2 * var1 to var1 , reduce var0 in 2 times , return concatenation of concatenation of string representation of 3 times var1 / 4 and space and string representation of 5 multiplied by var1 / 4 if var0 is equal to one , otherwise concatenation of concatenation of string value of var1 * half of var0 squared and space and string representation of var1 multiplied by half of var0 * ( 1 + var0 multiplied by var0 ) otherwise
we are given an integer var0 , an array of strings var1 . store the length of var1 in var2 . you have to store var0 in var3 . iterate var4 from 0 to var2 , inside the loop [ ] . var5 is a new grid of size var2 by var3 . set var7 to var2 - 1 . while var7 is non negative repeat assign var3 minus 1 to var8 , while var8 is non negative repeat set var9 to 1 if var1 [ var7 ] [ var8 ] is equal to 87 else - 1 , let var10 be var9 - var5 [ var7 ] [ var8 ] , continue if var10 is equal to zero , increment var6 , for each var11 between 0 and var7 ( inclusive ) for var12 in range from 0 to var8 ( inclusive ) increment var5 [ var11 ] [ var12 ] by var10 and then decrement var8 and then decrement var7 . return var6
given integers var0 , var1 , var2 , var3 and var4 . store ( var4 plus var0 - 1 ) / var4 in var5 . assign 1 plus var1 / var2 to var7 . for var8 in range from 0 to 60 ( exclusive ) assign var7 + var6 divided by 2 to var9 , set var10 to ( var1 minus var2 * var9 ) / ( var3 - var2 ) , you have to store var9 - var10 in var11 , assign ( var5 - 1 ) * var10 / ( var10 * var3 - var2 * var10 ) + var2 * var3 to var12 , let var13 : = var12 exceeds var9 , if var13 assign var9 to var6 , assign var9 to var7 otherwise . return var6
we are given integer var0 . if var0 is odd set var1 to half of square of var0 , set var2 to 1 plus half of square of var0 , you have to set var2 to var0 squared / 4 - 1 , set var1 to 1 + square of var0 / 4 otherwise . you have to return " - 1 " if var2 is equal to zero or var0 is equal to zero or var1 is equal to zero else concatenation of concatenation of string representation of var1 and space and string value of var2
you are given a number var0 . var7 is an empty array of strings . set var1 to 1 . initialize var2 to 2 . set var3 to var0 divided by two . iterate var5 from 0 to var0 ( exclusive ) for each var6 between 0 and var0 ( exclusive ) if absolute value of var3 minus var6 doesn ' t exceed var4 append string value of var1 to the end of var7 , increment var1 by 2 , append string value of var2 to var7 , increase var2 by 2 otherwise , if var6 is smaller than var0 - 1 add space to var7 , increment var4 if var5 is smaller than var3 , otherwise decrement var4 . after the loop ends return var7
we are given an integer var1 . in struct0 . __init__ in this . var1 you have to store 0 ; set this . var2 to 0 ; assign 0 to this . var0 ; return this . in func1 in this . var1 you have to store var1 . assign call function struct0 . __init__ to this . call func1 with ( this , var0 ) . you have to return string value of - 1 if this . var1 is equal to one or this . var1 is equal to 2 otherwise let this . var1 be 3 * this . var1 divided by 4 ( rounded down ) , let this . var2 be 5 multiplied by this . var1 / 4 if this . var0 is divisible by 4 otherwise if this . var0 is even assign 2 * the result of division of this . var0 * this . var2 by 8 to this . var0 , let this . var2 : = ( 1 + this . var1 * this . var0 / 8 ) * 2 , and let this . var2 : = this . var2 * this . var1 / 2 , set this . var0 to 1 plus half of this . var0 * this . var2 otherwise , you have to return concatenation of concatenation of string representation of this . var2 and space and string representation of this . var0
we are given an integer var0 , an array of characters var1 . set var2 to 2147483647 . you have to store new char % with ( [ ] ) in var4 . store new < char | int > with ( [ ] ) in var5 . for every var6 in var1 add var6 into var4 . for every element in var1 at index var7 insert 0 in var5 at var1 [ var7 ] if not var1 [ var7 ] ( 0 - based indices ) is in var5 , insert value of var1 [ var7 ] in var5 + 1 in var5 at var1 [ var7 ] , continue if the length of var5 is smaller than the length of var4 otherwise while value of var1 [ var3 ] ( 0 - based indices ) in var5 is greater than 1 repeat insert value of var1 [ var3 ] in var5 - 1 in var5 at var1 [ var3 ] , increment var3 , you have to store minimum of var2 and 1 + var7 - var3 in var2 . return var2
we are given an integer var0 . var7 is array of strings , which has no elements . var1 is a new var0 by var0 matrix . set var3 to var0 divided by 2 . while increment var4 minus 1 is less than var0 multiplied by var0 repeat you have to store var4 in var1 [ var2 ] [ var3 ] , assign ( var2 + var0 - 1 ) % var0 to var2 , assign ( var3 + 1 ) % var0 to var3 , set var2 to ( var2 + 2 ) % var0 , set var3 to ( var3 plus var0 - 1 ) % var0 if var1 [ var2 ] [ var3 ] is not equal to 0 . for each var5 and var6 in range from 0 to var0 add concatenation of string value of var1 [ var5 ] [ var6 ] and space to var7 . after the loop is ended , you have to return var7
we are given an array of integers var0 and an array of integers var1 . set var2 to the length of var0 . initialize var3 to 1 . iterate var4 from 0 to var2 , in each iteration you have to do the following : [ ] . for each var5 between 1 and var2 - 1 increment var3 if var1 [ var5 ] is less than var0 [ var5 ] - var0 [ var5 - 1 ] , otherwise if var1 [ var5 ] is smaller than var0 [ 1 plus var5 ] - var0 [ var5 ] increment var0 [ var5 ] by var1 [ var5 ] , increment var3 . increment var3 if var2 is larger than 1 . return var3
you are given a number var0 , an array of numbers var1 . assign the length of var1 to var2 . for var5 in range from 0 to var2 - 1 ( exclusive ) increment var4 by var0 minus var1 [ var5 ] . you have to return var4
you are given a string var0 . var6 is array of strings , which has no elements . store var0 in var1 . while var2 < 1000 repeat set var3 to string value of var2 , for every var5 in var1 increment var4 , add YES to var6 , append string representation of var2 to the end of var6 , you have to return var6 if var4 = the length of var3 if var3 [ var4 ] = var5 and then increment var2 by 8 . add NO to var6 . you have to return var6
we are given a number var0 , an array of numbers var1 . var9 is array of strings , which has no elements . assign len of var1 to var2 . store the sum of the numbers in var1 in var3 . iterate var5 from 0 to var2 , in each iteration you have to do the following : initialize var6 to 0 , assign maximum of 1 and var0 - var3 - var1 [ var5 ] to var7 , assign minimum of the difference of var0 and var2 - 1 and var1 [ var5 ] to var8 , set var6 to var1 [ var5 ] - var8 minus var7 - 1 if var7 is less than or equal to var8 , add concatenation of string representation of var6 and space to var9 . you have to return var9
we are given arrays of integers var1 and var2 . in func0 let var3 : = the length of var1 ; initialize var5 to - 2147483648 ; for var6 in range from 0 to var3 [ ] ; for var7 in range from 0 to var3 ( exclusive ) store var1 [ var7 ] in var8 , let var9 : = var2 [ var7 ] ( indexing is 0 - based ) , increment var4 , assign var8 to var5 if var8 - var9 is bigger than var5 , otherwise if var9 plus var8 is smaller than var1 [ 1 + var7 ] or var3 - 1 is equal to var7 you have to store var9 + var8 in var5 , increment var4 else set var5 to var8 ; you have to return var4 . you have to return call func0 with ( 1 , var1 , var2 )
we are given numbers var0 , var1 , var2 and var3 . set var4 to 1 . for var6 in range from 0 to var2 assign var1 + var0 * var4 to var4 , if var4 doesn ' t exceed var3 increment var5 else stop iterating . you have to return var2 - var5
we are given an array of integers var0 . until var2 less than var1 assign var6 - th element of var0 to var3 [ var2 ] , while incrementing var6 . sort var3 . you have to set var2 to zero . set var1 to the length of var0 . initialize var3 to array of integers with length equal to var1 . create an array var4 with size var1 of type integer . iterate var2 from 0 to var1 , inside the loop let var4 [ var2 ] be var3 [ var1 - var2 - 1 ] . iterate var2 from 0 to var1 set var5 to ( var5 + var3 [ var2 ] multiplied by var4 [ var2 ] ) modulo <unk> . return var5
given an array of numbers var0 . assign the length of var0 to var1 . var2 is a new array of numbers of length var1 - 1 . assign var0 [ 1 ] plus var0 [ 0 ] to var2 [ 0 ] . for var4 in range from 1 to var1 minus 1 ( exclusive ) let var2 [ var4 ] be var0 [ 1 + var4 ] + var2 [ var4 - 1 ] . initialize var5 to array of integers with length equal to var1 - 1 . let var5 [ var1 - 2 ] : = var2 [ var1 - 2 ] . set var6 to var1 minus 3 . while var6 is non negative repeat set var5 [ var6 ] to maximum between var5 [ 1 + var6 ] and var2 [ var6 ] - var5 [ 1 + var6 ] and then decrement var6 . you have to return var5 [ 0 ]
you are given integers var1 , var2 , var3 , var4 and var5 . in func0 store var1 in var6 ; set var7 to var2 ; set var8 to var3 ; assign var4 to var9 ; store var5 in var10 ; store var6 / var7 in var11 ; you have to store var6 / var8 in var12 ; set var13 to var6 divided by call function func1 with arguments var7 , var8 ( rounded down ) ; set var14 to maximum of var11 * var9 + ( var12 minus var13 ) * var10 and var12 * var10 + var9 * ( var11 - var13 ) ; return var14 . in func1 you have to set var7 to | var7 | ; set var8 to absolute value of var8 ; while var8 is not equal to 0 repeat set var15 to var7 modulo var8 , set var7 to var8 , assign var15 to var8 ; after the loop ends you have to return var7 . in func2 return var8 * var7 / call function func2 with arguments var7 , var8 . return value returned by function func0 ( 1 , var1 , var2 , var3 , var4 , var5 )
given numbers var0 and var1 . while 2 is less than or equal to var1 and 1 is less than or equal to var0 or var1 is greater than or equal to 1 and 2 is less than or equal to var0 while var0 is greater than or equal to 1 and var1 is greater than or equal to 2 repeat increment var2 , decrement var0 , subtract 2 from var1 , while var1 is greater than or equal to var0 and 2 is less than or equal to var0 and 1 is less than or equal to var1 increment var2 , subtract 2 from var0 , decrement var1 . you have to return var2
we are given a string var0 . for indices of the array var0 between 1 and the length of var0 ( exclusive ) if the element is equal to var0 [ var1 - 1 ] ( 0 - based indices ) increment var0 [ var1 ] by 1 if var0 [ var1 ] is less than 122 otherwise let var0 [ var1 ] be 97 , if var0 [ var1 ] is less than 122 add 1 to var0 [ var1 ] else assign 97 to var0 [ var1 ] if 1 plus var1 is less than the length of var0 and var0 [ var1 ] is equal to var0 [ 1 + var1 ] . you have to return var0
given numbers var0 and var1 . while 2 multiplied by var1 is larger than var0 and var0 is positive repeat increment var2 , subtract 2 from var1 , decrement var0 . increase var2 by var1 if var0 is greater than or equal to var1 * 2 . you have to return var2
we are given integers var0 , var1 , var2 and var3 . set var4 to var0 . increase var4 by 8 * var2 . if var4 is smaller than var1 and var3 is greater than or equal to var2 return - 1 else if var1 is less than or equal to var4 you have to return 0 , and while var4 is smaller than var1 repeat add 12 * var2 to var4 , subtract var3 * 12 from var4 , increment var5 , you have to return var5 otherwise
we are given integer var0 . if var0 is equal to one return 0 , if var0 is equal to 2 return 3 , and if 3 is equal to var0 return 6 , set var1 to 1 , for each var4 between 1 and var0 ( inclusive ) let var3 : = var2 , store ( 2 * var2 + var1 * 3 ) % 1000000007 in var2 , you have to set var1 to var3 , you have to return var1 otherwise otherwise otherwise
we are given arrays of integers var0 and var1 . set var2 to the length of var0 . initialize var3 to 1 . for each var4 between 0 and var2 ( exclusive ) [ ] . in var5 you have to store var0 [ 0 ] . for each var6 between 1 and var2 - 1 ( exclusive ) if var0 [ var6 ] - var1 [ var6 ] exceeds var5 increment var3 , set var5 to var0 [ var6 ] , if var1 [ var6 ] plus var0 [ var6 ] is less than var0 [ 1 + var6 ] increment var3 , store var0 [ var6 ] + var1 [ var6 ] in var5 , assign var0 [ var6 ] ( 0 - based indices ) to var5 otherwise otherwise . return ( 1 if var2 is greater than 1 else 0 ) + var3
given numbers var0 , var1 . let var1 be var1 % half of var0 * ( 1 plus var0 ) . for all var2 from 0 to var0 do the following . if var1 is smaller than var2 break , reduce var1 by var2 . return var1
given integers var9 , var10 , arrays of integers var4 and var5 . in func0 return 1 if var0 is equal to var3 ; you have to return var6 [ var0 ] [ var1 ] [ var2 + 1e - 1 ] if var6 [ var0 ] [ var1 ] [ var2 plus 1e - 1 ] is not equal to - 1 ; assign var4 [ var0 ] / 1e - <unk> to var7 ; you have to store ( 1 + var0 ) * maximum of var1 minus 1 and 0 ) + ( var2 - 1 if var5 [ var0 ] is equal to - 1 else minimum between 0 . 0 + var2 and var5 [ var0 ] + var3 and var6 ) times ( 1 - var7 ) in var8 ; return 0 if var0 is equal to var3 and var1 is positive or var2 is negative , otherwise var8 . you have to store the length of var4 in var3 . you have to set var11 to zero . you have to set var12 to zero . let var6 : = new real * * with ( 1 plus var3 , var9 + 1 , 500 ) . for each var13 in range from 0 to 1 + var3 and var14 from 0 to 1 + var9 fill var6 [ var13 ] [ var14 ] with - 1 . you have to return call function func0 with arguments 0 , var9 , var10 , var3 , var4 , var5 , var6
we are given the number var0 . set var1 to 1 . set var4 to 2 . while var0 is greater than or equal to var4 repeat let var2 be var3 , set var3 to ( 2 * var3 + 3 * var1 ) modulo 1000000007 , let var1 : = var2 , increment var4 . return var3
we are given a number var0 . for var3 in range from 1 to var0 ( inclusive ) set var2 to 2 to the power of var3 , increment var1 by var2 . return var1
we are given numbers var0 , var1 . var8 is new array of strings . set var2 to ( var1 - 1 ) * var0 + 1 . set var3 to 1 . set var4 to 1 + var0 - var1 . set var5 to var0 * ( 2 * var2 + ( the difference of var0 and 1 ) * var4 ) . append string representation of var5 to var8 . for integer var6 from 0 to var0 and inside it loop another integer var7 from 0 to var0 and add concatenation of string value of var3 and space to var8 , increment var3 if var7 is smaller than var1 minus 1 , otherwise if var7 is equal to var1 - 1 increment var5 by var2 , add concatenation of string representation of var2 and space to var8 , increment var2 . you have to return var8
given numbers var0 , var1 . for var3 in range from 0 to var1 ( inclusive ) let var4 be var3 , assign var0 - 2 * var4 to var5 , set var6 to var1 minus var4 , if var6 is negative continue , if var5 is negative continue , assign minimum between var5 and var6 divided by two to var7 , if var4 + var7 is bigger than var2 set var2 to var7 + var4 . after the loop is ended , return var2
you are given the number var0 , a string var1 . set var2 to new int % with ( [ ] ) . for indices of the array var1 between 0 and var0 ( exclusive ) if the element is equal to 42 add var3 into var2 . after the loop ends set var4 to false . for every var5 in var2 set var6 to 1 , while 4 * var6 plus var5 is less than var0 and not var4 repeat if var6 multiplied by 2 + var5 is in var2 and var5 + var6 is in var2 and 3 * var6 plus var5 is in var2 and var5 + 4 * var6 is in var2 initialize var4 to true and then increment var6 . return " yes " if var4 , otherwise " no "
we are given numbers var0 and var1 . var12 is array of strings , which has no elements . var2 is a new var0 by var0 matrix . let var2 [ 0 ] [ var1 - 1 ] be 1 + var0 * ( var1 - 1 ) . you have to set var3 to var2 [ 0 ] [ var1 - 1 ] . for each var4 between 1 and var0 ( exclusive ) set var2 [ var4 ] [ var1 - 1 ] to 1 + var2 [ var4 - 1 ] [ var1 minus 1 ] + var0 - var1 , increase var3 by var2 [ var4 ] [ var1 - 1 ] . set var5 to 1 . for each var6 and var7 in range from 0 to var1 minus 1 set var2 [ var6 ] [ var7 ] to var5 , increment var5 . set var8 to 1 . iterate var9 from var1 to var0 , inside the loop assign var8 + var2 [ var6 ] ( indexing is 0 - based ) [ var1 - 1 ] to var2 [ var6 ] [ var9 ] , increment var8 . append string representation of var3 to var12 . for every var10 in var2 for each var11 between 0 and the length of var10 - 1 ( exclusive ) add concatenation of string representation of var10 [ var11 ] ( indexing is 0 - based ) and space to var12 , append string value of var10 [ the length of var10 - 1 ] to var12 . you have to return var12
we are given a string var0 . add substring of var0 from 0 to 1 to var1 . for each element of the array var0 at indices between 1 and len of var0 , exclusive , if it equals to var1 [ var2 - 1 ] then if var2 is smaller than the length of var0 minus 1 concatenate 97 to var1 if 97 ! = var1 [ var2 - 1 ] and 97 is not equal to var0 [ var2 plus 1 ] otherwise add 98 to var1 if 98 is not equal to var0 [ 1 + var2 ] and var1 [ var2 - 1 ] ( indexing is 0 - based ) is not equal to 98 otherwise concatenate 99 to var1 , and concatenate 98 to var1 if var1 [ var2 - 1 ] = 97 otherwise add 97 to var1 otherwise , concatenate var0 [ var2 ] to var1 otherwise . return var1
we are given a number var0 . for each var2 between 1 and var0 ( inclusive ) set var3 to 1 , for each var4 between 1 and var2 ( inclusive ) assign 2 * var3 to var3 , after the loop ends increment var1 by var3 . you have to return var1
given numbers var3 , var0 , var1 , var4 and var5 . in func0 while var1 is positive repeat let var2 be var1 , set var1 to var0 modulo var1 , assign var2 to var0 ; you have to return var0 . in func1 you have to return var0 times var1 / value returned by function func0 ( var0 , var1 ) . you have to set var6 to value returned by function func1 ( var0 , var1 ) . assign var3 / var0 to var7 . let var8 : = var3 / var1 . assign var3 / var6 to var9 . if var4 is larger than var5 decrement var8 by var9 , and decrement var7 by var9 otherwise . you have to return var7 * var4 + var8 * var5
we are given numbers var0 , var1 . var7 is array of strings , which has no elements . assign var1 - 1 to var2 . add " - 1 - 1 " to var7 , return var7 if var1 is larger than var0 * 9 or var0 is not equal to 1 and var1 is equal to zero . for var5 in range from 0 to var0 add string representation of minimum of 9 and var1 to var3 , decrement var1 by minimum between 9 and var1 . iterate var6 from 0 to var0 - 1 , inside the loop set var4 to concatenation of string representation of minimum of 9 and var2 and var4 , subtract minimum between 9 and var2 from var2 . let var4 : = concatenation of string representation of 1 + var2 and var4 . add concatenation of concatenation of var4 and space and var3 to var7 . return var7
you are given an integer var0 . for each var2 between 1 and var0 ( inclusive ) increase var1 by 2 to the power of var2 . you have to return var1
we are given a number var6 . in __globals__.__init__ let __globals__.var1 be 0 ; set __globals__.var5 to 0 ; let __globals__.var2 be 0 ; assign 0 to __globals__.var4 ; assign 0 to __globals__.var0 ; store 0 in __globals__.var3 . let __globals__.var1 : = var6 . store 1 in __globals__.var5 . store <unk> in __globals__.var6 . while __globals__.var6 < = __globals__.var5 repeat set __globals__.var4 to __globals__.var6 plus __globals__.var5 divided by two , store in __globals__.var3 the value of __globals__.var2 , increment __globals__.var3 if __globals__.var4 is greater than or equal to half of ( 1 + __globals__.var3 ) * __globals__.var3 , otherwise decrement __globals__.var4 . after the loop is ended , let __globals__.var5 : = the difference of __globals__.var4 and half of ( __globals__.var5 + 1 ) times __globals__.var3 . let __globals__.var0 : = __globals__.var2 if 0 is not equal to __globals__.var3 . you have to return __globals__.var4
we are given integers var1 and var2 , a character array var3 . in __globals__.__init__ set __globals__.var0 to - 2147483648 . var5 is a new array of length 2 . iterate var6 from 0 to var1 for as long as var7 is smaller than var1 increment var5 [ 0 if 97 = var3 [ var7 ] else 1 ] , increment var7 , continue if var2 is greater than or equal to minimum of var5 [ 0 ] and var5 [ 1 ] , subtract 1 from var5 [ 0 if var3 [ var7 ] = 97 else 1 ] , stop iterating , assign maximum between var4 and var7 - var6 to var4 , subtract 1 from var5 [ 0 if var3 [ var6 ] equals to 97 else 1 ] . return var4
given a character array var2 . in __globals__.__init__ assign 1000000007 to __globals__.var1 ; create an array __globals__.var0 , containing elements : <unk> , <unk> , <unk> , 81 , <unk> , 27 , 81 , 81 , 27 , 81 , 81 , 27 , 81 , 81 , 9 , 27 , 81 , 81 , 27 , 9 , 27 , 81 , 81 , 81 , 9 , 27 , 81 , 9 , 27 , 9 , 27 , 81 , 9 , 9 , 27 , 81 . set var3 to 1 . for every element in var2 at index var4 if var2 [ var4 ] ( 0 - based indices ) is greater than or equal to 48 and var2 [ var4 ] doesn ' t exceed 57 set var5 to var2 [ var4 ] - 48 , and if 90 is greater than or equal to var2 [ var4 ] and var2 [ var4 ] is greater than or equal to 65 let var5 : = var2 [ var4 ] - 65 + 10 , if var2 [ var4 ] is greater than or equal to 97 and var2 [ var4 ] is less than or equal to 122 set var5 to var2 [ var4 ] - 97 + <unk> , if var2 [ var4 ] is equal to 45 set var5 to 62 , initialize var5 to 63 if var2 [ var4 ] is equal to 95 otherwise otherwise otherwise otherwise , let var3 be var3 * __globals__.var0 [ var5 ] % __globals__.var1 . return var3
you are given an integer var1 , arrays of characters var2 and var3 . in __globals__.__init__ create an array __globals__.var0 of type integer , containing elements : 31 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 . if var3 = " <unk> " if var1 is equal to 29 return " 12 " else if var1 = 30 you have to return " 11 " else return " 7 " if 31 = var1 , otherwise " 12 " , create an array var4 with size 7 of type integer , set var5 to 4 , for each var6 between 1 and <unk> ( inclusive ) increment var4 [ var5 modulo 7 ] , increment var5 , return string representation of var4 [ var1 - 1 ] otherwise
you are given arrays of numbers var0 , var1 . assign len of var0 to var2 . assign len of var1 to var3 . set the value of var5 to be the sum of numbers in var0 . create an array var7 with size var3 of type integer . iterate var8 from 0 to var3 , in each iteration you have to do the following : you have to store var12 - th element of array var1 - 1 in var7 [ var8 ] . create an array var9 with size var2 of type boolean . for var10 in range from 0 to var3 ( exclusive ) reduce var5 by var0 [ var7 [ var10 ] ] , increase var4 by var0 [ var7 [ var10 ] ] * var5 , assign true to var9 [ var7 [ var10 ] ] . for var11 in range from 0 to var2 if not var9 [ var11 ] and not var9 [ ( var11 + 1 ) % var2 ] add var0 [ var11 ] * var0 [ ( 1 + var11 ) % var2 ] to var4 . return var4
you are given arrays of numbers var0 , var1 . initialize var10 to zero . let var2 be the length of var0 . set var3 to len of var1 . set the value of var4 to be the sum of numbers in var0 . for var7 in range from 0 to var3 ( exclusive ) let the var1 [ var10 ] be equal to var8 , also increment var10 , decrement var8 , decrement var4 by var0 [ var8 ] , increment var6 by var4 * var0 [ var8 ] , you have to store 0 in var0 [ var8 ] ( indexing is 0 - based ) . for each var9 between 0 and var2 ( exclusive ) increment var6 by var0 [ ( var9 + 1 ) % var2 ] * var0 [ var9 ] . you have to return var6
given numbers var0 , var1 and var2 , an array of integers var3 . assign the length of var3 to var4 . you have to set var5 to zero . var6 is a new grid of size 2 by 1 plus var0 * var1 + 1 . for var7 in range from 0 to var1 ( inclusive ) assign 1 to var6 [ var4 and 1 bitwise ] [ 0 ] . after the loop is ended , assign var4 - 1 to var8 . while var8 is nonnegative repeat for each var9 between 0 and var0 ( inclusive ) for var10 in range from 0 to var1 ( inclusive ) store ( ( var6 [ var8 and 1 bitwise ] [ var9 - 1 ] [ var10 - var3 [ var8 ] if var10 is greater than or equal to var3 [ var8 ] and var9 is greater than zero else var2 ) + var6 [ var8 and 1 bitwise ] [ var9 ] ) modulo var2 in var6 [ var8 ] [ var10 ] and then decrement var8 . return var6 [ 0 ] [ var0 ] [ var1 ]
given an array of integers var0 . var7 is an empty array of integers . in var1 you have to store the length of var0 . append 1 to var7 , you have to return var7 if var1 is equal to one . for as long as var5 is smaller than var1 - 1 let var5 be var4 , let var6 be var5 , while var0 [ var5 + 1 ] ( indexing is 0 - based ) is greater than or equal to var0 [ var5 ] and var5 is smaller than var1 - 1 increment var5 , let var4 be 1 + var5 , while var0 [ var5 ] is greater than or equal to var0 [ var5 + 1 ] and var5 is smaller than var1 - 1 increment var5 , set var2 to maximum of var2 and 1 + var5 - var6 . append var2 to the end of var7 . return var7
given numbers var0 and var1 , a character array var2 . initialize var3 to array of integers with length equal to 100005 . store in var3 [ 0 ] the value of 0 . for each var4 between 1 and var0 ( inclusive ) set var3 [ var4 ] to 1 + var3 [ var4 - 1 ] if var2 [ var4 - 1 ] is equal to 97 otherwise set var3 [ var4 ] to var3 [ var4 - 1 ] . initialize var5 to 1 . set var6 to 1 + var0 . while var5 is smaller than var6 repeat assign var5 + var6 divided by 2 to var7 , initialize var8 to 0 , initialize var9 to 1 , while var0 is greater than or equal to var9 + var7 - 1 repeat initialize var8 to 1 if var3 [ var7 + var9 - 1 ] - var3 [ var9 - 1 ] is less than or equal to var1 , if var1 is greater than or equal to var7 - var3 [ var9 + var7 - 1 ] ( 0 - based indices ) - var3 [ the difference of var9 and 1 ] set var8 to 1 and then increment var9 , if var8 is equal to one set var5 to 1 plus var7 , and store var7 in var6 otherwise . you have to return var5 - 1
given numbers var0 and var1 . var3 is new array of strings . initialize var2 to 1 . while var1 is non negative repeat append string value of var1 to var3 , break if var1 - var2 is negative otherwise if var1 - var2 is equal to zero add " 0 " to var3 , break , subtract var2 from var1 , increment var2 , set var2 to 1 if var2 is greater than var0 otherwise . return var3
we are given numbers var0 and var1 . if var0 exceeds var1 let var2 : = var1 , and let var2 be var0 otherwise . you have to set var3 to ( var1 + var0 ) divided by 3 . return var3 if var2 is bigger than var3 , otherwise var2
we are given integers var0 , var1 . let var2 be var0 . assign var1 to var3 . set var4 to shift 1 left var2 + 1 bits - 2 . initialize var5 to 76 . for var6 in range from 0 to var2 ( exclusive ) you have to store var2 - var6 - 1 in var7 , if var5 is equal to 76 subtract shift 1 left 1 plus var7 bits - 1 from var4 , initialize var5 to 82 if var3 doesn ' t exceed shift 1 left var7 bits otherwise decrement var3 by shift 1 left var7 bits , if var5 is equal to 82 decrement var4 by shift 1 left 1 plus var7 bits - 1 , set var5 to 76 . you have to return var4
you are given an integer var1 , an array of arrays of characters var2 . in func0 you have to store in var3 the value of the length of var2 ; set var4 to var1 ; iterate var5 from 0 to var3 , in each iteration you have to do the following : [ ] ; var6 is a new array of numbers of length var3 ; you have to set var9 to var4 - 1 ; while var9 is nonnegative repeat set var10 to var3 - 1 , while var10 is non negative repeat increment var7 by var6 [ var10 ] , in var11 you have to store 1 if var2 [ var10 ] [ var9 ] is equal to 87 else - 1 , if var11 is not equal to var7 increment var8 , let var12 be var11 - var7 , increase var7 by var12 , increase var6 [ var10 ] by var12 and then decrement var10 and then decrement var9 ; return var8 . you have to return call function func0 with arguments 1 , var1 , var2
we are given numbers var0 and var1 . while var1 is greater than 1 or var0 is greater than 1 and var1 is positive and var0 is positive repeat if var1 doesn ' t exceed var0 subtract 2 from var0 , decrement var1 else reduce var1 by 2 , decrement var0 , increment var2 . you have to return var2
we are given integers var1 , var2 and var7 . in func0 set var5 to var0 [ var1 ] divided by var0 [ var3 ] ( rounded down ) * var0 [ var1 - var3 ] ; set var6 to var0 [ var2 ] / var0 [ var4 ] multiplied by var0 [ var2 - var4 ] ; you have to return var6 * var5 . var0 is a new array of length 31 . assign 1 to var0 [ 0 ] . let var0 [ 1 ] be 1 . for each var8 between 2 and 30 ( inclusive ) assign var0 [ var8 - 1 ] * var8 to var0 [ var8 ] . for each var10 between 4 and var1 ( inclusive ) if var7 - var10 exceeds var2 continue , let var11 be var7 - var10 , continue if var11 is smaller than 1 , you have to store in var12 the value of value returned by function func0 ( var0 , var1 , var2 , var10 , var11 ) , increment var9 by var12 . you have to return string value of var9
we are given arrays of numbers var0 and var1 . let var2 be the length of var0 . initialize var3 to 2 . for var4 in range from 0 to var2 ( exclusive ) if var4 is bigger than 1 if var0 [ var4 - 2 ] is less than var0 [ var4 - 1 ] - var1 [ var4 - 1 ] increment var3 , and increment var3 , increase var0 [ var4 - 1 ] by var1 [ var4 - 1 ] if var0 [ var4 ] is bigger than var1 [ var4 - 1 ] + var0 [ var4 - 1 ] otherwise . return var2 if var2 is smaller than 2 , otherwise var3
given numbers var7 , var5 , var6 , var8 and var9 . in __globals__.__init__ assign 1e - <unk> to __globals__.var0 ; you have to set __globals__.var1 to 7 + 1000000000 . 0 . in func0 let var5 : = var2 if var2 is larger than var3 else var3 ; set var6 to var2 if var2 is less than var3 else var3 ; let var4 be var6 ; while var5 is not divisible by var6 repeat you have to set var4 to var5 modulo var6 , set var5 to var6 , assign var4 to var6 ; after the loop is ended , return var4 . assign ( var7 / var5 - the result of division of var7 multiplied by call func0 with ( var5 , var6 ) by var5 * var6 ) * var8 to var10 . increase var10 by var9 * ( var7 / var6 minus var7 multiplied by call func0 with ( var5 , var6 ) / var5 * var6 ) . if var8 is bigger than var9 increment var10 by var8 multiplied by var7 * call function func0 with arguments var5 , var6 / var5 multiplied by var6 , and increment var10 by var9 multiplied by call function func0 with arguments var5 , var6 * var7 / var6 multiplied by var5 otherwise . you have to return var10
you are given arrays of integers var0 and var1 . in var2 you have to store the length of var0 . iterate var3 from 0 to var2 ( exclusive ) [ ] . assign - 1 to var4 . initialize var5 to zero . for var6 in range from 0 to var2 if var6 is equal to 0 you have to set var4 to var0 [ var6 ] , increment var5 , if var0 [ var6 ] minus var1 [ var6 ] is larger than var4 you have to store var0 [ var6 ] in var4 , increment var5 , if var6 is equal to var2 - 1 or var1 [ var6 ] plus var0 [ var6 ] is smaller than var0 [ 1 + var6 ] assign var1 [ var6 ] + var0 [ var6 ] to var4 , increment var5 , you have to store var0 [ var6 ] in var4 otherwise otherwise otherwise . you have to return var5
you are given integers var0 and var1 , arrays of integers var2 and var3 . var9 is array of strings , which has no elements . store the length of var2 in var4 . you have to set var5 to zero . decrement var0 . iterate var7 from 0 to var0 if var2 [ var7 ] is not equal to var3 [ var7 ] add " <unk> " to var9 , you have to return var9 . iterate var8 from var1 to var4 , inside the loop if var2 [ var8 ] is not equal to var3 [ var8 ] add " <unk> " to var9 , return var9 . add " <unk> " to var9 . return var9
we are given numbers var0 and var1 . let var2 be minimum between var0 minus ( var0 * 2 minus var1 ) / 3 and minimum of var0 and var1 . if 3 is less than or equal to var0 + var1 and 1 doesn ' t exceed var1 and 3 is less than or equal to var0 assign var0 - var2 multiplied by 3 to var3 , set var4 to var1 - 3 * var2 , if var0 plus var1 - var2 multiplied by 3 is less than zero you have to return var2 - 1 , return var2 + 1 if 1 doesn ' t exceed var4 and 1 doesn ' t exceed var3 and var3 + var4 is greater than or equal to 3 , otherwise var2 otherwise else you have to return 0
given a character array var6 . in func0 set var2 to the length of var0 ; initialize var3 to 99 ; var4 is new boolean array of length 26 ; let var4 [ var0 [ var1 - 1 ] - 97 ] be true ; let var4 [ var0 [ 1 + var1 ] - 97 ] be true if var1 + 1 is smaller than the length of var0 ; for all var5 from 0 to 26 do the following . if not var4 [ var5 ] return 97 + var5 ; you have to return 97 . let var0 be var6 . for indices of the array var0 between 1 and len of var6 ( exclusive ) if the element is equal to var0 [ var1 - 1 ] assign call function func0 with arguments var0 , var1 to var0 [ var1 ] . return var0
you are given integers var0 , var1 , var2 and var3 . increase var0 by shift var2 left 3 bits . if var2 is smaller than var3 and var0 is less than var1 assign - 1 to var4 , and if var1 is less than or equal to var0 otherwise if var2 is larger than var3 you have to store rounded up the result of division of var1 - var0 by ( var2 - var3 ) / 12 in var4 , and let var4 be - 1 otherwise otherwise . you have to return var4
given an array var0 . assign the length of var0 to var1 . you have to create an array of numbers var2 of length var1 . for each var4 between 0 and var1 ( exclusive ) assign var7 - th element of var0 to var2 [ var4 ] , while incrementing var7 . sort var2 . assign len of var2 - 1 to var5 . while 3 doesn ' t exceed var5 repeat if var2 [ var5 - 1 ] is equal to var2 [ var5 ] or var2 [ var5 ] - 1 = var2 [ var5 - 1 ] let var6 be var5 - 2 , while 1 doesn ' t exceed var6 and 3 doesn ' t exceed var5 repeat continue if var2 [ var6 ] is not equal to var2 [ var6 - 1 ] and var2 [ var6 ] - 1 is not equal to var2 [ var6 - 1 ] otherwise if var2 [ var5 - 1 ] is equal to var2 [ var5 ] or var2 [ var5 ] = var2 [ the difference of var5 and 1 ] and var2 [ var6 minus 1 ] = var2 [ var6 ] or var2 [ var6 ] is equal to var2 [ var5 - 1 ] increment var3 by var2 [ var5 - 1 ] * var2 [ var6 - 1 ] , let var5 : = var6 minus 1 , stop iterating and then decrement var6 else continue and then decrement var5 . you have to return var3
given an array of integers var0 . set var1 to the length of var0 . for var2 in range from 0 to var1 ( exclusive ) [ ] . var3 is a new integer array of length 5 + var1 . for var4 in range from 0 to var1 ( exclusive ) let var3 [ var4 + 2 ] be var3 [ 1 + var4 ] , for all var5 from 0 to 2 do the following . let var6 be var4 , while var6 is non - negative repeat stop iterating if var0 [ var6 ] and shift 1 left the difference of var4 and var6 + var5 and 1 bitwise is equal to 0 , you have to set var3 [ var4 + 2 ] ( indexing is 0 - based ) to maximum between var3 [ var4 + 2 ] and 1 + var4 - var6 + var3 [ var6 ] and then decrement var6 . you have to return var1 minus var3 [ var1 + 1 ]
we are given arrays of numbers var0 and var1 . store len of var0 in var3 . assign the length of var1 to var4 . you have to set var6 to zero . let var8 : = var4 - 1 . assign var7 + var8 divided by two to var9 . for every var10 in var0 you have to set var7 to zero , set var8 to var4 minus 1 , while var8 minus var7 is greater than 1 repeat assign half of var8 + var7 to var9 , assign var9 to var7 , assign var9 to var8 if var1 [ var9 ] is equal to var10 otherwise if var1 [ var9 ] is smaller than var10 you have to store var9 in var7 , if var1 [ var9 ] exceeds var10 you have to store var9 in var8 otherwise , set var2 to maximum between var2 and minimum between abs of var1 [ var7 ] - var10 and | var1 [ var8 ] - var10 | . return var2
we are given integer arrays var0 and var1 . in func0 set var4 to the length of var0 ; var5 is a new two dimensional array with var4 x 2 size ; for all var6 from 0 to var4 do the following . assign var2 - th element of var0 to var5 [ var6 ] [ 0 ] , while incrementing var2 , assign var3 - th element of var1 to var5 [ var6 ] [ 1 ] , while incrementing var3 ; set var7 to minimum between 2 and var4 ; for each var8 between 1 and var4 - 1 ( exclusive ) increment var7 if var5 [ var8 ] [ 0 ] - var5 [ var8 - 1 ] [ 0 ] is greater than var5 [ var8 ] [ 1 ] , otherwise if var5 [ 1 + var8 ] [ 0 ] minus var5 [ var8 ] [ 0 ] is greater than var5 [ var8 ] [ 1 ] increment var7 , increase var5 [ var8 ] [ 0 ] by var5 [ var8 ] [ 1 ] ; you have to return var7 . initialize var3 to zero . you have to return call function func0 with arguments var0 , var1 , var2 , var3
you are given integers var4 , var5 and an integer var6 . in __globals__.__init__ create an array __globals__.var0 , containing elements : 8 , 10 , 88 , <unk> , 10000000 , <unk> , <unk> , 10000000 , <unk> , 10000000 , 1 , 10000000 , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> ; create an array __globals__.var1 of type integer , containing elements : 1 , 1 , 62 , <unk> , <unk> , <unk> , <unk> , <unk> , 1 , <unk> , 1 , <unk> , <unk> , 1 , <unk> , 1 , <unk> , 2 , 1 , <unk> , <unk> , 1 , <unk> , 2 , <unk> , 1 , <unk> , <unk> , <unk> , 1 , <unk> , 100000000 , <unk> , 1 , <unk> , <unk> , <unk> , 1 , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , 88 . var8 is a new array of numbers . iterate over all positions var7 in __globals__.var0 append __globals__.var0 [ var7 ] to the end of var8 , you have to return var8 if __globals__.var0 [ var7 ] is equal to var5 and __globals__.var3 [ var7 ] is equal to var4 and var6 = __globals__.var3 [ var7 ] . you have to return var8
you are given integer arrays var0 and var1 . initialize var8 to 0 . set var2 to len ( var0 ) . var3 is a new var2 by 2 matrix . for all var4 from 0 to var2 do the following . assign var8 - th element of var0 to var3 [ var4 ] [ 0 ] , while incrementing var8 , assign var9 - th element of var1 to var3 [ var4 ] [ 1 ] , also increment var9 . initialize var5 to - 2147483648 . set var6 to 1 . for all var7 from 0 to var2 - 1 do the following . increment var6 , let var5 be var3 [ var7 ] [ 0 ] if var3 [ var7 ] [ 0 ] - var3 [ var7 ] [ 1 ] is larger than var5 , otherwise increment var6 , set var5 to var3 [ var7 ] [ 0 ] + var3 [ var7 ] [ 1 ] if var3 [ var7 ] [ 0 ] plus var3 [ var7 + 1 ] [ 0 ] is less than var3 [ var7 ] [ 1 ] , otherwise let var5 be var3 [ var7 ] [ 0 ] . return var6
you are given an integer var0 , a string var1 . you have to return " 1 " if var0 is equal to one , otherwise initialize var3 to 1 , let var4 : = the length of var1 , var5 is a new array of numbers of length 128 , you have to store 1 in var5 [ var1 [ 0 ] ] , while var3 is less than var0 repeat you have to store 1 + var3 - var2 in var4 if var5 [ var1 [ var3 ] ] is equal to 0 , increment var5 [ var1 [ var3 ] ] , while var5 [ var1 [ var2 ] ] is greater than 1 and var2 is less than var3 decrement var5 [ var1 [ var2 ] ] , increment var2 , assign minimum of var4 and 1 + var3 minus var2 to var4 , after the loop ends increment var3 , return string representation of var4
given numbers var0 and var1 . set var2 to var1 - 1 . set var3 to 1 . create an array var4 , containing elements : 1 , 1 . for var5 in range from 0 to var0 ( exclusive ) set var6 to ( 0 , 0 ) , if var2 and shift 1 left var5 bits bitwise is equal to 0 in var6 [ 0 ] you have to store 1 + var4 [ 1 ] , let var6 [ 1 ] : = var4 [ 1 ] plus var3 + 1 else set var6 [ 0 ] to var4 [ 0 ] + 1 + var3 , let var6 [ 1 ] be var4 [ 0 ] + 1 , let var3 be 1 + var3 times 2 , let var4 be var6 . return var4 [ 0 ] - 1
we are given a number var0 . let var1 be " 3 " . assign " 4 " to var2 . let var3 be " 5 " . assign " 2 " to var4 . set var5 to var0 / var1 , you have to return concatenation of concatenation of string representation of var2 * var5 and space and string value of var5 * var3 if var0 is divisible by var1 , otherwise if var0 is divisible by var2 you have to set var6 to var0 / var2 , return concatenation of concatenation of string value of var6 * var1 and space and string value of var6 * var3 , and set var7 to var0 / var3 , you have to return concatenation of concatenation of string representation of var1 * var7 and space and string representation of var2 * var7 if var0 is divisible by var3 otherwise if " 1 " is equal to var0 or var0 is equal to " 2 " you have to return " - 1 " , return concatenation of concatenation of string representation of ( var0 squared minus " 1 " ) / var4 and space and string representation of ( var0 squared - " 1 " ) / var4 + " 1 " if var0 is not divisible by var4 , otherwise concatenation of concatenation of string value of var0 squared divided by var2 - " 1 " and space and string representation of " 1 " + half of var0 to the power of var2 otherwise otherwise
given a number var0 . set var1 to var0 . if var1 is smaller than 3 you have to return string value of - 1 , and let var4 : = var1 divided by two , set var2 to var4 squared minus 1 , assign 1 + var4 squared to var3 if var1 is even otherwise let var2 : = var1 squared - 1 divided by 2 , let var3 be half of square of var1 - 1 plus 1 , return concatenation of concatenation of string value of var2 and space and string value of var3 otherwise
you are given arrays of integers var0 , var1 . let var2 : = new < int | bool > with ( [ ] ) . assign the length of var0 to var3 . assign the length of var1 to var4 . initialize var5 to zero . you have to set var6 to zero . iterate var7 from 0 to var3 , in each iteration you have to do the following : insert false in var2 at var7 , increase var5 by var0 [ var7 ] . iterate var8 from 0 to var4 ( exclusive ) insert true in var2 at var1 [ var8 ] - 1 , increase var6 by var0 [ var1 [ var8 ] - 1 ] . initialize var10 to zero . for var11 in range from 0 to var4 ( exclusive ) increase var9 by ( var5 - var0 [ var1 [ var11 ] minus 1 ] ) * var0 [ var1 [ var11 ] - 1 ] . add var6 * ( var5 minus var6 ) to var9 . divide var9 by 2 . iterate var12 from 0 to var3 ( exclusive ) if value of ( var12 + 1 ) modulo var3 in var2 equals to false and value of var12 % var3 in var2 is equal to false add var0 [ var12 modulo var3 ] ( 0 - based indices ) * var0 [ ( var12 plus 1 ) % var3 ] to var9 . return var9
we are given numbers var0 , var1 . var3 is a new integer array . for as long as var1 is greater than zero for var2 in range from 1 to var0 ( inclusive ) reduce var1 by var2 if var1 minus var2 is non - negative otherwise append var1 to the end of var3 , you have to return var3 . append 0 to the end of var3 . you have to return var3
given integer var1 , an array of integers var2 . in __globals__.__init__ in __globals__.var0 you have to store 7 + 1000000000 . 0 . let var3 : = len ( var2 ) . you have to store var1 in var4 . for var5 in range from 0 to var3 ( exclusive ) [ ] . var6 is a new grid of size var3 + 1 by 1 + var3 . set var6 [ 0 ] [ 0 ] to 1 . for integer var7 from 0 to var3 and inside it loop another integer var8 from 0 to var7 + 1 and if var8 + var2 [ var7 ] is equal to var4 let var6 [ var7 plus 1 ] [ var8 ] ( 0 - based indices ) be ( var6 [ var7 ] [ var8 ] + var6 [ 1 + var7 ] [ var8 ] ) % __globals__.var0 , if var8 - 1 is non - negative in var6 [ var7 plus 1 ] [ var8 ] you have to store ( var6 [ var7 ] [ var8 - 1 ] + var6 [ 1 plus var7 ] ( indexing is 0 - based ) [ var8 ] ) modulo __globals__.var0 , set var6 [ 1 + var7 ] [ var8 ] to ( var6 [ var7 ] [ var8 plus 1 ] ( 0 - based indices ) times var6 [ var7 ] [ var8 + 1 ] modulo __globals__.var0 ) modulo __globals__.var0 , set var6 [ 1 plus var7 ] [ var8 ] to ( var6 [ var7 + 1 ] [ var8 ] + var6 [ var7 ] [ var8 ] ) % __globals__.var0 , set var6 [ var7 + 1 ] [ var8 ] to ( var6 [ var7 ] [ var8 ] + var6 [ 1 + var7 ] [ var8 ] ) % __globals__.var0 if var6 [ var7 ] [ var8 ] + 1 is equal to var4 otherwise . return var6 [ var3 ] [ 0 ]
we are given integer var0 , arrays of characters var1 and var2 . in func0 you have to return 1 if var0 is greater than var1 else - 1 if var0 is smaller than var1 else 0 . set var3 to var0 . set var4 to var2 . if value returned by function func0 ( var4 , " <unk> " ) is equal to zero decrement var3 , initialize var5 to zero , initialize var6 to 0 , iterate var7 from 5 - 1 to <unk> , inside the loop increment var5 if var7 is equal to var3 , if increment var7 = 7 , return var5 else you have to return 12 if var3 < = 29 , otherwise return 11 if 30 is greater than or equal to var3 , otherwise 7
we are given arrays of numbers var0 and var1 . set var2 to the length of var0 . for each var3 between 0 and var2 ( exclusive ) [ ] . iterate var6 from 0 to var2 , inside the loop if var6 is equal to zero or var0 [ var6 ] - var1 [ var6 ] exceeds var4 increment var5 , store var0 [ var6 ] in var4 else increment var5 , let var4 : = var1 [ var6 ] plus var0 [ var6 ] if var6 is equal to var2 - 1 or var1 [ var6 ] + var0 [ var6 ] is smaller than var0 [ var6 + 1 ] otherwise you have to store in var4 the value of var0 [ var6 ] . you have to return var5
you are given an integer var0 . store var0 in var1 . if var1 is even assign half of var1 to var2 , and set var2 to 1 + var1 divided by 2 otherwise . return var2
we are given numbers var0 and var1 . if var1 times 2 doesn ' t exceed var0 assign var1 to var2 , and assign var0 to var2 if 2 * var0 is less than or equal to var1 , otherwise let var2 : = ( var1 + var0 ) divided by 3 ( rounded down ) otherwise . you have to return var2
we are given numbers var0 , var1 . while true repeat stop iterating if var1 is equal to 1 and var0 is equal to one , if var1 is equal to zero or var0 is equal to 0 stop iterating , if var0 is bigger than var1 increment var2 , subtract 2 from var0 , decrement var1 else increment var2 , reduce var1 by 2 , decrement var0 if var0 is less than var1 , otherwise increment var2 , decrement var0 , subtract 2 from var1 . return var2
we are given numbers var0 and var1 . return 0 if var1 is equal to one and var0 is equal to one , otherwise if var0 is bigger than var1 you have to set var2 to var1 , if var0 is bigger than 2 * var1 you have to set var3 to 2 * var1 , and set var3 to var0 otherwise else if var0 is less than var1 you have to store var0 in var2 , you have to store 2 * var0 in var3 if var1 is larger than var0 multiplied by 2 otherwise assign var1 to var3 , and let var2 : = var0 , in var3 you have to store var1 otherwise , if var2 is even assign var2 divided by 2 to var4 , set var5 to var4 , and you have to store rounded up var2 divided by two + 1 in var4 , let var5 be rounded up var2 divided by two otherwise , set var6 to var3 - var4 , return var6 divided by 3 + var5
we are given a character array var1 . in func0 you have to store var1 in var2 ; for each element of the array var2 at indices between 1 and the length of var2 , exclusive , if it equals to var2 [ var3 - 1 ] then initialize var4 to 97 , while var4 doesn ' t exceed 122 repeat if var2 [ var3 - 1 ] ! = var4 and the length of var2 is less than or equal to var3 + 1 or var4 is not equal to var2 [ var3 + 1 ] let var2 [ var3 ] : = var4 , stop iterating and then increase var4 by 1 ; return var2 . you have to return call func0 with ( 1 , var1 )
given a string var1 . in func0 assign var1 to var2 ; assign the length of var2 to var3 ; for each element of the array var2 at indices between 1 and var3 , exclusive , if it equals to var2 [ var4 - 1 ] then initialize var5 to 97 , while 122 is greater than or equal to var5 repeat if not var2 [ 1 + var4 ] is equal to var5 and 1 + var4 is less than var3 and var2 [ the difference of var4 and 1 ] is not equal to var5 store in var2 [ var4 ] the value of var5 , break and then add 1 to var5 ; after the loop is ended , you have to return var2 . return call func0 with ( 1 , var1 )
we are given integers var1 and var2 . in func0 set var3 to var1 ; set var4 to var2 ; while var4 is positive and var3 is greater than zero reduce var3 by 2 , decrement var4 , if var4 is non negative and var3 is non negative increment var5 , and stop iterating otherwise if var4 doesn ' t exceed var3 , otherwise decrement var3 , reduce var4 by 2 , increment var5 if var4 is non negative and var3 is nonnegative otherwise stop iterating ; return var5 . you have to return value returned by function func0 ( 1 , var1 , var2 )
we are given integers var0 , var1 . in func0 return the greatest common divisor between var0 and var1 . let var2 : = var0 / call func0 with ( var0 , var1 ) times var1 . you have to store var2 divided by var0 ( rounded down ) in var3 . assign var2 / var1 to var4 . increment var3 if var0 exceeds var1 otherwise increment var4 . if var3 is greater than var4 return " <unk> " , return " <unk> " if var3 is smaller than var4 , otherwise " <unk> " otherwise
you are given integer var0 , an array of numbers var1 and an array of numbers var2 . initialize var13 to 0 . let var3 : = the length of var1 . you have to create an array of numbers var4 of length var3 . create an array var5 with size var3 of type integer . initialize var6 to array of reals with length equal to var3 . iterate var7 from 0 to var3 , in each iteration you have to do the following : assign var12 - th element of var1 to var8 , while incrementing var12 , let the var2 [ var13 ] be equal to var9 , also increment var13 , let var4 [ var7 ] be 1 + var9 - var8 , store var9 divided by var0 minus var8 divided by var0 in var5 [ var7 ] , if var8 is divisible by var0 increment var5 [ var7 ] , let var6 [ var7 ] : = 1 . 0 - var5 [ var7 ] / var4 [ var7 ] . set var10 to 0 . 0 . for each var11 between 0 and var3 ( exclusive ) increment var10 by ( 1 . 0 - var6 [ ( 1 + var11 ) modulo var3 ] * 2 . return 1000 * var10
we are given numbers var0 and var1 . var3 is an empty array of strings . append string value of var1 times ( 6 * var0 - 1 ) to var3 . for var2 in range from 0 to var0 add concatenation of concatenation of concatenation of concatenation of concatenation of string value of ( var2 times 6 + 1 ) * var1 and space and string value of var1 * ( 2 plus var2 * 6 ) and space and string value of ( 3 + var2 multiplied by 6 ) * var1 and space and string representation of var1 * ( 5 + 6 * var2 ) to var3 . return var3
you are given integers var4 , var5 and var6 . in func0 set var2 to 1 ; for all var3 from 0 to var1 do the following . set var2 to var2 * ( var0 - var3 ) , divide var2 by 1 + var3 ; return var2 . for each var3 between 4 and var6 increase var7 by call func0 with ( var4 , var3 ) multiplied by call func0 with ( var5 , var6 - var3 ) . you have to return var7
given integers var0 and var1 , a string var2 . initialize var3 to zero . set var8 to ( 0 , 0 ) . while var6 is smaller than var0 repeat increment var8 [ var2 [ var6 ] - 97 ] , decrement var8 [ var2 [ var5 ] - 97 ] , increment var5 if minimum of var8 [ 0 ] and var8 [ 1 ] exceeds var1 otherwise increment var7 , increment var6 . you have to return var7
given integer var0 . assign var0 to var1 . set var4 to 1 . assign var1 to var6 . if var1 is smaller than 10 you have to return var1 else while var1 divided by 10 is positive repeat set var5 to 1 , divide var1 by 10 , let var7 be var4 , for each var8 between 1 and var7 ( exclusive ) set var5 to var5 * 10 , increment var3 by 9 * var5 , add 9 * var5 * var4 to var2 , increment var4 , increment var2 by var4 * ( var6 - var3 ) , you have to return var2
we are given a number var3 . in func0 set var1 to 1 ; for var2 in range from 1 to var0 ( inclusive ) assign var1 * 2 to var1 ; you have to return var1 . for var2 in range from 1 to var3 ( inclusive ) add value returned by function func0 ( var2 ) to var4 . return var4
we are given arrays of numbers var0 , var1 . assign the length of var0 to var2 . iterate var3 from 0 to var2 , in each iteration you have to do the following : [ ] . if var2 is less than or equal to 2 return var2 , initialize var4 to 2 , iterate var5 from 1 to var2 - 1 , inside the loop increment var4 , continue if var0 [ var5 ] - var1 [ var5 ] is larger than var0 [ var5 - 1 ] , increment var4 , increment var0 [ var5 ] by var1 [ var5 ] if var1 [ var5 ] + var0 [ var5 ] is less than var0 [ var5 + 1 ] , after the loop ends you have to return var4 otherwise
we are given numbers var1 , var2 . in func0 assign var1 to var3 ; let var4 be var2 ; for var6 in range from 2 to var3 ( inclusive ) for each var7 between 2 and var4 ( inclusive ) if var6 is even and var7 is even increment var5 by ( 1 plus var4 minus var7 ) * ( var3 - var6 + 1 ) ; return var5 . return call func0 with ( 1 , var1 , var2 )
you are given a character array var0 . you have to set var1 to zero . let var2 be split var0 by space . assign remove element at position 0 from var2 to var1 . you have to set var3 to zero . if var1 is less than or equal to 2 return string representation of - 1 else if var1 is even in var3 you have to store var1 squared / 4 - 1 , assign 1 plus var1 squared / 4 to var4 else you have to set var3 to var1 squared divided by 2 , you have to set var4 to 1 + half of var1 * var1 , you have to return concatenation of concatenation of string representation of var3 and space and string value of var4
you are given arrays of integers var0 and var1 . you have to store the length of var0 in var2 . for each var3 between 0 and var2 ( exclusive ) [ ] . in var4 you have to store var0 [ 0 ] . set var5 to 1 . for var6 in range from 1 to var2 ( exclusive ) assign var0 [ var6 ] to var4 , increment var5 if var0 [ var6 ] - var1 [ var6 ] exceeds var4 , otherwise if var2 - 1 is not equal to var6 and var1 [ var6 ] + var0 [ var6 ] is less than var0 [ var6 + 1 ] ( 0 - based indices ) set var4 to var1 [ var6 ] + var0 [ var6 ] , increment var5 , and if var6 is equal to var2 - 1 increment var5 else you have to set var4 to var0 [ var6 ] otherwise . you have to return var5
given integers var0 , var1 , var2 , var3 , var4 and var5 . var10 is new array of strings . set var6 to var0 + var2 - var5 divided by 2 . you have to store in var7 the value of var0 - var6 . you have to set var9 to var2 - var6 . let var8 : = var4 - var6 . if 0 is greater than or equal to var9 or var7 is less than or equal to 0 or var6 doesn ' t exceed 0 append string representation of - 1 to var10 , if 10 doesn ' t exceed var8 or var6 is greater than or equal to 10 or 10 is less than or equal to var7 or var9 is greater than or equal to 10 append string representation of - 1 to var10 , if var9 is equal to var8 or var6 is equal to var7 or var6 = var9 or var7 is equal to var8 or var7 is equal to var9 append string representation of - 1 to var10 , if var7 plus var9 is not equal to var5 or var3 is not equal to var8 + var7 or var7 + var6 ! = var0 or var6 + var9 is not equal to var1 or var2 is not equal to var8 + var9 append string value of - 1 to the end of var10 , add concatenation of concatenation of string representation of var6 and space and string representation of var7 to var10 , add concatenation of concatenation of string representation of var9 and space and string value of var8 to var10 otherwise otherwise otherwise . you have to return var10
you are given numbers var2 , var1 , var0 , var3 and var4 . in func0 return var1 if var0 is divisible by var1 , otherwise value returned by function func0 ( var1 , var0 % var1 ) . set var5 to var0 divided by call function func0 with arguments var0 , var1 ( rounded down ) . assign var1 times var5 to var5 . if var3 is greater than var4 you have to set var6 to var4 , let var4 : = var3 , assign var6 to var3 , set var6 to var0 , set var0 to var1 , let var1 be var6 . assign var2 divided by var0 ( rounded down ) times var4 to var7 . assign var2 divided by var5 to var8 . increment var7 by var3 * ( var2 divided by var1 ( rounded down ) - var8 ) . return var7
we are given numbers var0 and var1 . while 1 is less than or equal to var0 and var1 is greater than or equal to 1 or 2 is less than or equal to var1 and 1 doesn ' t exceed var0 repeat if var0 exceeds var1 reduce var0 by 2 , decrement var1 , increment var2 , subtract 2 from var1 , decrement var0 , increment var2 otherwise . you have to return var2
you are given arrays of numbers var1 and var2 . in func0 set var5 to the length of var1 ; you have to create an array of numbers var6 of length var5 ; var7 is a new integer array of length var5 ; for each var8 between 0 and var5 ( exclusive ) let the var1 [ var3 ] be equal to var6 [ var8 ] , also increment var3 , assign var4 - th element of var2 to var7 [ var8 ] , while incrementing var4 , if var7 [ var8 ] is greater than var7 [ var8 - 1 ] in var7 [ var8 ] you have to store var7 [ var8 - 1 ] if var8 is positive ; for each var10 between 0 and var5 ( exclusive ) increase var9 by var7 [ var10 ] multiplied by 1 * var6 [ var10 ] ; you have to return var9 . initialize var4 to zero . return value returned by function func0 ( 1 , var1 , var2 , var3 , var4 )
we are given an array of numbers var0 . assign the length of var0 to var1 . var3 is a new two dimensional array with var1 plus 1 x 3 size . for var4 in range from 1 to var1 ( inclusive ) assign var6 - th element of var0 to var2 , while incrementing var6 , you have to store maximum of var3 [ var4 - 1 ] [ 0 ] and maximum between var3 [ var4 - 1 ] [ 1 ] and var3 [ var4 - 1 ] [ 2 ] in var3 [ var4 ] [ 0 ] , assign maximum between var3 [ var4 - 1 ] [ 0 ] + 1 and 1 + var3 [ var4 - 1 ] [ 2 ] to var3 [ var4 ] [ 1 ] if var2 is equal to 3 or var2 is equal to one , if 2 = var2 or var2 = 3 store maximum of 1 + var3 [ var4 - 1 ] [ 0 ] and var3 [ var4 minus 1 ] [ 1 ] + 1 in var3 [ var4 ] [ 2 ] . assign maximum of var3 [ var1 ] [ 0 ] and maximum of var3 [ var1 ] [ 1 ] and var3 [ var1 ] [ 2 ] to var5 . return var1 - var5
we are given numbers var1 and var2 . in func0 let var3 be var1 ; assign var2 to var4 ; initialize var5 to zero ; while 1 doesn ' t exceed var3 and 2 doesn ' t exceed var4 or 2 doesn ' t exceed var4 and var3 is greater than or equal to 1 repeat if var3 is greater than var4 increment var5 , subtract 2 from var3 , decrement var4 , decrement var3 , subtract 2 from var4 , increment var5 otherwise ; return var5 . you have to return call func0 with ( 1 , var1 , var2 )
given integers var0 , var1 and var2 . var5 is a new array of reals . initialize var3 to 1 . 0 . for var4 in range from 0 to var2 ( inclusive ) set var3 to var3 multiplied by var1 minus var4 / ( 1 plus var0 + var4 ) . assign 1 . 0 - var3 to var3 . append 0 to var5 , return var5 if 0 . 0 is greater than or equal to var3 . append var3 to var5 . you have to return var5
given integers var1 , var2 , var3 , var4 and var5 . in func0 store var1 in var6 ; you have to set var7 to var2 ; set var8 to var3 ; let var9 : = var4 ; in var10 you have to store var5 ; store in var11 the value of 1 . 0 / var8 - 1 . 0 / var9 ; let var12 be 1 . 0 / ( var9 plus var8 ) ; assign the result of division of var7 by var8 to var14 ; while var14 - var13 is greater than maximum between 1 . 0 and var14 * maximum between 1 . 0 and var14 repeat store var14 + var13 / 2 in var15 , store in var16 the value of half of var7 - var8 minus var15 , you have to set var18 to zero , while var18 is less than var6 repeat if var10 + var18 is smaller than var6 add var16 * 2 * var12 to var17 , and increase var17 by var16 / var9 otherwise and then add var10 to var18 , if var17 doesn ' t exceed var15 set var14 to var15 , and in var13 you have to store var15 otherwise ; you have to return var14 plus var13 divided by 2 . return call func0 with ( 1 , var1 , var2 , var3 , var4 , var5 )
you are given numbers var0 and var1 . for var3 in range from 0 to var0 ( inclusive ) set var4 to minimum of var1 - var3 * 2 and var0 - var3 / 2 , if var3 + var4 is larger than var2 let var2 : = var3 + var4 . you have to return var2
we are given numbers var0 , var1 , var2 , var3 , var4 , var5 , var6 and var7 . var9 is an empty array of strings . add " <unk> 1 " to var9 , you have to return var9 if var4 is less than var3 and var7 is smaller than var0 and var5 is smaller than var0 . initialize var8 to true if var6 is greater than var3 and var5 is bigger than var0 or var7 is bigger than var0 and var4 exceeds var3 , otherwise set var8 to false . add " <unk> 1 " to var9 , return var9 if var5 is less than var2 and var6 is smaller than var1 and var7 is smaller than var2 and var4 is less than var1 , otherwise if var5 is greater than var2 and var6 is bigger than var1 or var7 exceeds var2 and var4 is larger than var1 add " <unk> 2 " to var9 , return var9 . add " <unk> <unk> " to var9 . return var9
you are given a string var0 . for indices of the array var0 between 1 and the length of var0 ( exclusive ) if the element is equal to var0 [ var1 - 1 ] increment var0 [ var1 ] by 1 , if var0 [ var1 ] exceeds 122 let var0 [ var1 ] : = 97 , add 1 to var0 [ var1 ] , if var0 [ var1 ] is greater than 122 set var0 [ var1 ] to 97 if var1 is less than the length of var0 - 1 and var0 [ var1 ] is equal to var0 [ 1 plus var1 ] . return var0
you are given integers var0 , var1 , var2 and a number var3 . var5 is a new array of numbers . increment var0 by var2 * 8 . append 0 to the end of var5 , return var5 if var1 is less than or equal to var0 . if var2 is less than or equal to var3 append - 1 to var5 , return var5 . let var4 be 12 * ( var2 - var3 ) . append ( var4 + var1 - 1 - var0 ) / var4 to the end of var5 . you have to return var5
we are given an integer var0 , an array of numbers var1 . initialize var10 to 0 . let var2 be the length of var1 . let var3 be var0 . set var4 to 1 . initialize var5 to array of reals with length equal to var2 . iterate var6 from 0 to var2 , in each iteration you have to do the following : assign var10 - th element of var1 to var5 [ var6 ] , also increment var10 . sort var5 . assign var5 [ 0 ] to var4 . let var7 : = var3 - var5 [ len of var5 - 1 ] . if var7 is greater than var4 assign var7 to var4 . iterate var8 from 1 to var2 , in each iteration you have to do the following : set var9 to var5 [ var8 ] - var5 [ var8 - 1 ] divided by two , if var9 is greater than var4 assign var9 to var4 . you have to return var4
we are given numbers var0 and var1 , a string var2 . assign var0 to var3 . assign var1 to var4 . assign var3 to var5 . var6 is an empty array of integers . store var2 in var7 . for each element of the array var7 at indices between 0 and var3 , exclusive , if it equals to 48 then append var8 to the end of var6 . while var9 is not equal to the length of var6 - var4 repeat while var6 [ var10 ] minus var6 [ var9 ] is less than var6 [ var4 + var9 ] - var6 [ var10 ] repeat you have to store minimum between var5 and var6 [ var4 + var9 ] - var6 [ var10 ] in var5 , increment var10 , you have to store in var5 the value of minimum between var5 and var6 [ var10 ] - var6 [ var9 ] and then increment var9 . return var5
we are given numbers var0 and var1 . you have to store minimum between var0 and var1 in var2 . for as long as var2 is greater than zero assign maximum of var0 and var1 to var4 , decrement var4 by 2 , decrement var2 , let var0 : = var4 , set var1 to var2 , increment var3 if var2 - 1 is non negative and var4 - 2 is non - negative , break if var1 is equal to 1 and var0 is equal to 1 , set var2 to minimum of var0 and var1 . you have to return var3
you are given integers var4 , var5 and var6 . in func0 set var2 to 1 ; for each var3 between 1 and var1 ( inclusive ) you have to store in var2 the value of var2 multiplied by ( var0 minus var3 + 1 ) , divide var2 by var3 ; return var2 . for each var8 between 4 and var6 - 1 ( inclusive ) increment var7 by call function func0 with arguments var4 , var8 multiplied by call func0 with ( var5 , var6 - var8 ) . you have to return var7
you are given a number var0 . if var0 is larger than 1 assign var0 / 2 + var0 modulo 2 to var0 . return var0
given a string var1 . in func0 store var1 in var2 ; concatenate var2 [ 0 ] to var3 ; you have to store in var4 the value of var2 [ 0 ] ; for each var5 between 1 and the length of var2 ( exclusive ) initialize var6 to 97 , while var6 doesn ' t exceed 122 repeat if var6 ! = var4 and var5 is equal to len of var2 - 1 or var6 is not equal to var2 [ 1 + var5 ] concatenate var6 to var3 , set var4 to var6 , stop iterating and then add 1 to var6 if var2 [ var5 ] ( indexing is 0 - based ) equals to var4 otherwise concatenate var2 [ var5 ] to var3 , store var2 [ var5 ] in var4 ; return var3 . return call func0 with ( 1 , var1 )
you are given an array of numbers var0 . you have to set var7 to zero . store in var1 the value of the length of var0 . var2 is a new array of length var1 . for all var3 from 0 to var1 do the following . assign var7 - th element of var0 to var2 [ var3 ] , while incrementing var7 . sort var2 . you have to store in var5 the value of var1 - 1 . assign var1 - 1 to var6 . while var5 is positive repeat while var5 is positive and | var2 [ var5 ] - var2 [ var5 - 1 ] | exceeds 1 repeat decrement var5 , let var6 : = var5 - 2 , while var6 is greater than zero and | var2 [ var6 ] minus var2 [ var6 - 1 ] | exceeds 1 decrement var6 , add var2 [ var5 - 1 ] * var2 [ var6 - 1 ] to var4 if var5 is positive and var6 is greater than zero , set var5 to var6 - 2 . return var4
you are given integers var6 , var7 , var8 and var9 . in __globals__.__init__ you have to store 1000000000 . 0 + 7 in __globals__.var0 . in func0 set var3 to 1 ; while var2 is positive repeat if var2 and 1 bitwise is not equal to 0 assign var1 * var3 modulo __globals__.var0 to var3 , assign shift var2 right 1 bits to var2 , let var1 : = square of var1 % __globals__.var0 ; you have to return var3 % __globals__.var0 . in func1 set var5 to call function func0 with arguments var4 , __globals__.var0 minus 2 ; while var5 is less than zero add __globals__.var0 to var5 ; you have to return var5 % __globals__.var0 . if var6 is equal to one you have to set var5 to ( var9 + var8 % __globals__.var0 * var7 modulo __globals__.var0 ) modulo __globals__.var0 , set var5 to ( call function func0 with arguments var6 , var8 times var9 % __globals__.var0 + var7 * call function func1 with arguments 1 - var6 % __globals__.var0 % __globals__.var0 ) modulo __globals__.var0 otherwise . return var5
we are given numbers var0 and var1 . for as long as 1 is less than or equal to var0 and var1 is greater than or equal to 1 or 2 is less than or equal to var1 and 1 doesn ' t exceed var0 if var1 is less than or equal to var0 decrement var0 by 2 , decrement var1 , increment var2 , decrement var0 , subtract 2 from var1 , increment var2 otherwise . you have to return var2
given integers var0 , var1 , var2 , var3 , var4 and var5 . var10 is new array of strings . you have to store var0 - var3 + var4 divided by two in var6 . assign half of var0 + var3 - var4 to var7 . you have to set var8 to half of var3 + var2 * 2 - var0 - var4 . you have to store in var9 the value of var4 plus var3 - var0 / 2 . if var8 is not equal to var9 and var6 is not equal to var7 and var6 is less than 10 and var8 is not equal to var9 and var6 is not equal to var8 and var7 is positive and var8 is positive and var9 is positive and var8 is not equal to var6 and var6 is not equal to var9 and var8 is not equal to var9 and var7 is not equal to var8 and var7 is not equal to var8 and var9 is not equal to var6 and var8 + var7 is equal to var5 add concatenation of concatenation of string value of var6 and space and string value of var7 to var10 , add concatenation of concatenation of string value of var8 and space and string value of var9 to var10 , and append string representation of - 1 to var10 otherwise . you have to return var10
you are given integers var0 , var1 , var2 and integer var3 . while var0 is less than var1 repeat store in var5 the value of var0 , add var2 * 8 to var0 , if var1 is less than or equal to var0 break , increment var4 , reduce var0 by var3 * 12 , increase var0 by 4 * var2 , if var5 is greater than or equal to var0 let var4 : = - 1 , break . you have to return var4
we are given numbers var0 , var1 , var2 and var3 . if var0 + 8 * var2 is less than var1 and var3 is greater than or equal to var2 return - 1 , and for as long as true increment var0 by var2 * 8 , if var1 doesn ' t exceed var0 break , increment var4 , reduce var0 by var3 times 12 , increase var0 by var2 * 4 , return var4 otherwise
given numbers var0 , var1 . set var2 to var0 . set var3 to var1 . while var2 is positive and var3 is positive repeat increment var2 , reduce var3 by 2 , if var3 is negative decrement var4 if var2 is smaller than var3 , otherwise increment var3 , decrement var2 by 2 , decrement var4 if var2 is negative , increment var4 . return var4
given numbers var3 , var4 , var5 , var6 and var7 . in func0 return the greatest common divisor between var0 and var1 . assign var3 / var4 to var8 . assign var3 / var5 to var9 . you have to store in var10 the value of call function func0 with arguments var4 , var5 . let var11 : = var3 / var10 * var4 / var10 * var5 divided by var10 ( rounded down ) * 1 . store ( var7 * ( var9 - var11 ) + var8 * var6 ) * 1 in var12 . let var13 be ( var8 - var11 ) * var6 plus var9 * var7 ) times 1 . let var14 be maximum between var12 and var13 . you have to return var14
we are given an array of reals var0 . you have to set var9 to zero . let var1 be the length of var0 . you have to create an array of reals var2 of length var1 . iterate var3 from 0 to var1 ( exclusive ) assign var9 - th element of var0 to var2 [ var3 ] , also increment var9 . sort var2 . you have to create an array of reals var4 of length var1 . let var4 [ var1 - 1 ] be 1 - var2 [ var1 - 1 ] . assign var2 [ var1 - 1 ] to var5 . let var6 be var1 - 2 . while var6 is non negative repeat let var4 [ var6 ] be ( 1 - var2 [ var6 ] ) * var4 [ 1 + var6 ] , for var8 in range from var6 to var1 add var4 [ var6 ] ( 0 - based indices ) / ( 1 - var2 [ var8 ] ) * var2 [ var8 ] to var7 , if var7 is larger than var5 you have to store var7 in var5 and then decrement var6 . you have to return var5
we are given integer arrays var1 and var2 . in func0 set var3 to the length of var1 ; var4 is a new integer array of length var3 ; iterate var5 from 0 to var3 , inside the loop [ ] ; you have to create an array of boolean var6 of length var3 ; assign var1 [ 0 ] - var2 [ 0 ] to var4 [ 0 ] ; assign var1 [ var3 minus 1 ] + var2 [ var3 - 1 ] to var4 [ var3 - 1 ] ; initialize var7 to 1 if var3 is equal to 1 otherwise set var7 to 2 ; iterate var8 from 1 to var3 - 1 , inside the loop store var1 [ var8 ] - var2 [ var8 ] in var9 , set var10 to var1 [ var8 ] + var2 [ var8 ] , if var4 [ var8 - 1 ] is smaller than var9 and var1 [ var8 - 1 ] is less than var9 increment var7 , store var9 in var4 [ var8 ] ( indexing is 0 - based ) , and if var1 [ var8 + 1 ] is greater than var10 increment var7 , set var4 [ var8 ] to var10 otherwise ; you have to return var7 . you have to return call func0 with ( 1 , var1 , var2 )
we are given integers var1 , var2 . in func0 set var3 to var1 ; set var4 to var2 ; store shift 1 left var3 bits in var5 ; you have to set var6 to zero ; you have to store var5 - var4 + 1 in var4 ; for var7 in range from 0 to var3 ( exclusive ) divide var5 by 2 , if var4 is larger than var5 set var4 to 1 + var5 * 2 - var4 , increment var6 , and increase var6 by 2 * var5 otherwise ; you have to return var6 . return call function func0 with arguments 1 , var1 , var2
given integers var1 , var2 , a string var3 . in func0 set var4 to var1 ; store var2 in var5 ; let var6 be var3 ; initialize var7 to 0 ; initialize var8 to 97 ; while var8 doesn ' t exceed 98 repeat initialize var9 to 0 , initialize var10 to 0 , initialize var11 to 0 , while var10 is smaller than var4 repeat if var6 [ var10 ] is equal to var8 increment var11 , for as long as var11 is bigger than var5 decrement var11 if var6 [ var9 ] ( indexing is 0 - based ) is equal to var8 , increment var9 , assign maximum between var7 and var10 - var9 plus 1 to var7 , increment var10 and then increment var8 by 1 ; return var7 . you have to return call func0 with ( 1 , var1 , var2 , var3 )
you are given a number var0 , arrays of integers var1 , var2 . you have to set var11 to zero . let var3 be len of var1 . var4 is new array of reals of length var3 + 1 . iterate var6 from 0 to var3 , inside the loop let the var1 [ var10 ] be equal to var7 , also increment var10 , let the var2 [ var11 ] be equal to var8 , also increment var11 , you have to store ( var8 / var0 - ( var7 - 1 ) / var0 ) / ( var8 - var7 + 1 ) in var4 [ var6 ] . assign var4 [ 0 ] to var4 [ var3 ] . for var9 in range from 1 to var3 ( inclusive ) increase var5 by 1 - ( 1 minus var4 [ var9 ] ) * ( 1 - var4 [ var9 - 1 ] ) . let var5 be var5 * 2000 . you have to return var5
you are given an integer var0 , an array of integers var1 . store in var2 the value of the length of var1 . assign var0 to var3 . var4 is a new array of length var2 . iterate var7 from 0 to var2 ( exclusive ) let the var8 - th element of var1 be equal to var4 [ var7 ] , also increment var8 , add var4 [ var7 ] to var5 , if var5 = var3 increment var6 , initialize var5 to 0 , if var5 is greater than var3 increment var6 , store in var5 the value of var4 [ var7 ] . after the loop is ended , if var5 ! = 0 or var6 is equal to 0 increment var6 . return var6
we are given numbers var0 and var1 . var6 is array of strings , which has no elements . if var0 * var1 is bigger than ( var0 - 1 ) * var0 divided by 2 add " - 1 " to var6 , and let var2 : = var1 times var0 , append string representation of var2 to the end of var6 , iterate var3 from 0 to var0 , inside the loop iterate var4 from 1 plus var3 to 1 + var3 + var1 ( exclusive ) set var5 to var4 + 1 , reduce var5 by var0 if var5 exceeds var0 , add concatenation of concatenation of string representation of var3 + 1 and space and string representation of var5 to var6 otherwise . return var6
you are given integers var1 , var2 , var3 and the number var4 . in func0 set var5 to var1 ; you have to set var6 to var2 ; assign var3 to var7 ; assign var4 to var8 ; you have to store half of var7 - var5 in var9 ; store var8 - var6 in var10 ; if var10 is even reduce var10 in 2 times , let var11 : = ( 1 plus var9 ) * ( var10 + 1 ) + var9 * var10 , divide var10 by 2 , in var11 you have to store ( 1 + var9 * 2 ) * ( 1 + var10 ) otherwise ; return var11 . you have to return call function func0 with arguments 1 , var1 , var2 , var3 , var4
we are given the number var0 . initialize var1 to 2 . for each var3 between 1 and var0 ( inclusive ) increment var2 by var1 , set var1 to 2 * var1 . you have to return var2
we are given the number var0 , arrays of numbers var1 and var2 . set var3 to the length of var1 . create an array var4 with size var3 of type real . for all var5 from 0 to var3 do the following . you have to store in var6 the value of var2 [ var5 ] / var0 - ( var1 [ var5 ] - 1 ) / var0 , store in var4 [ var5 ] the value of ( 1 . 0 + var2 [ var5 ] - var1 [ var5 ] ) / ( 1 . 0 plus var2 [ var5 ] - var1 [ var5 ] ) . iterate var8 from 0 to var3 , inside the loop store ( var8 - 1 plus var3 ) modulo var3 in var9 , increase var7 by ( 1 . 0 - var4 [ var8 ] * 3 . 0 ) * 3 . <unk> . you have to return var7
we are given numbers var0 and var1 . initialize var2 to 1 . while var1 is greater than zero repeat if var1 is greater than or equal to var2 subtract var2 from var1 , and stop iterating otherwise , increment var2 , initialize var2 to 1 if var2 is equal to 1 + var0 . you have to return var1
you are given an array of integers var0 . var7 is an empty array of strings . you have to set var6 to zero . you have to store in var1 the value of the length of var0 . var2 is a new array of numbers . iterate var3 from 0 to var1 , inside the loop let the var6 - th element of var0 be equal to var4 , also increment var6 , append var4 to var2 . sort var2 . for every var5 in var2 add concatenation of string representation of var5 and space to var7 . after the loop ends you have to return var7
given an array of numbers var0 . var6 is array of strings , which has no elements . let var1 be the length of var0 . var2 is a new array of numbers . iterate var3 from 0 to var1 , in each iteration you have to do the following : append var0 [ var5 ] while incrementing var5 to the end of var2 . sort var2 . iterate var4 from 0 to var1 add concatenation of string value of var2 [ var4 ] and space to var6 . you have to return var6
given numbers var0 , var1 . var7 is array of strings , which has no elements . set var4 to 1 . var6 is a new grid of size 1 + var0 by var0 + 1 . for each var3 between 1 and var0 ( inclusive ) for each var2 between 1 and var1 in var6 [ var3 ] ( indexing is 0 - based ) [ var2 ] you have to store var4 , increment var4 . for each var3 between 1 and var0 ( inclusive ) for each var2 between var1 and var0 ( inclusive ) set var6 [ var3 ] [ var2 ] to var4 , increment var4 , if var2 is equal to var1 add var6 [ var3 ] ( indexing is 0 - based ) [ var2 ] to var5 . after the loop is ended , append string value of var5 to var7 . for each var2 between 1 and var0 ( inclusive ) for var3 in range from 1 to var0 ( inclusive ) add concatenation of string representation of var6 [ var2 ] ( 0 - based indices ) [ var3 ] and space to var7 . after the loop is ended , you have to return var7
given an array of integers var0 and an array of integers var1 . assign the length of var0 to var2 . for var3 in range from 0 to var2 ( exclusive ) [ ] . let var4 be var0 [ 0 ] . initialize var5 to 1 . for all var6 from 1 to var2 do the following . you have to store var0 [ var6 ] - var1 [ var6 ] in var7 , set var8 to var0 [ var6 ] + var1 [ var6 ] , if var7 exceeds var0 [ var6 - 1 ] and var7 is bigger than var4 set var4 to var0 [ var6 ] ( indexing is 0 - based ) , increment var5 , and let var4 : = var8 , increment var5 if var8 is smaller than var0 [ 1 plus var6 ] or var6 is equal to var2 minus 1 otherwise . you have to return var5
we are given an integer var1 , a string var2 . in __globals__.__init__ you have to store in __globals__.var0 the value of 1000000007 . in func0 set var3 to 1 ; for as long as var2 is positive set var3 to var1 multiplied by var3 % __globals__.var0 if var2 is odd , assign square of var1 modulo __globals__.var0 to var1 , let var2 : = shift var2 right 1 bits ; you have to return var3 . let var4 : = var1 . assign var2 to var5 . initialize var6 to array of integers with length equal to 26 . for each var7 between 0 and var4 ( exclusive ) set var8 to var5 [ var7 ] - 65 , increment var6 [ var8 ] . sort var6 . initialize var9 to 1 . initialize var10 to 24 . while var10 is non negative and var6 [ var10 ] is equal to var6 [ 25 ] repeat increment var9 and then decrement var10 . in var3 you have to store call function func0 with arguments var9 , var4 . you have to return var3
you are given a number var0 , a character array var1 . in func0 set var3 to var0 ; you have to store var1 in var4 ; for each var5 between 1 and var3 / 4 ( inclusive ) while 4 * var5 + var6 is smaller than var3 repeat if var4 [ 4 * var5 + var6 ] is equal to 42 and var4 [ var6 ] = 42 and var4 [ var6 + var5 ] is equal to 42 and var4 [ 3 * var5 plus var6 ] equals to 42 add " yes " to var2 , you have to return var2 and then increment var6 ; add " no " to var2 ; you have to return var2 . var2 is array of strings , which has no elements . return call func0 with ( var0 , var1 , var2 )
we are given an integer var0 , a string var1 . var4 is a new integer array of length the length of var1 . var5 is a new array of length 1 + the length of var1 . for every element in var1 at index var6 assign 1 to var4 [ var6 ] if var1 [ var6 ] is equal to 49 , if var6 is greater than zero increase var4 [ var6 ] by var4 [ var6 - 1 ] . you have to set var7 to zero . set var5 [ 0 ] ( 0 - based indices ) to 1 . until var8 less than the length of var1 if var0 is less than or equal to var4 [ var8 ] increment var7 by var5 [ var4 [ var8 ] minus var0 ] , increment var5 [ var4 [ var8 ] ] . return var7
you are given numbers var1 , var2 . in func0 let var3 be var1 ; assign var2 to var4 ; while var4 is positive and var3 is greater than zero repeat if var3 is greater than var4 if 1 doesn ' t exceed var4 and 2 doesn ' t exceed var3 increment var5 , subtract 2 from var3 , decrement var4 , and otherwise , and initialize var4 to 0 otherwise , increment var5 , subtract 2 from var4 , decrement var3 if 2 is less than or equal to var4 and 1 doesn ' t exceed var3 otherwise otherwise ; you have to return var5 . you have to return call func0 with ( 1 , var1 , var2 )
we are given numbers var0 , var1 , var2 , var3 and var4 . let var5 be 1000000 . 0 . for each var7 between 0 and var5 ( inclusive ) if var4 * var7 is bigger than var0 stop iterating , assign maximum between var6 and ( var0 - var4 times var7 ) divided by var3 ( rounded down ) * var1 plus var2 times var7 to var6 . for each var8 between 0 and var5 ( inclusive ) if var8 * var3 is bigger than var0 stop iterating , let var6 : = maximum of var6 and ( var0 - var8 * var3 ) / var4 * var2 plus var1 * var8 . return var6
given numbers var0 and var1 . initialize var3 to 1 . while var3 doesn ' t exceed var0 and 1 doesn ' t exceed var3 and var1 is greater than or equal to var3 repeat if var1 > = var3 increment var2 by var3 , reduce var1 by var3 , increment var3 , if var3 is greater than var0 set var3 to 1 . after the loop is ended , you have to return var1
given numbers var0 , var1 and var2 , an array of integers var3 . assign the length of var3 to var4 . var5 is a new grid of size 2 by 1 plus var1 . initialize var6 to zero . you have to set var5 [ 0 ] [ 0 ] to 1 . for each var7 between 1 and var4 ( inclusive ) you have to set var8 to var7 and 1 bitwise , for each var9 between 0 and var0 ( inclusive ) for each var10 between 0 and var1 ( inclusive ) let var5 [ var8 ] [ var9 ] be var5 [ var8 xor 1 bitwise ] [ var9 ] [ var10 ] , increase var5 [ var8 ] ( indexing is 0 - based ) [ var9 ] by var5 [ var8 ] [ var9 - 1 ] [ var10 - var3 [ var7 - 1 ] ] if var9 is positive and var3 [ var7 - 1 ] is less than or equal to var10 , while var2 is less than or equal to var5 [ var8 ] [ var9 ] ( 0 - based indices ) repeat let var5 [ var8 ] [ var10 ] be var5 [ var8 ] [ var9 ] [ var10 ] - var2 . initialize var11 to zero . for each var12 between 0 and var1 ( inclusive ) increase var11 by var5 [ var4 and 1 bitwise ] [ var0 ] [ var12 ] , while var2 is less than or equal to var11 repeat subtract var2 from var11 . after the loop is ended , return var11
you are given numbers var0 and var1 . return string value of - 1 if var0 is bigger than var1 + 1 or shift 1 + var0 left 1 bits is smaller than var1 , otherwise if var1 - var0 is less than or equal to 1 or var0 = var1 + 1 if var0 is equal to var1 + 1 you have to set var3 to zero else set var3 to 1 , while var4 < var1 + var0 repeat add string representation of var3 to var2 and then increment var4 , assign ( 1 + var3 ) % 2 to var3 else initialize var6 to 0 , while var5 is smaller than var0 or var6 is smaller than var1 repeat if var7 is odd concatenate string value of 0 to var2 , increment var5 , and concatenate string value of 11 to var2 , increment var6 by 2 if var1 - var6 is greater than 1 + var0 - var5 , otherwise concatenate string representation of 1 to var2 , increment var6 otherwise and then increment var7 , return var2
you are given an array of numbers var0 . assign the length of var0 to var1 . var3 is a new array of numbers of length var1 . var4 is a new array of numbers of length var1 . fill var3 with - 1 . fill var3 with - 1 . in var3 [ 0 ] ( indexing is 0 - based ) you have to store 0 . iterate var5 from 1 to var1 set var3 [ var5 ] to 1 plus var3 [ var5 - 1 ] if var0 [ var5 - 1 ] is less than or equal to var0 [ var5 ] , otherwise set var3 [ var5 ] to 0 . you have to set var4 [ var1 - 1 ] to 0 . you have to store var1 - 2 in var6 . while var6 is non negative repeat if var0 [ 1 + var6 ] is less than or equal to var0 [ var6 ] you have to store var4 [ var6 + 1 ] + 1 in var4 [ var6 ] , and assign 0 to var4 [ var6 ] otherwise and then decrement var6 . initialize var7 to zero . iterate var8 from 0 to var1 set var7 to maximum of var7 and var4 [ var8 ] + var3 [ var8 ] + 1 . return var7
you are given numbers var1 and var2 . in func0 set var3 to var1 ; set var4 to var2 ; let var5 be minimum between var3 and var4 ; set var6 to var5 ; while var5 exceeds 1 decrement var5 , store in var6 the value of var6 * var5 ; after the loop ends return var6 . you have to return call function func0 with arguments 1 , var1 , var2
we are given numbers var0 and var1 . if var0 exceeds var1 let var3 be var1 , assign var0 to var3 otherwise . you have to store var3 in var4 . while var4 exceeds 1 repeat you have to store ( var4 - 1 ) * var3 in var3 and then decrement var4 . return var3
given numbers var0 , var1 . set var0 to var1 if var1 is smaller than var0 . let var2 be var0 . for each var3 between 2 and var2 ( exclusive ) assign var0 * var3 to var0 . after the loop ends you have to return var0
we are given integers var0 and var1 . let var2 be minimum between var0 and var1 . initialize var3 to 1 . for var4 in range from 2 to minimum between var0 and var1 let var2 be var2 * var4 . return var2
we are given numbers var0 and var4 . in func0 set var1 to 1 ; for each var2 between 1 and var0 ( inclusive ) you have to store in var1 the value of var2 * var1 ; you have to return var1 . in func1 return var3 . you have to return value returned by function func1 ( concatenation of empty string and string representation of value returned by function func0 ( minimum of var0 and var4 )
we are given integers var1 and var2 , an array of integers var3 . in func0 set var5 to the length of var3 ; let var6 be var1 ; set var7 to var2 ; create an array var8 with size var5 + 1 of type integer ; for each var9 between 1 and var5 ( inclusive ) you have to store in var8 [ var9 ] the value of var4 - th element of array var3 + var8 [ var9 - 1 ] ; var10 is a new grid of size var5 + 1 by var7 + 1 ; for each var11 between var6 and var5 ( inclusive ) for var12 in range from 1 to var7 ( inclusive ) set var10 [ var11 ] [ var12 ] to maximum of var10 [ var11 - 1 ] [ var12 ] and var8 [ var11 ] + var10 [ var11 - var6 ] [ var12 - 1 ] ( indexing is 0 - based ) - var8 [ var11 - var6 ] ; return var10 [ var5 ] [ var7 ] . initialize var4 to 0 . you have to return call function func0 with arguments 1 , var1 , var2 , var3 , var4
we are given numbers var0 and var1 , an array of numbers var2 . set var3 to the length of var2 . initialize var4 to 0 . var5 is a new integer array of length var3 . for each var6 between 0 and var0 ( exclusive ) you have to store in var5 [ var0 - 1 ] the value of var5 [ var0 - 1 ] + var2 [ var6 ] . for each var7 between var0 and var3 ( exclusive ) assign var2 [ var7 ] + var5 [ var7 - 1 ] - var2 [ the difference of var7 and var0 ] to var5 [ var7 ] . var8 is a new grid of size var1 + 1 by 1 + var3 . for var9 in range from 0 to var1 let var8 [ var9 ] [ 0 ] be 0 . for var10 in range from 1 to var1 ( inclusive ) for each var11 between var0 and var3 ( inclusive ) assign maximum between var8 [ var10 ] [ var11 - 1 ] and var8 [ var10 - 1 ] [ var11 - var0 ] + var5 [ var11 - 1 ] to var8 [ var10 ] [ var11 ] . after the loop ends you have to return var8 [ var1 ] [ var3 ]
given integer arrays var0 and var1 . var7 is a new integer array . set var2 to the length of var0 . for each var3 between 0 and var2 [ ] . create an array var4 with size var2 of type integer . set var4 [ 0 ] to 1 . you have to store var0 [ 0 ] in var5 . append 1 to var7 , you have to return var7 if var2 is equal to 1 . iterate var6 from 1 to var2 - 1 if var0 [ var6 ] - var5 is bigger than var1 [ var6 ] store in var4 [ var6 ] the value of 1 + var4 [ var6 - 1 ] , you have to store in var5 the value of var0 [ var6 ] , and if the difference of var0 [ var6 + 1 ] ( indexing is 0 - based ) and var0 [ var6 ] is bigger than var1 [ var6 ] set var4 [ var6 ] to 1 + var4 [ var6 - 1 ] , assign var1 [ var6 ] + var0 [ var6 ] to var5 else set var4 [ var6 ] to var4 [ var6 - 1 ] , let var5 be var0 [ var6 ] otherwise . append 1 + var4 [ var2 - 2 ] to var7 . return var7
given arrays of integers var0 and var1 . assign the length of var0 to var2 . for all var3 from 0 to var2 do the following . [ ] . set var4 to 1 . you have to store var0 [ 0 ] in var5 . for each var6 between 1 and var2 - 1 store in var7 the value of var0 [ var6 ] - var1 [ var6 ] , assign var1 [ var6 ] + var0 [ var6 ] to var8 , increment var4 , assign var0 [ var6 ] to var5 if var7 is larger than var5 , otherwise increment var4 , set var5 to var8 if var8 is less than var0 [ var6 + 1 ] otherwise let var5 : = var0 [ var6 ] . increment var4 if var2 is not equal to 1 . you have to return var4
you are given integer var2 , arrays of numbers var0 and var1 . in func0 create an array var4 with size the length of var0 of type integer ; for every element in var0 at index var5 let var6 : = 1 + var1 [ var5 ] - var0 [ var5 ] , let var7 : = call % with ( var0 [ var5 ] , var2 ) , assign var0 [ var5 ] + var2 - var7 to var8 , set var9 to 1 plus ( var1 [ var5 ] - var8 ) / var2 if var8 is less than or equal to var1 [ var5 ] else 0 , set var4 [ var5 ] to var9 , add var9 multiplied by 8 . 0 / var6 to var3 , if var5 is greater than zero set var10 to 1 + var1 [ var5 - 1 ] ( indexing is 0 - based ) minus var0 [ var5 - 1 ] , decrement var3 by var9 * var4 [ var5 - 1 ] multiplied by 2000 / var10 * var6 ; assign the length of var0 - 1 to var11 ; you have to store 1 + var1 [ var11 ] - var0 [ var11 ] in var12 ; let var13 be 1 + var1 [ 0 ] ( indexing is 0 - based ) minus var0 [ 0 ] ; reduce var3 by var4 [ 0 ] times 2000 times var4 [ var11 ] / var13 * var12 ; you have to return var3 . set var14 to the length of var0 . for var15 in range from 0 to var14 ( exclusive ) [ ] . store value returned by function func0 ( var0 , var1 , var2 ) in var16 . you have to return var16
you are given an array of integers var1 . in func0 let var2 be the length of var1 ; for var3 in range from 0 to var2 ( exclusive ) [ ] ; var4 is a new array of numbers of length var2 ; assign var1 [ 0 ] to var4 [ 0 ] ; for var5 in range from 1 to var2 ( exclusive ) assign var1 [ var5 ] + var4 [ var5 - 1 ] to var4 [ var5 ] ; let var6 : = new < int | int > with ( [ ] ) ; for var7 in range from 0 to var2 insert value of var4 [ var7 ] in var6 + 1 in var6 at var4 [ var7 ] if var4 [ var7 ] is in var6 , otherwise insert 1 in var6 at var4 [ var7 ] ; for every var9 in new int % with ( keys of var6 ) set var8 to maximum between value of var9 in var6 and var8 ; return var2 - var8 . return value returned by function func0 ( 1 , var1 )
we are given integers var0 and var1 . if var0 exceeds var1 assign var1 to var2 , let var2 be var0 otherwise . store ( var0 plus var1 ) divided by 3 in var3 . you have to return var3 if var2 is larger than var3 else var2
you are given the number var1 . in func0 return 1 if var0 is divisible by 4 and var0 is not divisible by 100 or var0 is divisible by 400 , otherwise 0 . assign var1 to var2 . assign var2 to var3 . set var4 to ( call func0 with ( var2 ) + 365 ) % 7 . store in var5 the value of value returned by function func0 ( var2 ) . while 0 ! = var4 or var5 ! = value returned by function func0 ( increment var3 ) repeat you have to store ( var4 plus 365 + value returned by function func0 ( var3 ) ) % 7 in var4 . you have to return var3
we are given a character array var0 . var1 is a new array of numbers of length 64 . initialize var2 to 1000000007 . for each var3 in range from 0 to 64 and var4 from 0 to 64 increment var1 [ var3 and var4 bitwise ] . set var5 to 1 . until var6 less than the length of var0 if 48 doesn ' t exceed var0 [ var6 ] and 57 is greater than or equal to var0 [ var6 ] let var7 : = var1 [ var0 [ var6 ] - 48 ] , and if var0 [ var6 ] is uppercase let var7 : = var1 [ 10 + var0 [ var6 ] - 65 ] , and if var0 [ var6 ] is lowercase set var7 to var1 [ var0 [ var6 ] - 97 + <unk> ] , and if var0 [ var6 ] is equal to 45 let var7 : = var1 [ 62 ] , store var1 [ 63 ] in var7 otherwise otherwise otherwise , let var5 be 1 * var7 * var5 % var2 . you have to return var5
given integers var0 and var1 . while var1 is not equal to 0 and 3 doesn ' t exceed var1 + var0 and var0 is not equal to 0 if var0 is larger than var1 reduce var0 by 2 , decrement var1 , and decrement var0 , decrement var1 by 2 otherwise , increment var2 . you have to return var2
given an array of numbers var0 . var6 is new array of strings . initialize var5 to 0 . var1 is a new array of numbers . assign the length of var0 to var2 . for var3 in range from 0 to var2 append var0 [ var5 ] ( also increment var5 ) to the end of var1 . sort var1 . iterate var4 from 0 to var2 ( exclusive ) add concatenation of string value of var1 [ var4 ] and space to var6 . return var6
you are given a string var0 . for indices of the array var0 between 1 and the length of var0 ( exclusive ) if the element is equal to var0 [ var1 - 1 ] increment var0 [ var1 ] by 1 , if var0 [ var1 ] exceeds 122 let var0 [ var1 ] : = 97 , add 1 to var0 [ var1 ] , if var0 [ var1 ] is greater than 122 let var0 [ var1 ] : = 97 if 1 + var1 is less than the length of var0 and var0 [ var1 ] = var0 [ var1 + 1 ] . return var0
you are given a string var0 . for var3 in range from 1 to the length of var0 ( exclusive ) if var0 [ var3 - 1 ] is equal to var0 [ var3 ] initialize var4 to 1 , while true repeat if var4 + var0 [ var3 ] is less than or equal to 122 and var0 [ var3 ] + var4 is not equal to var0 [ var3 + 1 ] add var4 to var0 [ var3 ] , stop iterating , if var0 [ var3 ] minus var4 is greater than or equal to 97 and var0 [ var3 ] - var4 is not equal to var0 [ var3 + 1 ] subtract var4 from var0 [ var3 ] , stop iterating , increment var4 if var3 + 1 is less than the length of var0 , otherwise increase var0 [ var3 ] by 1 if 122 is greater than or equal to var0 [ var3 ] + 1 otherwise reduce var0 [ var3 ] by 1 . you have to return var0
you are given integers var4 , var5 and an integer var6 . in __globals__.__init__ create an array __globals__.var0 , containing elements : 8 , 10 , 88 , <unk> , 10000000 , <unk> , <unk> , 10000000 , <unk> , 10000000 , 1 , 10000000 , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> ; create an array __globals__.var1 of type integer , containing elements : 1 , 1 , 62 , <unk> , <unk> , <unk> , <unk> , <unk> , 1 , <unk> , 1 , <unk> , <unk> , 1 , <unk> , 1 , <unk> , 2 , 1 , <unk> , <unk> , 1 , <unk> , 2 , <unk> , 1 , <unk> , <unk> , <unk> , 1 , <unk> , 100000000 , <unk> , 1 , <unk> , <unk> , <unk> , 1 , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , 88 . var8 is a new array of numbers . iterate over all positions var7 in __globals__.var0 append __globals__.var0 [ var7 ] to the end of var8 , you have to return var8 if __globals__.var0 [ var7 ] is equal to var5 and __globals__.var3 [ var7 ] is equal to var4 and var6 = __globals__.var3 [ var7 ] . you have to return var8
we are given integers var0 , var1 . you have to store var0 in var2 . set var3 to var1 . set var4 to shift 1 left var2 bits . assign 1 + var4 - var3 to var3 . for var6 in range from 0 to var2 ( exclusive ) assign shift var4 right 1 bits to var4 , if var3 exceeds var4 increment var5 , assign 2 * var4 + 1 - var3 to var3 else add var4 multiplied by 2 to var5 . you have to return var5
we are given integers var1 and var2 . in func0 assign var1 to var3 ; let var4 be var2 ; initialize var5 to 1 ; store shift 1 left var3 bits in var6 ; set var8 to true ; while var5 is smaller than var6 repeat set var9 to shift var5 + var6 right 1 bits , if var4 is less than or equal to var9 increment var7 if var8 otherwise increment var7 by var6 - var5 + 1 , store in var6 the value of var9 , initialize var8 to false else increment var7 by var6 - var5 + 1 if var8 , otherwise increment var7 , set var8 to true ; after the loop is ended , you have to return var7 . return call func0 with ( 1 , var1 , var2 )
you are given integers var1 and var2 . in __globals__.__init__ you have to create an array of numbers __globals__.var0 of length 60 . set __globals__.var0 [ 0 ] to 1 . let var3 : = var2 . for var4 in range from 0 to var1 if shift 1 left var1 - var4 - 1 bits is greater than or equal to var3 set __globals__.var0 [ 1 + var4 ] to 0 , decrement var3 by shift 1 left the difference of var1 and var4 minus 1 bits , assign 1 to __globals__.var0 [ 1 + var4 ] otherwise . for var4 in range from 0 to var1 ( exclusive ) if var2 is larger than shift 1 left var1 - var4 - 1 bits reduce var2 by shift 1 left var1 minus var4 - 1 bits , increase var5 by shift 1 left var1 - var4 bits if __globals__.var0 [ var4 ] is equal to __globals__.var0 [ 1 + var4 ] , otherwise increment var5 . you have to return var5
we are given integer var0 . var7 is array of strings , which has no elements . var1 is a new two dimensional array with var0 x var0 size . set var2 to var0 - 1 . assign var0 / 2 to var3 . you have to set var1 [ var2 ] [ var3 ] to 1 . for each var4 between 2 and var0 squared ( inclusive ) if var1 [ ( var2 + 1 ) modulo var0 ] [ ( var3 plus 1 ) % var0 ] is equal to 0 let var2 be ( var2 + 1 ) modulo var0 , assign ( 1 + var3 ) modulo var0 to var3 else set var2 to ( var0 + var2 - 1 ) % var0 , set var1 [ var2 ] [ var3 ] to var4 . for each var5 and var6 in range from 0 to var0 add space to var7 if var1 [ var5 ] [ var6 ] ( 0 - based indices ) is less than 10 , add space to var7 if var1 [ var5 ] [ var6 ] is smaller than 100 , add concatenation of string representation of var1 [ var5 ] [ var6 ] and space to var7 . you have to return var7
we are given an integer var0 , an array of numbers var1 . assign the length of var1 to var2 . initialize var3 to zero . var4 is a new array of length var2 . for var5 in range from 0 to var2 ( exclusive ) let the var9 - th element of var1 be equal to var4 [ var5 ] , also increment var9 . for all var6 from 0 to var2 do the following . increment var3 by var4 [ var6 ] / 10 , let var7 : = var4 [ var6 ] / 10 , you have to set var4 [ var6 ] to 10 + var7 * 10 - var4 [ var6 ] . sort var4 . iterate var8 from 0 to var2 , inside the loop if var0 is greater than or equal to var4 [ var8 ] subtract var4 [ var8 ] from var0 , increment var3 , and break otherwise . add var0 divided by 10 to var3 . you have to store minimum between var3 and 10 * var2 in var3 . return var3
given a number var0 . set var1 to 1 . if var0 is even assign half of var0 to var2 , assign 1 + var0 to var3 , and let var2 : = var0 , store in var3 the value of 1 + var0 divided by 2 otherwise . add var2 to var4 . you have to store var3 * var4 in var4 . set var5 to 6 . assign var4 * var5 to var4 . add var4 to var1 . return var1
we are given numbers var0 , var1 , a string var2 . for var5 in range from 0 to var0 ( exclusive ) add var2 [ var5 ] to var4 if var1 is equal to zero , otherwise set var3 to maximum of var2 [ var5 ] - 97 and 122 - var2 [ var5 ] , if var1 is greater than or equal to var3 set var6 to var2 [ var5 ] + var3 if var2 [ var5 ] + var3 is less than or equal to 122 else var2 [ var5 ] - var3 , add concatenation of var6 and empty string to var4 , subtract var3 from var1 , let var7 : = var1 + var2 [ var5 ] if var1 + var2 [ var5 ] is lowercase else var2 [ var5 ] - var1 , concatenate concatenation of var7 and empty string to var4 otherwise . return " - 1 " if var1 is positive else var4
we are given a number var0 . initialize var1 to zero . set var2 to 1 . for each var3 between 1 and var0 ( inclusive ) let var2 be var2 * 2 , add var2 to var1 . return var1
you are given arrays of numbers var0 and var1 . var8 is an empty array of strings . let var2 : = the length of var0 . var3 is a new array of length 100001 . iterate var4 from 0 to var2 ( exclusive ) assign var7 - th element of var0 to var5 , also increment var7 , increment var3 [ var5 ] . for all var6 from 0 to var2 do the following . add concatenation of concatenation of string value of var2 - 1 + var3 [ var1 [ var6 ] ] and space and string representation of var2 - 1 - var3 [ var1 [ var6 ] ] to var8 . you have to return var8
given the number var0 . if var0 is equal to one initialize var1 to 1 , and if var0 is even you have to store var0 divided by 2 in var1 , and let var1 : = var0 divided by 2 + 1 otherwise otherwise . you have to return var1
given integer var1 , an array of integers var2 . in func0 you have to store in var3 the value of the length of var2 ; store var1 in var4 ; for each var5 between 0 and var3 ( exclusive ) [ ] ; set the value of var6 to be the sum of var7 ; for every var9 in var2 assign var4 - var3 + 1 to var10 , store var9 + var4 - var6 in var11 , let var11 : = maximum of 1 and var11 , set var10 to minimum between var10 and var9 , concatenate space to var8 if the length of var8 is positive , concatenate string representation of maximum of 0 and var9 - 1 + var10 - var11 to var8 ; you have to return var8 . return value returned by function func0 ( 1 , var1 , var2 )
you are given a number var0 , an array of numbers var1 . var8 is array of strings , which has no elements . you have to store in var3 the value of the length of var1 . store the sum of the numbers in var1 in var2 . for var7 in range from 0 to var3 let var5 be var1 [ var7 ] + var0 - var2 if var1 [ var7 ] + var0 - var2 is positive otherwise set var5 to 1 , if 1 + var0 minus var3 is smaller than var1 [ var7 ] you have to set var6 to var0 minus var3 plus 1 else store in var6 the value of var1 [ var7 ] , add concatenation of string representation of var1 [ var7 ] - 1 + var6 - var5 and space to var8 . after the loop is ended , you have to return var8
you are given an integer var0 , arrays of characters var1 , var2 . initialize var3 to zero . if var2 = " <unk> " initialize var5 to 4 , for var6 in range from 1 to <unk> ( inclusive ) increment var4 if var5 is equal to var0 - 1 , set var5 to ( 1 + var5 ) % 7 , in var3 you have to store var4 , and if var0 doesn ' t exceed 29 initialize var3 to 12 else if 30 = var0 initialize var3 to 11 , and if var0 is equal to 31 initialize var3 to 7 otherwise otherwise . return var3
you are given arrays of numbers var0 , var1 . set var2 to the length of var0 . store in var3 the value of 5 + 18 . 0 . var4 is new boolean array of length var3 . iterate var5 from 0 to var2 , inside the loop set var4 [ var0 [ var5 ] ] to true . for var6 in range from 0 to var2 ( exclusive ) let var4 [ var1 [ var6 ] ] : = true . for each var8 in range from 0 to var2 and var9 from 0 to var2 let var10 be var0 [ var8 ] xor var1 [ var9 ] bitwise , increment var7 if var10 is greater than zero and var10 is smaller than var3 and var4 [ var10 ] . return " <unk> " if var7 is odd else " <unk> "
given the number var0 , an array of numbers var1 . in func0 assign the length of var1 to var3 ; let var4 be var0 ; iterate var6 from 0 to var3 , inside the loop add var2 - th element of array var1 to var5 ; store absolute value of var5 in var5 ; you have to return rounded up 1 . 0 multiplied by var5 / var4 . initialize var2 to 0 . return call function func0 with arguments var0 , var1 , var2
given integers var1 , var2 and var3 . in func0 var4 is a new 101 by 101 matrix ; you have to store 1 in var4 [ 0 ] [ 0 ] ; let var5 be var1 ; you have to store in var6 the value of var2 ; assign var3 to var7 ; store 1000000000 . 0 + 7 in var8 ; for each var9 between 1 and var5 ( inclusive ) for each var10 between 1 and var6 ( inclusive ) break if var9 - var10 is less than zero , increment var4 [ var9 ] [ 0 ] by var4 [ var9 - var10 ] [ 0 ] , set var4 [ var9 ] [ 0 ] to var4 [ var9 ] [ 0 ] ( indexing is 0 - based ) modulo var8 , add var4 [ var9 - var10 ] [ 1 ] to var4 [ var9 ] [ 1 ] , set var4 [ var9 ] [ 1 ] to var4 [ var9 ] [ 1 ] modulo var8 if var10 is smaller than var7 otherwise add var4 [ var9 - var10 ] [ 0 ] to var4 [ var9 ] [ 1 ] , set var4 [ var9 ] [ 1 ] to var4 [ var9 ] [ 1 ] ( indexing is 0 - based ) + var4 [ var9 minus var10 ] [ 0 ] , you have to store var4 [ var9 ] [ 1 ] % var8 in var4 [ var9 ] [ 1 ] , increase var4 [ var9 ] [ 1 ] by var4 [ var9 - var10 ] [ 1 ] , set var4 [ var9 ] [ 1 ] to var4 [ var9 ] [ 1 ] % var8 ; you have to return var4 [ var5 ] [ 1 ] . return call func0 with ( 1 , var1 , var2 , var3 )
you are given integers var0 and var1 . initialize var3 to 1000000 . for as long as var2 is less than or equal to var3 set var4 to var3 - var2 divided by two + var2 , if var1 + var0 is less than 3 * var4 or var4 is larger than minimum of var0 and var1 let var3 be var4 - 1 else set var2 to var4 + 1 . after the loop is ended , return var3
we are given integers var0 and var1 . initialize var2 to 1 . iterate var3 from 2 to minimum between var0 and var1 + 1 , inside the loop you have to store in var2 the value of var3 * var2 . after the loop ends you have to return var2
we are given numbers var0 , var1 . let var2 be minimum between var0 and var1 . set var3 to 1 . for each var4 between 1 and var2 ( inclusive ) assign var3 times var4 to var3 . return var3
you are given an integer var1 . in func0 assign var1 to var2 ; for each var4 between 1 and var2 ( inclusive ) add shift 1 left var4 bits to var3 ; you have to return var3 . you have to return value returned by function func0 ( 1 , var1 )
we are given numbers var1 and var2 . in func0 set var3 to var1 ; store var2 in var4 ; you have to set var5 to var3 / 2 ; store var5 / ( var4 plus 1 ) in var6 ; for as long as ( 1 + var4 ) * var6 doesn ' t exceed var5 increment var6 ; decrement var6 ; you have to return concatenation of concatenation of concatenation of concatenation of string representation of var6 and space and string representation of var6 times var4 and space and string representation of var3 - var6 - var4 * var6 . return call function func0 with arguments 1 , var1 , var2
we are given integer var0 . var1 is a new integer array of length 56 . assign 2 to var1 [ 1 ] . for each var2 between 2 and 55 ( inclusive ) assign 2 to the power of var2 + var1 [ var2 - 1 ] to var1 [ var2 ] . you have to return var1 [ var0 ]
we are given integers var1 , var2 and var3 , an array of integers var4 . in __globals__.__init__ __globals__.var0 is a new two dimensional array with 2 x <unk> size . assign the length of var4 to var5 . initialize var6 to zero . set __globals__.var0 [ 0 ] [ 0 ] to 1 . for each var7 between 1 and var5 ( inclusive ) you have to set var8 to var7 and 1 bitwise , for each var9 between 0 and var1 ( inclusive ) for each var10 between 0 and var2 ( inclusive ) set __globals__.var0 [ var8 ] [ var9 ] to __globals__.var0 [ var8 xor 1 bitwise ] [ var9 ] , increment __globals__.var0 [ var8 ] [ var9 - 1 ] ( 0 - based indices ) [ var10 - var4 [ var7 - 1 ] ] if var9 is positive and var10 is greater than or equal to var4 [ var7 minus 1 ] , set __globals__.var0 [ var8 ] [ var9 ] to __globals__.var0 [ var8 ] [ var9 ] ( 0 - based indices ) % var3 . after the loop is ended , for each var12 between 0 and var2 ( inclusive ) increase var11 by __globals__.var0 [ var5 and 1 bitwise ] [ var1 ] , let var11 : = var11 % var3 . return var11
we are given numbers var0 , var1 . initialize var2 to true . while var2 set var2 to false , if var0 exceeds var1 if var0 - 2 is non - negative and var1 minus 1 is non - negative decrement var0 by 2 , decrement var1 , increment var3 , set var2 to true , and if the difference of var0 and 1 is non - negative and var1 - 2 is non - negative decrement var0 , decrement var1 by 2 , increment var3 , set var2 to true otherwise . you have to return var3
we are given numbers var0 and var1 . var11 is an empty array of strings . let var3 : = var0 times ( var1 - 1 ) + 1 . var4 is a new var0 by var0 matrix . for each var5 in range from 0 to var0 and var6 from 0 to var1 - 1 let var4 [ var5 ] [ var6 ] be var5 * ( var1 minus 1 ) + var6 + 1 , for all var7 from var1 - 1 to var0 do the following . assign var3 to var4 [ var5 ] ( indexing is 0 - based ) [ var7 ] , increment var3 . iterate var8 from 0 to var0 , inside the loop increment var2 by var4 [ var8 ] ( indexing is 0 - based ) [ var1 - 1 ] . append string representation of var2 to the end of var11 . for each var9 and var10 in range from 0 to var0 add concatenation of string representation of var4 [ var9 ] [ var10 ] and space to var11 . return var11
you are given arrays of numbers var1 and var2 . in func0 set var3 to the length of var1 ; set var4 to new int % with ( [ ] ) ; iterate var5 from 0 to var3 add var1 [ var5 ] into var4 ; for var6 in range from 0 to var3 add var2 [ var6 ] into var4 ; after the loop is ended , for integer var8 from 0 to var3 and inside it loop another integer var9 from 0 to var3 and if var1 [ var8 ] xor var2 [ var9 ] bitwise is in var4 increment var7 ; return " <unk> " if var7 is even , otherwise " <unk> " . return call function func0 with arguments 1 , var1 , var2
we are given the number var0 . for var1 in range from 0 to 9 ( inclusive ) if var1 + var0 is divisible by 10 increment var0 by var1 , stop iterating , if var0 - var1 is divisible by 10 subtract var1 from var0 , stop iterating . you have to return var0
given an array of integers var0 . initialize var2 to 1 . var5 is a new integer array . assign the length of var0 to var1 . iterate var2 from 0 to var1 , inside the loop let var3 be var2 , while var3 is positive repeat set var4 to var0 [ var3 ] , let var0 [ var3 ] ( indexing is 0 - based ) : = var0 [ var3 - 1 ] ( 0 - based indices ) , in var0 [ var3 - 1 ] you have to store var4 if var0 [ var3 ] is smaller than var0 [ var3 - 1 ] and then decrement var3 . for each var2 between 0 and var1 ( exclusive ) append var0 [ var2 ] to the end of var5 . return var5
you are given integer arrays var0 and var1 . assign the length of var0 to var2 . you have to create an array of boolean var3 of length shift 1 left 21 bits + 121 . for var4 in range from 0 to var2 ( exclusive ) set var3 [ var0 [ var4 ] ] to true . iterate var5 from 0 to var2 ( exclusive ) assign true to var3 [ var1 [ var5 ] ] . iterate var7 from 0 to var2 and var8 from 0 to var2 var8 . return " <unk> " if var6 is equal to 0 , otherwise " <unk> "
we are given integer var0 , an array of integers var1 . var10 is array of strings , which has no elements . set var2 to the length of var1 . var3 is a new array of numbers of length var2 . iterate var4 from 0 to var2 ( exclusive ) let the var1 [ var9 ] be equal to var3 [ var4 ] , also increment var9 . sort var3 . initialize var5 to 1 . var7 is a new array of numbers . while var0 is greater than or equal to var5 repeat if var5 is not equal to var3 [ var6 ] and var6 is less than var2 or var2 is less than or equal to var6 append var5 to var7 , reduce var0 by var5 else increment var6 , increment var5 . append string value of the length of var7 to var10 . for every var8 in var7 add concatenation of string value of var8 and space to var10 . you have to return var10
we are given an array of numbers var1 . in __globals__.__init__ assign None to __globals__.var0 . let var2 be the length of var1 . iterate var6 from 0 to var2 , inside the loop let the var9 - th element of var1 be equal to var7 , also increment var9 , if var7 is divisible by 3 increment var5 else if var7 modulo 3 is equal to 1 increment var3 , and increment var4 otherwise . let var8 be minimum between var3 and var4 + var5 divided by 2 . return var8
we are given numbers var1 and var2 . in func0 let var3 be var1 ; store var2 in var4 ; for as long as 1 doesn ' t exceed var4 and var3 is greater than or equal to 2 or 1 doesn ' t exceed var3 and var4 is greater than or equal to 2 if var3 is greater than var4 subtract 2 from var3 , decrement var4 , increment var5 , decrement var3 , subtract 2 from var4 , increment var5 otherwise ; return var5 . return call function func0 with arguments 1 , var1 , var2
you are given arrays of numbers var0 and var1 . var8 is an empty array of strings . you have to store in var2 the value of len ( var0 ) . you have to create an array of numbers var4 of length <unk> . iterate var5 from 0 to var2 ( exclusive ) let the var0 [ var7 ] be equal to var3 , also increment var7 , increment var4 [ var3 ] . for all var6 from 0 to var2 do the following . add concatenation of concatenation of string value of var2 + var4 [ var1 [ var6 ] ] - 1 and space and string value of var2 - var4 [ var1 [ var6 ] ] - 1 to var8 . return var8
we are given numbers var1 and var2 . in func0 store var1 in var3 ; let var4 be var2 ; decrement var4 ; initialize var5 to 1 ; for as long as true increment var5 , set var5 to var5 % var3 , set var5 to var3 if var5 is equal to 0 , if var4 - var5 is negative stop iterating , decrement var4 by var5 ; return var4 . return value returned by function func0 ( 1 , var1 , var2 )
given the number var0 , arrays of numbers var1 and var2 . let var3 be the length of var1 . for each var4 between 0 and var3 ( exclusive ) [ ] . var5 is new array of reals of length var3 . iterate var6 from 0 to var3 if var1 [ var6 ] is divisible by var0 you have to set var7 to 1 plus 0 . 0 + the difference of var2 [ var6 ] / var0 and var1 [ var6 ] ( indexing is 0 - based ) / var0 else let var7 : = 0 . 0 + var2 [ var6 ] / var0 - var1 [ var6 ] divided by var0 , let var5 [ var6 ] be var7 / ( 1 plus var2 [ var6 ] - var1 [ var6 ] ) . set var8 to 0 . 0 . for var9 in range from 0 to var3 ( exclusive ) add ( 1 minus ( 1 - var5 [ var9 ] ) times 2000 to var8 if 1 + var9 is smaller than var3 otherwise increment var8 by ( 1 - ( 1 - var5 [ var9 ] ) * ( 1 minus var5 [ 0 ] ) . return var8
we are given the number var0 . var4 is new array of strings . if var0 - var0 divided by two * 2 is equal to 0 add " 4 " to var4 , append string value of var0 - 4 to the end of var4 , and add " 9 " to var4 , append string representation of var0 - 9 to var4 otherwise . return var4
we are given integer var0 . initialize var1 to 1 . for each var2 between 0 and var0 assign var1 * 2 to var1 , subtract 100 from var1 if var2 is equal to 12 . after the loop ends you have to return var1
you are given an integer var1 . in func0 assign var1 to var2 ; for each var4 between 1 and var2 ( inclusive ) add shift 1 left var4 bits to var3 ; you have to return var3 . you have to return value returned by function func0 ( 1 , var1 )
we are given a character array var0 . let var1 : = the length of var0 . for var3 in range from 0 to var1 assign var0 [ var3 ] to var4 , if var4 is uppercase add var4 - 65 + 1 to var2 , and reduce var2 by var4 - 97 + 1 if var4 is lowercase otherwise . you have to return var2
we are given an array of numbers var0 . let var1 be the length of var0 . for all var2 from 0 to var1 do the following . [ ] . initialize var3 to zero . var4 is a new array of numbers of length var1 . for each var6 between 0 and var1 ( exclusive ) while var5 is bigger than 1 and var4 [ var5 - 1 ] doesn ' t exceed minimum of var4 [ var5 minus 2 ] ( indexing is 0 - based ) and var0 [ var6 ] increase var3 by minimum between var4 [ var5 - 2 ] and var0 [ var6 ] , decrement var5 , set var4 [ var5 ] to var0 [ var6 ] , increment var5 . after the loop is ended , for each var7 between 1 and var5 - 1 increment var3 by minimum of var4 [ var7 - 1 ] and var4 [ var7 + 1 ] . return var3
we are given an integer var1 . in func0 set var2 to var1 ; set var3 to 2 ; initialize var4 to zero ; iterate var5 from 0 to var2 add var3 to var4 , you have to store in var3 the value of var3 * 2 ; return var4 . you have to return call func0 with ( 1 , var1 )
we are given numbers var0 and var1 . var3 is an empty array of integers . for as long as true if half of var2 > = var1 and var0 is less than or equal to var2 / 2 and var1 + var0 is less than or equal to var2 divided by 3 ( rounded down ) + var2 divided by 2 - var2 divided by 6 ( rounded down ) append var2 to var3 , you have to return var3 , increment var2 . return var3
we are given numbers var0 and var1 . var11 is array of strings , which has no elements . var3 is a new var0 by var0 matrix . initialize var4 to 1 . for each var5 in range from 0 to var1 - 1 and var6 from 0 to var0 assign var4 to var3 [ var6 ] [ var5 ] , increment var4 . for all var7 from 0 to var0 do the following . you have to store var4 in var3 [ var7 ] [ var1 minus 1 ] , increment var2 by var4 , increment var4 , for each var8 between var1 and var0 let var3 [ var7 ] [ var8 ] : = var4 , increment var4 . append string value of var2 to var11 . for each var9 in range from 0 to var0 and var10 from 0 to var0 add concatenation of string representation of var3 [ var9 ] [ var10 ] and space to var11 , add empty string to var11 . after the loop is ended , you have to return var11
we are given numbers var0 and var1 , a string var2 . assign var0 to var3 . set var4 to var1 . store var2 in var5 . for each var7 between 0 and var3 store var5 [ var7 ] in var8 , if var8 - 97 exceeds 122 - var8 assign minimum between var8 - 97 and var4 to var9 , add var8 - var9 to var6 , assign minimum of 122 - var8 and var4 to var9 , concatenate var9 + var8 to var6 otherwise , decrement var4 by var9 . return string representation of - 1 if var4 is positive , otherwise var6
we are given numbers var0 and var1 . var8 is an empty array of strings . initialize var2 to 0 . create an array var3 with size var0 + 1 of type integer . store in var3 [ 0 ] the value of square of var0 + 1 . iterate var4 from 0 to var0 ( exclusive ) set var3 [ var4 + 1 ] to var3 [ var4 ] - 1 + var0 - var1 , increment var2 by var3 [ 1 + var4 ] . after the loop is ended , append string value of var2 to var8 . initialize var5 to 1 . for each var6 between 0 and var0 for each var7 between 1 and var0 ( inclusive ) if var7 is less than var1 add concatenation of string value of var5 and space to var8 , increment var5 , add concatenation of string representation of var3 [ var0 - var6 ] + var7 - var1 and space to var8 otherwise . return var8
given numbers var1 and var2 , an array of integers var3 . in func0 you have to store in var5 the value of the length of var3 ; set var6 to var1 ; store var2 in var7 ; var8 is a new integer array of length var5 + 1 ; for var9 in range from 0 to var5 you have to store in var8 [ var9 + 1 ] the value of var8 [ var9 ] + var3 [ var4 ] ( also increment var4 ) ; var10 is a new grid of size 1 + var5 by 2 ; for each var11 between 0 and var7 ( inclusive ) for var12 in range from 1 to var5 ( inclusive ) in var13 you have to store var11 modulo 2 , you have to store var13 xor 1 bitwise in var14 , set var10 [ var12 ] [ var13 ] to var10 [ var12 - 1 ] [ var13 ] , if var12 - var6 is non - negative and var11 is greater than zero set var10 [ var12 ] [ var13 ] to maximum between var10 [ var12 ] [ var13 ] and var8 [ var12 ] ( indexing is 0 - based ) + var10 [ var12 - var6 ] [ var14 ] - var8 [ var12 - var6 ] ; you have to return var10 [ var5 ] [ var7 % 2 ] . return value returned by function func0 ( 1 , var1 , var2 , var3 , var4 )
you are given an array of integers var0 . you have to set var6 to zero . set var1 to the length of var0 . var2 is a new integer array of length var1 . for all var4 from 0 to var1 do the following . assign var6 - th element of var0 to var2 [ var4 ] , while incrementing var6 . sort var2 . for all var5 from 0 to var1 do the following . add concatenation of string representation of var2 [ var5 ] and space to var3 . return stripped var3
you are given a number var5 , arrays of characters var6 , var7 . in func0 let var3 be the length of var0 - 1 ; while var0 [ var2 ] equals to var1 [ var2 ] increment var2 ; while var0 [ var3 ] is equal to var1 [ var3 ] decrement var3 ; set var4 to var3 - var2 ; increment var2 ; reduce var3 by var4 ; for as long as 1 + decrement var4 is greater than zero if var0 [ var2 ] ( also increment var2 ) ! = var1 [ var3 ] ( also increment var3 ) you have to return 0 ; you have to return 1 . you have to return value returned by function func0 ( var6 , var7 ) + call function func0 with arguments var7 , var6
we are given numbers var0 and var1 . var6 is a new array of numbers . set var2 to 1 . while true repeat assign var2 divided by two to var3 , set var4 to var2 / 3 , set var5 to var2 / 6 , reduce var3 by var5 , decrement var4 by var5 , if maximum between 0 and var0 - var3 + maximum between 0 and the difference of var1 and var4 doesn ' t exceed var5 append var2 to var6 , break and then increment var2 . return var6
given the number var1 , arrays of integers var2 , var3 . in func0 let var6 be the length of var2 ; you have to store in var7 the value of var1 ; initialize var8 to array of reals with length equal to var6 + 1 ; var9 is a new array of numbers of length 1 + var6 ; for var10 in range from 0 to var6 ( exclusive ) assign var4 - th element of var2 to var11 , also increment var4 , assign var5 - th element of var3 to var12 , while incrementing var5 , let var9 [ var10 ] : = 1 + var12 - var11 , set var8 [ var10 ] to value returned by function func1 ( var11 , var12 , var7 ) ; you have to store var8 [ 0 ] in var8 [ var6 ] ; assign var9 [ 0 ] to var9 [ var6 ] ; for var13 in range from 0 to var6 ( inclusive ) let var8 [ var13 ] be 1 - var8 [ var13 ] / var9 [ var13 ] ; initialize var14 to 0 . 0 ; iterate var15 from 0 to var6 , in each iteration you have to do the following : increase var14 by 1 - var8 [ var15 ] * var8 [ var15 + 1 ] ; return var14 multiplied by 2000 . in func1 you have to return var12 / var7 - ( var11 - 1 ) / var7 . you have to return call function func0 with arguments 1 , var1 , var2 , var3 , var4 , var5
we are given numbers var0 , var1 . let var2 : = var0 . you have to store var1 in var3 . for as long as true increment var4 , reduce var2 by 2 , decrement var3 if 2 is less than or equal to var2 and 1 is less than or equal to var3 and var2 is greater than or equal to var3 , otherwise if var2 > = 1 and 2 is less than or equal to var3 and var2 is less than or equal to var3 increment var4 , decrement var2 , reduce var3 by 2 else stop iterating . you have to return var4
we are given the number var0 . initialize var1 to 2 . for each var3 between 1 and var0 ( inclusive ) increment var2 by var1 , set var1 to 2 * var1 . you have to return var2
you are given an integer var0 . for each var2 between 1 and var0 ( inclusive ) increase var1 by 2 to the power of var2 . you have to return var1
given numbers var0 and var1 . return " - 1 " if var0 * 9 is smaller than var1 or var0 is bigger than 1 and var1 is equal to zero , otherwise initialize var3 to empty string , set var4 to var1 - 1 , for var5 in range from 0 to var0 - 1 ( exclusive ) let var6 be 9 if 9 doesn ' t exceed var4 else var4 , decrement var4 by var6 , store in var2 the value of concatenation of string value of var6 and var2 , let var2 be concatenation of string value of 1 + var4 and var2 , store var1 in var4 , for each var7 between 0 and var0 you have to store 9 if 9 is less than or equal to var4 else var4 in var8 , reduce var4 by var8 , concatenate string value of var8 to var3 , return concatenation of concatenation of var2 and space and var3
you are given integer var1 , strings var2 and var3 . in func0 let var4 : = var1 ; you have to store var2 in var5 ; assign var3 to var6 ; if var6 is equal to " <unk> " return 53 if var4 is equal to 5 or var4 is equal to 6 , otherwise 52 , and you have to return 7 if var4 is equal to 31 otherwise return 11 if var4 is equal to 30 , otherwise 12 otherwise . you have to return value returned by function func0 ( 1 , var1 , var2 , var3 )
we are given integers var0 , var1 . you have to set var2 to 2 to the power of var0 . initialize var3 to 76 . while true increment var4 , if var3 = 76 set var3 to 82 if var1 is less than or equal to var2 divided by 2 , otherwise iterate var5 from 0 to var0 ( exclusive ) increment var4 by 2 to the power of var5 , subtract 2 to the power of var0 - 1 from var1 else if var1 is bigger than var2 divided by 2 initialize var3 to 76 , decrement var1 by 2 to the power of var0 - 1 else for each var6 between 0 and var0 ( exclusive ) increase var4 by 2 to the power of var6 , decrement var0 , divide var2 by 2 , if var0 is equal to zero stop iterating . you have to return var4
we are given character arrays var0 , var1 and a character array var2 . in func0 return 32 + var0 if var0 is uppercase else var0 . in func1 you have to return var0 is lowercase . in func2 you have to return - 32 + var0 if var0 is lowercase else var0 . set var3 to new < char | char > with ( [ ] ) . until var4 less than the length of var0 insert var1 [ var4 ] in var3 at var0 [ var4 ] . for every element in var2 at index var6 let var7 be var2 [ var6 ] , if not call func0 with ( var7 ) is in var3 concatenate var7 to var5 , if value returned by function func1 ( var7 ) add value of var7 in var3 to var5 , concatenate call func2 with ( value of value returned by function func0 ( var7 ) in var3 ) to var5 otherwise otherwise . you have to return var5
we are given a number var2 . in func0 return value returned by function func2 ( 2 , var0 ) . in func1 assign var2 to var3 ; for each var0 between 1 and var3 ( inclusive ) increase var4 by value returned by function func2 ( var0 ) ; return var4 . in func2 assign value returned by function func1 ( var5 , shift var6 right 1 bits ) to var7 ; assign square of var7 to var7 ; if var6 and 1 bitwise is not equal to 0 set var7 to var5 times var7 ; return 1 if var6 is equal to 0 , otherwise var7 . return value returned by function func0 ( 1 , var2 )
we are given integers var2 , var3 . in func0 return var0 if var0 is larger than var1 else var1 . in func1 you have to return var0 if var0 is smaller than var1 else var1 . create an array var4 , containing elements : var2 * 2 , 3 multiplied by var3 . set var5 to value returned by function func1 ( var2 / 3 , var3 divided by two ) . while 0 ! = var5 store in var6 the value of 1 if var4 [ 0 ] is larger than var4 [ 1 ] else 0 , increase var4 [ var6 ] by 2 + var6 , decrement var5 if var4 [ var6 ] ( 0 - based indices ) is bigger than var4 [ var6 xor 1 bitwise ] or var4 [ var6 ] is not divisible by 6 divided by ( 2 + var6 ) . return call func0 with ( var4 [ 0 ] , var4 [ 1 ] )
given integers var0 , var1 . you have to store in var2 the value of var0 * 2 . in var3 you have to store 3 * var1 . assign var1 divided by two to var4 . iterate var5 from 0 to var4 , in each iteration you have to do the following : if 2 + var2 is less than var3 + 3 increase var2 by 2 , add 3 to var3 , if var3 is even increment var4 otherwise . return maximum between var2 and var3
we are given an array of numbers var0 . var6 is new array of strings . let var1 : = the length of var0 . var2 is a new integer array of length var1 . for var3 in range from 0 to var1 assign var5 - th element of var0 to var2 [ var3 ] , while incrementing var5 . sort var2 . iterate over all positions var4 in var2 add concatenation of string representation of var2 [ var4 ] and space to var6 . return var6
given arrays of integers var0 and var1 . var11 is new array of strings . you have to set var2 to the length of var0 . for var3 in range from 0 to var2 [ ] . store in var4 the value of new < int | int > with ( [ ] ) . iterate var5 from 0 to var2 , inside the loop insert value of var0 [ var5 ] in var4 + 1 in var4 at var0 [ var5 ] if var0 [ var5 ] ( 0 - based indices ) is in var4 otherwise insert 1 in var4 at var0 [ var5 ] . var6 is a new array of numbers of length var2 . var7 is a new array of numbers of length var2 . for all var8 from 0 to var2 do the following . let var6 [ var8 ] : = var2 - 1 . for var9 in range from 0 to var2 if var1 [ var9 ] is in var4 set var6 [ var9 ] to value of var1 [ var9 ] in var4 + var6 [ var9 ] , set var7 [ var9 ] to var2 - 1 - value of var1 [ var9 ] in var4 else store var2 - 1 in var7 [ var9 ] . for var10 in range from 0 to var2 ( exclusive ) add concatenation of concatenation of string representation of var6 [ var10 ] and space and string representation of var7 [ var10 ] to var11 . you have to return var11
we are given numbers var0 and var1 . var12 is array of strings , which has no elements . var2 is a new grid of size var0 by var0 . var3 is a new var0 by var0 matrix . initialize var4 to 1 . for each var6 in range from 0 to var0 and var7 from 0 to var1 - 1 set var3 [ var6 ] [ var7 ] to var4 , increment var4 . for each var8 between 0 and var0 ( exclusive ) for all var9 from var1 minus 1 to var0 do the following . let var3 [ var8 ] [ var9 ] : = var4 , increment var4 , add var3 [ var8 ] [ var1 - 1 ] to var5 . append string representation of var5 to the end of var12 . for integer var10 from 0 to var0 and inside it loop another integer var11 from 0 to var0 and add concatenation of string value of var3 [ var10 ] [ var11 ] and space to var12 . you have to return var12
you are given integers var1 , var2 and var3 . in __globals__.__init__ assign 1000000007 to __globals__.var0 . var4 is a new two dimensional array with 104 x 2 size . set var4 [ 0 ] [ 0 ] to 1 . assign 0 to var4 [ 0 ] [ 1 ] . for each var5 between 1 and var1 ( inclusive ) set var4 [ var5 ] [ 0 ] to set var4 [ var5 ] [ 1 ] to 0 , for each var6 between 1 and var2 ( inclusive ) if var6 exceeds var5 stop iterating , if var6 is smaller than var3 you have to set var4 [ var5 ] [ 0 ] to ( var4 [ var5 ] [ 0 ] ( 0 - based indices ) modulo __globals__.var0 + var4 [ var5 - var6 ] [ 0 ] % __globals__.var0 ) % __globals__.var0 , you have to store in var4 [ var5 ] [ 1 ] the value of ( var4 [ var5 ] [ 1 ] modulo __globals__.var0 + var4 [ var5 - var6 ] [ 1 ] % __globals__.var0 ) % __globals__.var0 , set var4 [ var5 ] [ 1 ] to ( var4 [ var5 - var6 ] [ 0 ] % __globals__.var0 + var4 [ var5 ] [ 1 ] ( indexing is 0 - based ) modulo __globals__.var0 ) modulo __globals__.var0 , set var4 [ var5 ] [ 1 ] to ( var4 [ var5 - var6 ] [ 1 ] % __globals__.var0 plus var4 [ var5 ] [ 1 ] % __globals__.var0 ) modulo __globals__.var0 otherwise . you have to return var4 [ var1 ] [ 1 ]
given integers var0 and var1 , an array of characters var2 . set var3 to var0 - 1 . store var1 - 1 in var4 . set var6 to - 1 . initialize var7 to 0 . if var4 exceeds var3 / 2 assign var3 - var4 to var4 . for var8 in range from 0 to var3 divided by 2 ( inclusive ) in var9 you have to store | var2 [ var8 ] - var2 [ var3 - var8 ] | , add minimum between var9 and 26 - var9 to var5 , assign var8 to var6 if var6 equals to - 1 otherwise assign var8 to var7 if var2 [ var8 ] is not equal to var2 [ var3 - var8 ] . add minimum between abs of var4 - var6 and abs of var4 - var7 to var5 . increment var5 by maximum between var7 - var6 and 0 . you have to return 0 if - 1 is equal to var6 else var5
you are given integers var0 , var1 . in func0 return the greatest common divisor between var0 and var1 . in func1 return var0 multiplied by var1 / call func0 with ( var0 , var1 ) . let var2 : = value returned by function func1 ( var0 , var1 ) . let var3 : = var2 / var0 . assign var2 / var1 to var4 . decrement var3 if var0 is less than var1 otherwise decrement var4 . if var3 is larger than var4 you have to return " <unk> " , and return " <unk> " if var3 is smaller than var4 , otherwise " <unk> " otherwise
you are given integers var2 , var3 . in __globals__.__init__ you have to store in __globals__.var0 the value of 0 ; you have to set __globals__.var1 to 0 . let __globals__.var0 be var2 . assign var3 to __globals__.var1 . initialize var4 to 1 . for each var5 between 2 and minimum between __globals__.var0 and __globals__.var1 ( inclusive ) you have to set var4 to var5 * var4 . return var4
we are given numbers var2 and var3 . in func0 set var1 to 1 ; for all var2 from 0 to var0 do the following . you have to store var1 * ( var2 + 1 ) in var1 ; after the loop ends you have to return var1 . return call function func0 with arguments var3 if var2 exceeds var3 , otherwise call function func0 with arguments var2
we are given numbers var4 and var5 . in func0 let var1 : = " 1 " ; for each var2 between 2 and var0 ( inclusive ) set var3 to concatenation of string value of var2 and empty string , set var1 to var3 times var1 ; you have to return var1 . return value returned by function func0 ( minimum of var4 and var5 )
we are given arrays of numbers var0 and var1 . let var2 : = the length of var0 . var3 is a new array of length var2 . var4 is a new array of numbers of length var2 . iterate var5 from 0 to var2 ( exclusive ) assign var13 - th element of var0 to var3 [ var5 ] , while incrementing var13 . for all var6 from 0 to var2 do the following . let the var14 - th element of var1 be equal to var4 [ var6 ] , also increment var14 . initialize var7 to 0 . assign var3 [ 0 ] to var9 . set var10 to var4 [ 0 ] . set var11 to var9 + var10 . for var12 in range from 1 to var2 you have to set var9 to var9 or var3 [ var12 ] bitwise , in var10 you have to store var10 or var4 [ var12 ] bitwise , if var9 + var10 is bigger than var11 assign var10 + var9 to var11 . return var11
we are given the number var0 . set var2 to 2 . for each var3 between 1 and var0 ( inclusive ) increment var1 by var2 to the power of var3 . return var1
you are given an integer var0 . for each var2 between 1 and var0 ( inclusive ) increase var1 by 2 to the power of var2 . you have to return var1
given the number var0 . assign var0 to var1 . var2 is a new array of numbers of length 56 . set var2 [ 0 ] to 0 . you have to store in var2 [ 1 ] the value of 1 . for var4 in range from 1 to var1 ( inclusive ) store var2 [ 1 ] + 2 * var2 [ var4 - 1 ] in var2 [ var4 ] , let var3 : = var2 [ var4 ] . return var3 * 2
given arrays of integers var0 , var1 and var2 . initialize var9 to zero . you have to set var8 to zero . let var3 : = the length of var0 . assign the length of var1 to var4 . initialize var5 to zero . initialize var6 to 0 . iterate var7 from 0 to var4 , inside the loop increment var6 by minimum of var0 [ var8 - th element of array var1 ( increment var8 ) - 1 ] and var0 [ var2 [ var9 ] ( also increment var9 ) - 1 ] . you have to return var6
we are given numbers var0 and var1 . if var0 is smaller than 1 plus var1 * 2 you have to return string representation of - 1 , and iterate var4 from 0 to var0 , inside the loop set var5 to ( 1 + var4 ) modulo var0 , while true repeat concatenate concatenation of concatenation of concatenation of string representation of var4 + 1 and space and string value of 1 + var5 and " \ n " to var2 , increment var3 , if var5 = ( var1 + var4 ) % var0 break and then you have to store ( 1 + var5 ) modulo var0 in var5 , after the loop is ended , concatenate concatenation of string value of var3 and " \ n " to var6 , concatenate var2 to var6 , return var6 otherwise
we are given an integer var1 , arrays of characters var2 and var3 . in __globals__.__init__ create an array __globals__.var0 , containing elements : 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 . if " <unk> " is equal to var3 for every var5 in __globals__.var0 if var1 doesn ' t exceed var5 increment var4 , return string value of var4 , and return " 53 " if var1 is equal to 6 or var1 is equal to 5 else 52 otherwise
given numbers var0 and var1 . var3 is array of strings , which has no elements . add " - 1 " to var3 , you have to return var3 if var1 is smaller than var0 - 1 or var1 exceeds 2 + var0 * 2 . for as long as var1 is positive or var0 is greater than zero if var1 = var0 concatenate " 10 " to var2 , decrement var0 , decrement var1 , and concatenate " 0 " to var2 , decrement var0 if var0 is greater than var1 , otherwise if var1 exceeds var0 and var0 is greater than zero concatenate " 110 " to var2 , decrement var0 , decrement var1 by 2 else while var1 is positive repeat concatenate " 1 " to var2 , decrement var1 otherwise . after the loop ends add var2 to var3 . return var3
we are given an array of numbers var0 . var6 is an empty array of strings . let var1 be the length of var0 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) assign var5 - th element of var0 to var2 [ var3 ] , while incrementing var5 . sort var2 . for every var4 in var2 add concatenation of string value of var4 and space to var6 . return var6
given character arrays var4 , var5 and a string var6 . in __globals__.__init__ assign empty string to __globals__.var0 ; store empty string in __globals__.var1 . in func0 for every element in __globals__.var0 at index var3 you have to return __globals__.var1 [ var3 ] if var2 is equal to __globals__.var0 [ var3 ] ; you have to return 42 . store var4 in __globals__.var0 . assign var5 to __globals__.var1 . for every element in var6 at index var3 in var2 you have to store var6 [ var3 ] , if var2 doesn ' t exceed 57 assign var2 to var8 , and if var2 is greater than or equal to 97 you have to set var8 to value returned by function func0 ( var2 ) , and store 65 + call function func0 with arguments var2 - 65 - 97 in var8 otherwise otherwise , concatenate var8 to var7 . return var7
we are given numbers var1 , var2 . in func0 let var3 be var1 ; set var4 to var2 ; set var5 to minimum between var3 and var4 ; set var6 to 1 ; for var7 in range from 2 to var5 ( inclusive ) assign var7 * var6 to var6 ; you have to return var6 . return call function func0 with arguments 1 , var1 , var2
given arrays of numbers var1 and var2 . in func0 let var5 : = the length of var1 ; for var6 in range from 0 to var5 ( exclusive ) [ ] ; after the loop ends iterate var7 from 0 to var5 [ ] ; return " <unk> " . initialize var3 to 0 . return call func0 with ( 1 , var1 , var2 , var3 , var4 )
you are given arrays of integers var0 , var1 . let var2 be the length of var0 . assign new int % with ( [ ] ) to var3 . iterate var4 from 0 to var2 , in each iteration you have to do the following : add var0 [ var4 ] into var3 . for each var5 between 0 and var2 ( exclusive ) add var1 [ var5 ] ( indexing is 0 - based ) into var3 . for each var7 and var8 in range from 0 to var2 increment var6 if var0 [ var7 ] xor var1 [ var8 ] ( indexing is 0 - based ) bitwise is in var3 . return " <unk> " if var6 is even , otherwise " <unk> "
you are given an array of integers var0 . you have to set var7 to zero . set var1 to the length of var0 . initialize var4 to zero . for var5 in range from 0 to var1 ( exclusive ) assign var7 - th element of var0 to var6 , also increment var7 , increment var2 if var6 is divisible by 3 , increment var3 if var6 % 3 is equal to one , if 2 = var6 % 3 increment var4 . you have to return minimum between var3 and var4 + var2 divided by 2
you are given arrays of integers var0 and var1 . assign the length of var0 to var2 . you have to create an array of boolean var3 of length <unk> . iterate var4 from 0 to var2 ( exclusive ) set var3 [ var0 [ var4 ] ] to true . for all var5 from 0 to var2 do the following . set var3 [ var1 [ var5 ] ] to true . for each var7 and var8 in range from 0 to var2 if var3 [ var0 [ var7 ] xor var1 [ var8 ] bitwise ] increment var6 . after the loop is ended , return " <unk> " if var6 is even , otherwise " <unk> "
you are given a string var0 . let var1 be 7 + 1000000000 . 0 . initialize var2 to array of integers with length equal to 256 . initialize var3 to 48 . while var3 < = 57 repeat let var2 [ var3 ] be var3 - 48 and then increment var3 . after the loop is ended , set var4 to 65 . while var4 doesn ' t exceed 90 repeat set var2 [ var4 ] to 10 + var4 - 65 and then increment var4 . after the loop is ended , set var5 to 97 . while var5 is less than or equal to 122 repeat assign var5 - 97 + <unk> . 0 to var2 [ var5 ] and then increment var5 . set var2 [ 45 ] to 62 . you have to store 95 in var2 [ 95 ] . initialize var6 to array of integers with length equal to 64 . for each var7 in range from 0 to 64 and var8 from 0 to 64 increment var6 [ var7 and var8 bitwise ] . set var9 to 1 . iterate over all positions var10 in var0 set var9 to var6 [ var2 [ var0 [ var10 ] ] times var9 modulo var1 . return var9
you are given integers var0 , var1 , var2 , var3 and var4 . if var0 is bigger than var1 or var4 is less than or equal to var2 * var0 you have to return 0 else initialize var5 to zero , store in var6 the value of var0 * var2 , for as long as var6 is smaller than var4 add var0 multiplied by var6 / ( var1 minus var0 ) to var6 , if var6 is smaller than var4 increment var5 , increase var6 by var0 * ( var3 + var6 / var1 ) else stop iterating , you have to return var5
we are given integers var6 , var2 and var7 . in __globals__.__init__ set __globals__.var0 to 1000000007 . in func0 create an array var3 with size var1 + 1 of type integer ; set var3 [ 0 ] to 1 ; for var4 in range from 0 to var1 ( inclusive ) set var5 to 1 , while var5 < = var2 and var4 minus var5 is non - negative repeat let var3 [ var4 ] : = ( var3 [ var4 - var5 ] + var3 [ var4 ] ( indexing is 0 - based ) ) % __globals__.var0 and then increment var5 ; return var3 [ var1 ] . store in var8 the value of var7 minus 1 . return ( __globals__.var0 + call func0 with ( var6 , var2 ) - call func0 with ( var6 , var8 ) ) % __globals__.var0
you are given integers var4 , var5 and an integer var6 . in __globals__.__init__ create an array __globals__.var0 , containing elements : 8 , 10 , 88 , <unk> , 10000000 , <unk> , <unk> , 10000000 , <unk> , 10000000 , 1 , 10000000 , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> ; create an array __globals__.var1 of type integer , containing elements : 1 , 1 , 62 , <unk> , <unk> , <unk> , <unk> , <unk> , 1 , <unk> , 1 , <unk> , <unk> , 1 , <unk> , 1 , <unk> , 2 , 1 , <unk> , <unk> , 1 , <unk> , 2 , <unk> , 1 , <unk> , <unk> , <unk> , 1 , <unk> , 100000000 , <unk> , 1 , <unk> , <unk> , <unk> , 1 , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , <unk> , 88 . var8 is a new array of numbers . iterate over all positions var7 in __globals__.var0 append __globals__.var0 [ var7 ] to the end of var8 , you have to return var8 if __globals__.var0 [ var7 ] is equal to var5 and __globals__.var3 [ var7 ] is equal to var4 and var6 = __globals__.var3 [ var7 ] . you have to return var8
we are given integer var0 . var3 is array of strings , which has no elements . append string value of - 1 to the end of var3 , you have to return var3 if var0 doesn ' t exceed 2 . if var0 is odd you have to set var1 to ( 1 + var0 ) * var0 divided by two , set var2 to 1 + var1 . assign var0 / 4 multiplied by 3 to var1 , let var2 : = 5 * var0 / 4 if var0 is divisible by 4 . if var0 % 4 is equal to 2 assign var0 / 4 multiplied by ( 2 plus var0 ) to var1 , set var2 to var1 + 2 . add concatenation of concatenation of string representation of var1 and space and string representation of var2 to var3 . you have to return var3
you are given an array of numbers var0 . var7 is array of strings , which has no elements . assign len ( var0 ) to var1 . iterate var4 from 0 to var1 , inside the loop for all var5 from var4 to var1 do the following . if var0 [ var4 ] ( 0 - based indices ) is bigger than var0 [ var5 ] store in var3 the value of var0 [ var4 ] , set var0 [ var4 ] to var0 [ var5 ] , set var0 [ var5 ] to var3 . iterate var6 from 0 to var1 , in each iteration you have to do the following : add concatenation of string representation of var0 [ var6 ] and space to var7 . you have to return var7
we are given numbers var0 , var1 , an array of numbers var2 . store the length of var2 in var3 . var4 is a new array of numbers of length 1 + var3 . for each var5 between 1 and var3 ( inclusive ) assign var2 [ var11 ] while incrementing var11 + var4 [ var5 - 1 ] ( 0 - based indices ) to var4 [ var5 ] . var6 is a new 2 by var3 + 1 matrix . for each var7 between 1 and var1 ( inclusive ) set var8 to var7 % 2 , for each var9 between var7 * var0 and var3 ( inclusive ) assign var6 [ var8 ] ( indexing is 0 - based ) [ var9 - 1 ] to var6 [ var8 ] [ var9 ] , assign var6 [ 1 - var8 ] [ var9 - var0 ] + var4 [ var9 ] - var4 [ var9 - var0 ] to var10 , set var6 [ var8 ] [ var9 ] to maximum between var6 [ var8 ] [ var9 ] and var10 . return var6 [ var1 % 2 ] [ var3 ]
given arrays of integers var0 and var1 . assign the length of var0 to var2 . set var3 to the length of var1 . initialize var4 to 0 . initialize var8 to 2147483647 . set var9 to true . iterate var10 from 0 to var2 , inside the loop set var9 to false , initialize var8 to 2147483647 , while var6 is less than var3 and | var0 [ var10 ] - var1 [ var6 ] | is less than or equal to var8 repeat you have to store abs of var0 [ var10 ] - var1 [ var6 ] in var8 , increment var6 , set var9 to true , decrement var6 , if var9 and var8 is bigger than var7 assign var8 to var7 . return var7
you are given arrays of numbers var0 , var1 . set var2 to the length of var0 . for each var3 between 0 and var2 ( exclusive ) [ ] . assign minimum of var2 and 2 to var4 . iterate var5 from 1 to var2 - 1 ( exclusive ) if var0 [ var5 ] - var1 [ var5 ] is larger than var0 [ var5 - 1 ] increment var4 else increment var4 , increase var0 [ var5 ] by var1 [ var5 ] if var0 [ var5 ] plus var1 [ var5 ] is less than var0 [ var5 + 1 ] . after the loop ends you have to return var4
we are given an array of integers var0 . initialize var6 to 0 . set var1 to the length of var0 . create an array var2 of type integer , containing elements : 0 , 0 , 0 , 0 . iterate var3 from 0 to var1 , inside the loop assign var6 - th element of var0 to var4 , also increment var6 , increment var2 [ var4 modulo 3 ] . assign var2 [ 0 ] divided by two to var5 . if var2 [ 1 ] is bigger than var2 [ 2 ] add var2 [ 2 ] to var5 , add var2 [ 1 ] to var5 otherwise . return var5
you are given an integer var1 , an array of arrays of characters var2 . in func0 you have to set var3 to the length of var2 ; you have to store var1 in var4 ; for var5 in range from 0 to var3 ( exclusive ) [ ] ; var6 is a new grid of size var3 by var4 ; assign var3 - 1 to var8 ; while var8 is non - negative repeat assign var4 minus 1 to var9 , while var9 is non negative repeat if var2 [ var8 ] [ var9 ] = 87 and var6 [ var8 ] [ var9 ] is not equal to 1 or var6 [ var8 ] [ var9 ] is not equal to - 1 and var2 [ var8 ] [ var9 ] equals to 66 increment var7 , set var10 to 1 - var6 [ var8 ] [ var9 ] if var2 [ var8 ] [ var9 ] is equal to 87 else - 1 - var6 [ var8 ] [ var9 ] , for each var11 between 0 and var8 ( inclusive ) for var12 in range from 0 to var9 ( inclusive ) increment var6 [ var11 ] [ var12 ] by var10 and then decrement var9 and then decrement var8 ; you have to return var7 . you have to return call func0 with ( 1 , var1 , var2 )
we are given integers var0 and var1 . let var2 be minimum between var0 and var1 . assign var2 - 1 to var3 . while var3 is larger than 1 repeat store var2 * var3 in var2 and then decrement var3 . you have to return var2
given an array of numbers var0 . var6 is new array of strings . initialize var5 to 0 . var1 is a new array of numbers . assign the length of var0 to var2 . for var3 in range from 0 to var2 append var0 [ var5 ] ( also increment var5 ) to the end of var1 . sort var1 . iterate var4 from 0 to var2 ( exclusive ) add concatenation of string value of var1 [ var4 ] and space to var6 . return var6
you are given numbers var0 and var1 . in func0 if var0 is smaller than 2 return 1 if var0 is nonnegative ; return call function func1 with arguments 2 , var0 . in func1 return var1 * var0 if var1 - var0 is equal to one ; you have to return var1 * var0 * ( 1 + var0 ) if 2 = var1 - var0 ; let var2 be var0 + var1 - var0 divided by two ; return var0 if var1 - var0 is equal to 0 , otherwise value returned by function func1 ( var0 , var2 ) * value returned by function func1 ( 1 + var2 , var1 ) . return call function func0 with arguments minimum between var0 and var1
we are given integers var0 and var3 . in func0 set var1 to 1 ; for var2 in range from 1 to var0 ( inclusive ) assign var1 * var2 to var1 ; you have to return string representation of var1 . if var0 is equal to zero or var3 is equal to 0 you have to return " 1 " , and return value returned by function func0 ( var3 ) if var0 is bigger than var3 , otherwise call func0 with ( var0 ) otherwise
given numbers var0 and var1 . initialize var2 to array of integers with length equal to 13 . you have to store 1 in var2 [ 0 ] . for var3 in range from 1 to 13 ( exclusive ) assign var3 times var2 [ var3 - 1 ] to var2 [ var3 ] . you have to set var4 to minimum between var0 and var1 . set var5 to var1 if var4 equals to var0 otherwise set var5 to var0 . you have to return var2 [ var4 ]
you are given integers var0 , var1 . initialize var3 to zero . if var0 is greater than var1 let var2 : = var1 , set var3 to var0 else assign var1 to var3 , set var2 to var0 . initialize var4 to 1 . for var5 in range from 1 to var2 ( inclusive ) assign var5 * var4 to var4 . you have to return var4
we are given numbers var0 , var1 . set var2 to minimum between var0 and var1 . set var3 to 1 . let var4 be var2 . while 1 doesn ' t exceed var4 repeat set var3 to var4 * var3 and then decrement var4 . return var3
we are given integers var0 and var1 . initialize var2 to 1 . for var3 in range from 2 to minimum between var0 and var1 ( inclusive ) set var2 to var3 * var2 . return var2
we are given a string var0 . var4 is new array of strings . set var2 to trimmed var0 . if var2 is equal to one add " 1 1 " to var4 , append string representation of 1 to the end of var4 , add concatenation of concatenation of string representation of ( var2 - 1 ) * 2 and space and string value of 2 to var4 , add concatenation of concatenation of string representation of 1 and space and string value of 2 to var4 otherwise . return var4
we are given an array of numbers var0 . var6 is new array of strings . let var1 : = the length of var0 . var2 is a new integer array of length var1 . for var3 in range from 0 to var1 assign var5 - th element of var0 to var2 [ var3 ] , while incrementing var5 . sort var2 . iterate over all positions var4 in var2 add concatenation of string representation of var2 [ var4 ] and space to var6 . return var6
given integers var0 , var1 , var2 , var3 , var4 , var5 , var6 , var7 , var8 , var9 , var10 and integer var15 . initialize var16 to false . if var7 is equal to 1 and var6 is equal to 1 or var5 is equal to 1 or var4 is equal to one or var6 is equal to one or var2 is equal to one or var5 is equal to one or var2 is equal to 1 or var8 is equal to one or var7 is equal to one and var11 is equal to 1 or var10 is equal to one or var9 is equal to one or var8 is equal to one or var6 is equal to one or var2 is equal to one and var11 is equal to one or var8 is equal to one or var9 is equal to one or var10 is equal to one or var1 is equal to one or var6 is equal to one or var12 is equal to one and var15 is equal to 1 or var10 is equal to 1 or var12 is equal to 1 or var14 is equal to one or var5 is equal to 1 or var10 is equal to 1 initialize var16 to true , and initialize var16 to false otherwise . return YES if var16 , otherwise NO
you are given the number var0 . if last number of var0 in decimal notation is less than 5 subtract last digit of var0 from var0 , and increment var0 by 10 - last number of var0 in decimal notation otherwise . return var0
you are given the number var1 . in func0 let var2 be var1 ; initialize var3 to zero ; for as long as var2 - var3 is not divisible by 10 increment var3 ; for as long as var2 + var4 is not divisible by 10 increment var4 ; you have to return var2 - var3 if var3 is less than var4 else var4 + var2 . you have to return call function func0 with arguments 1 , var1
given numbers var0 and var1 . for var3 in range from 0 to var1 ( inclusive ) set var4 to ( var1 minus var3 ) * var0 , you have to set var5 to ( 1 + var4 ) * 1 * var4 divided by 2 * ( 1 + var3 ) + ( 1 + var4 ) multiplied by var3 * 1 / 2 * ( var4 + 1 ) , assign maximum between var2 and var5 to var2 . you have to return var2
you are given an array of numbers var0 . var6 is an empty array of strings . let var1 be the length of var0 . var2 is a new array of numbers . iterate var3 from 0 to var1 ( exclusive ) append var0 [ var5 ] ( also increment var5 ) to var2 . sort var2 . for every var4 in var2 add concatenation of string representation of var4 and space to var6 . return var6
we are given numbers var0 , var3 . in func0 initialize var1 to 1 ; if var0 is equal to zero you have to return 1 , and for each var2 between 1 and 1 + var0 ( exclusive ) you have to store in var1 the value of var1 * var2 otherwise ; you have to return var1 . return value returned by function func0 ( var3 ) if var0 exceeds var3 , otherwise return value returned by function func0 ( var0 ) if var0 is less than var3 , otherwise value returned by function func0 ( var0 )
we are given numbers var0 , var1 . assign var1 if var0 is bigger than var1 else var0 to var2 . assign var2 - 1 to var3 . while var3 is greater than or equal to 1 repeat store var3 times var2 in var2 and then decrement var3 . after the loop is ended , return var2
we are given integers var0 , var1 . set var2 to 1 . assign minimum between var0 and var1 to var3 . for each var4 between 1 and var3 ( inclusive ) you have to set var2 to var4 * var2 . return var2
we are given a number var0 . let var1 : = last number of var0 in decimal notation . if var1 is less than or equal to 5 while var1 is not equal to 0 repeat decrement var1 , decrement var0 , and for as long as var1 is not equal to 10 increment var1 , increment var0 otherwise . you have to return var0
given an integer var0 . assign last digit of var0 to var1 . decrement var0 by 5 if var1 is equal to 5 . if var1 is equal to 0 let var0 : = var0 . if 4 is greater than or equal to var1 and 1 doesn ' t exceed var1 reduce var0 by var1 . increase var0 by 10 minus var1 if var1 doesn ' t exceed 9 and 6 doesn ' t exceed var1 . return var0
we are given strings var0 , var1 and var2 . let var3 : = new < char | char > with ( [ ] ) . for each var4 between 0 and 26 insert var1 [ var4 ] in var3 at var0 [ var4 ] , insert var1 [ var4 ] minus 65 in var3 at var0 [ var4 ] - 97 . for every element in var2 at index var6 let var7 be value of var2 [ var6 ] in var3 if var2 [ var6 ] is in var3 else var2 [ var6 ] , concatenate var7 to var5 . return var5
you are given a number var1 . in func0 assign var1 to var2 ; assign last number of var2 in decimal notation to var3 ; if 5 doesn ' t exceed var3 increase var2 by 10 - var3 , and decrement var2 by var3 otherwise ; return var2 . you have to return call func0 with ( 1 , var1 )
we are given strings var1 , var2 and var3 . in func0 return var0 is lowercase or var0 is uppercase . set var4 to new < char | char > with ( [ ] ) . for each position var5 in var1 insert var2 [ var5 ] in var4 at var1 [ var5 ] . for every element in var3 at index var7 if var3 [ var7 ] is lowercase concatenate value of var3 [ var7 ] in var4 to var6 , set var8 to var3 [ var7 ] + 32 , add value of var8 in var4 - 32 to var6 otherwise if call function func0 with arguments var3 [ var7 ] otherwise concatenate var3 [ var7 ] to var6 . you have to return var6
we are given a string var0 . initialize var1 to array of integers with length equal to 64 . for each var2 and var3 in range from 0 to 64 increment var1 [ var2 and var3 bitwise ] . assign var0 to var4 . set var5 to 1000000007 . initialize var6 to 1 . until var7 less than the length of var4 let var8 be var4 [ var7 ] , if var8 doesn ' t exceed 57 and var8 is greater than or equal to 48 let var9 be var8 - 48 , if var8 is uppercase assign var8 - 55 to var9 , and if var8 is lowercase set var9 to var8 - 61 , and if var8 is greater than or equal to 97 and var8 doesn ' t exceed 61 set var9 to 62 , set var9 to 63 otherwise otherwise otherwise , set var6 to var1 [ var9 ] * var6 % var5 . after the loop is ended , return var6
we are given character arrays var1 , var2 and var3 . in func0 return 32 + var0 if var0 is uppercase else var0 . in func1 you have to return var0 plus - 32 if var0 is lowercase else var0 . set var4 to new < char | char > with ( [ ] ) . for every element in var1 at index var5 set var6 to var1 [ var5 ] , insert var2 [ var5 ] in var4 at var6 . for every element in var3 at index var8 set var9 to var3 [ var8 ] , if var9 - 97 is non - negative and var9 - 97 is less than 26 add string value of value returned by function func1 ( value of var9 in var4 ) to var7 , and concatenate string value of var9 to var7 otherwise . you have to return var7
we are given an array of numbers var0 . var6 is an empty array of strings . let var1 be the length of var0 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) assign var5 - th element of var0 to var2 [ var3 ] , while incrementing var5 . sort var2 . for every var4 in var2 add concatenation of string value of var4 and space to var6 . return var6
we are given an array of numbers var0 . assign the length of var0 to var1 . set var3 to 1 . initialize var4 to 1 . for all var5 from 0 to var1 do the following . you have to store var5 in var6 , for as long as var6 is positive and var0 [ var6 ] is greater than or equal to var0 [ var6 - 1 ] decrement var6 , increment var3 , let var6 be var5 , while var0 [ var6 ] ( 0 - based indices ) is greater than or equal to var0 [ var6 + 1 ] and var6 is less than var1 - 1 increment var6 , increment var3 , assign maximum between var4 and var3 to var4 , initialize var3 to 1 . you have to return var4
we are given an integer var1 , an array of arrays of characters var2 . in func0 you have to store in var3 the value of the length of var2 ; you have to set var4 to var1 ; iterate var5 from 0 to var3 , in each iteration you have to do the following : [ ] ; var6 is a new grid of size var3 by var4 ; store in var8 the value of var3 - 1 ; while var8 is non negative repeat store var4 - 1 in var9 , while var9 is non negative repeat you have to set var10 to var6 [ var8 ] [ var9 ] , set var11 to 1 if 87 is equal to var2 [ var8 ] [ var9 ] else - 1 , if var10 is not equal to var11 increment var7 , store var11 - var10 in var12 , for each var13 between 0 and var8 ( inclusive ) for each var14 between 0 and var9 ( inclusive ) add var12 to var6 [ var13 ] [ var14 ] and then decrement var9 and then decrement var8 ; return var7 . return call function func0 with arguments 1 , var1 , var2
you are given arrays of numbers var0 and var1 . initialize var17 to zero . assign len of var0 to var2 . let var3 : = the length of var1 . var4 is a new integer array of length var3 . create an array var5 with size var2 of type boolean . var6 is the sum of all elements of var0 . for var9 in range from 0 to var3 ( exclusive ) store var1 [ var17 ] ( also increment var17 ) minus 1 in var4 [ var9 ] , you have to set var5 [ var4 [ var9 ] ] ( indexing is 0 - based ) to true , increment var8 by var0 [ var4 [ var9 ] ] . for var11 in range from 0 to var2 ( exclusive ) increment var10 by var0 [ ( 1 + var11 ) % var2 ] * var0 [ var11 % var2 ] . for every var12 in var4 increase var10 by var0 [ var12 ] multiplied by ( var6 - var0 [ var12 ] - var0 [ ( var12 plus 1 ) % var2 ] - var0 [ ( var12 minus 1 + var2 ) modulo var2 ] ) . for every var14 in var4 set var15 to ( var2 + var14 - 1 ) modulo var2 , let var16 be ( 1 + var14 ) % var2 , decrement var13 by ( var8 - var0 [ var14 ] - ( indexing is 0 - based ) - ( var0 [ var15 ] if var5 [ var15 ] else 0 ) , increase var10 by var13 divided by two , return var10
given an integer var0 , a character array var1 . set var2 to - 1 . assign - 1 to var3 . for all var5 from 0 to var0 do the following . you have to set var2 to var5 , if var3 is non negative and var2 - var3 is even increment var4 if var1 [ var5 ] is equal to 76 , otherwise if var1 [ var5 ] ( indexing is 0 - based ) is equal to 82 assign var5 to var3 , increment var4 by var3 - var2 - 1 . increment var4 by var0 - var2 minus 1 if var2 is greater than or equal to var3 . return var4
you are given a number var5 . in __globals__.__init__ set __globals__.var0 to 0 ; set __globals__.var2 to None ; you have to store None in __globals__.var3 ; let __globals__.var1 : = None ; assign 0 to __globals__.var4 . set var6 to new < int | int > with ( [ ] ) . you have to set var7 to new < int | int > with ( [ ] ) . let var8 : = new < int | int > with ( [ ] ) . set var9 to new < char * | int > with ( [ ] ) . assign new < char * | int > with ( [ ] ) to var10 . if last digit of var5 doesn ' t exceed 5 decrement var5 by last digit of var5 , increase var5 by 10 minus last digit of var5 otherwise . you have to return var5
given an array var0 . var6 is new array of strings . let var1 be the length of var0 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) let the var0 [ var5 ] be equal to var2 [ var3 ] , also increment var5 . after the loop ends sort var2 . iterate var4 from 0 to var1 add concatenation of string value of var2 [ var4 ] and space to var6 . you have to return var6
we are given integers var0 and var1 . set var3 to 1 . for var2 in range from 2 to minimum between var0 and var1 ( inclusive ) store var2 * var3 in var3 . you have to return var3
we are given numbers var0 , var1 . you have to set var2 to var0 if var0 is less than var1 else var1 . set var3 to 1 . assign var2 to var4 . while var4 is greater than or equal to 1 repeat assign var3 multiplied by var4 to var3 and then decrement var4 . you have to return var3
you are given an array of integers var0 . var6 is an empty array of strings . you have to set var5 to zero . assign the length of var0 to var1 . you have to create an array of numbers var2 of length var1 . iterate var3 from 0 to var1 , inside the loop assign var5 - th element of var0 to var2 [ var3 ] , while incrementing var5 . sort var2 . iterate var4 from 0 to var1 , inside the loop if var4 equals to var1 - 1 append string value of var2 [ var4 ] to the end of var6 , add concatenation of string value of var2 [ var4 ] and space to var6 otherwise . after the loop is ended , return var6
given a string var0 . var7 is new array of strings . assign var0 to var1 . while var2 < 10000 repeat set var3 to string representation of var2 , set var4 to the length of var3 , for every var6 in var1 increment var5 , add YES to var7 , append string representation of var2 to the end of var7 , return var7 if var5 is equal to var4 if var6 is equal to var3 [ var5 ] and then increment var2 by 8 . add NO to var7 . you have to return var7
we are given a number var0 , an array of numbers var1 . let var2 be the length of var1 . initialize var3 to zero . var4 is a new array of numbers of length 1 + var2 . for var5 in range from 1 to var2 ( inclusive ) let var4 [ var5 ] be 2 to the power of var5 - 1 . initialize var6 to 9223372036854775807 . iterate var7 from 1 to var2 , in each iteration you have to do the following : you have to store minimum between var1 [ var7 ] and 2 * var1 [ var7 - 1 ] in var1 [ var7 ] . initialize var10 to 9223372036854775807 . let var11 be var2 . while 1 doesn ' t exceed var11 repeat increase var9 by var1 [ var11 - 1 ] multiplied by var0 / var4 [ var11 ] , if var0 is not divisible by var4 [ var11 ] let var10 be minimum between var10 and var1 [ var11 minus 1 ] + var9 else set var10 to minimum of var10 and var9 , reduce var0 by var0 / var4 [ var11 ] ( 0 - based indices ) * var4 [ var11 ] and then decrement var11 . return var10
we are given integer var0 . if last number of var0 in decimal notation doesn ' t exceed 5 subtract last digit of var0 from var0 , you have to set var0 to 10 + var0 - last number of var0 in decimal notation otherwise . return var0
given integers var1 , var2 and var3 , an array of integers var4 . in __globals__.__init__ you have to store 1000000007 in __globals__.var0 . let var5 be the length of var4 . you have to store in var6 the value of var1 . assign var2 to var7 . assign var3 to __globals__.var0 . for each var8 between 0 and var5 [ ] . var9 is a new var6 plus 1 by 1 + var7 matrix . set var9 [ 0 ] [ 0 ] to 1 . for each var10 in range from 0 to var5 and var11 from 0 to var6 for var12 in range from 0 to var7 ( inclusive ) let var9 [ 1 + var11 ] [ var12 + var4 [ var10 ] ] : = ( var9 [ var11 ] [ var12 ] + var9 [ var11 + 1 ] [ var12 + var4 [ var10 ] ) % __globals__.var0 if var7 is greater than or equal to var12 + var4 [ var10 ] . for var14 in range from 0 to var7 ( inclusive ) assign ( var9 [ var6 ] [ var14 ] + var13 ) % __globals__.var0 to var13 . return var13
you are given a character array var0 and a character array var1 . store 1000000000 . 0 + 7 in var2 . var3 is a new integer array of length 10 . initialize var4 to array of integers with length equal to 10 . for var5 in range from 0 to 9 ( inclusive ) assign var5 to var3 [ var5 ] , assign 10 to var4 [ var5 ] ( 0 - based indices ) . store the length of var1 in var6 . set var8 to var6 - 1 . while var8 is non negative repeat assign the difference of var1 [ var8 ] [ 0 ] and 48 to var9 , initialize var11 to 1 , set var12 to the length of var1 [ var8 ] minus 1 , while 3 is less than or equal to var12 repeat let var10 be ( var3 [ var1 [ var8 ] [ var12 ] - 48 ] * var11 plus var10 ) modulo var2 , let var11 be var4 [ var1 [ var8 ] [ var12 ] - 48 ] ( 0 - based indices ) * var11 % var2 and then decrement var12 , set var3 [ var9 ] to var10 , you have to store in var4 [ var9 ] the value of var11 and then decrement var8 . after the loop ends set var14 to 1 . assign the length of var0 minus 1 to var15 . while var15 is non negative repeat set var13 to ( var14 * var3 [ var0 [ var15 ] minus 48 ] + var13 ) % var2 , let var14 be var14 times var4 [ var0 [ var15 ] - 48 ] % var2 and then decrement var15 . return var13
you are given integers var0 and var1 . for var3 in range from 0 to var1 ( inclusive ) set var4 to var0 * ( var1 minus var3 ) , you have to store in var2 the value of maximum of var2 and half of ( var4 plus var3 ) * ( var3 plus 1 ) * ( var3 + var4 ) . you have to return var2
you are given numbers var1 and var2 . in func0 you have to store var1 in var3 ; set var4 to var2 ; assign minimum between var3 and var4 to var5 ; return value returned by function func1 ( var5 ) . in func1 set var8 to 1 ; let var7 : = var6 ; while var7 is greater than 1 repeat set var8 to var7 * var8 and then decrement var7 ; you have to return var8 . you have to return value returned by function func0 ( 1 , var1 , var2 )
you are given the number var0 . var3 is new array of strings . set var1 to ( 1 , 2 ) . if var0 is equal to one initialize var2 to 1 , assign 2 * ( var0 - 1 ) to var2 otherwise . add concatenation of concatenation of string representation of var2 and space and string representation of 2 to var3 . add concatenation of concatenation of string representation of var1 [ 0 ] and space and string representation of var1 [ 1 ] to var3 . return var3
you are given an integer var0 , a string var1 . var8 is an empty array of strings . for each element of the array var1 at indices between 0 and var0 , exclusive , if it equals to 42 then initialize var3 to 1 , while var2 + var3 * 4 is smaller than var0 repeat assign var3 + var2 to var4 , assign var3 * 2 + var2 to var5 , set var6 to var2 + 3 * var3 , store var2 + 4 * var3 in var7 , add " yes " to var8 , return var8 if var1 [ var7 ] is equal to 42 and 42 = var1 [ var6 ] and var1 [ var4 ] = 42 and var1 [ var5 ] equals to 42 and then increment var3 . add " no " to var8 . you have to return var8
you are given an integer var1 , a character array var2 . in __globals__.__init__ set __globals__.var0 to 5 . var7 is an empty array of strings . iterate var3 from 0 to var1 initialize var4 to 1 , while var3 + var4 multiplied by ( __globals__.var0 - 1 ) is smaller than var1 repeat initialize var5 to true , iterate var6 from 0 to __globals__.var0 , inside the loop let var5 be var5 and var2 [ var3 + var4 multiplied by var6 ] is equal to 42 , add " yes " to var7 , return var7 if var5 and then increment var4 . add " no " to var7 . you have to return var7
you are given integers var0 , var1 and var2 . var5 is new array of strings . create an array var3 , containing elements : var0 , var1 , var2 . if var3 [ 1 ] / var3 [ 0 ] + 1 . 0 / var3 [ 2 ] + 1 . 0 / var3 [ 0 ] is less than <unk> add NO to var5 , and sort var3 , if var3 [ 2 ] ( 0 - based indices ) = 4 and var3 [ 0 ] is equal to 2 and var3 [ 1 ] equals to 4 or var3 [ 1 ] is equal to 2 add YES to var5 , for each var4 between 0 and var3 [ 1 ] * var3 [ 0 ] times var3 [ 2 ] ( exclusive ) if var4 - 2 is not divisible by var3 [ 2 ] and var4 - 1 is not divisible by var3 [ 1 ] and var4 is not divisible by var3 [ 0 ] add NO to var5 , you have to return var5 , add YES to var5 otherwise otherwise . return var5
you are given a character array var1 . in func0 you have to return - 48 + var0 if var0 is greater than or equal to 48 and var0 is less than or equal to 57 else var0 + - 55 if var0 is uppercase else var0 + - 87 if var0 is lowercase else - 1 . you have to set var2 to position of " ^ " in var1 . initialize var4 to zero . set var5 to var2 . iterate var6 from 0 to var2 , in each iteration you have to do the following : increment var3 by value returned by function func0 ( var1 [ var6 ] ) times var5 if var1 [ var6 ] is not equal to 61 , decrement var5 . set var5 to 1 . for var7 in range from 1 + var2 to the length of var1 ( exclusive ) if var1 [ var7 ] ! = 61 add value returned by function func0 ( var1 [ var7 ] ) * var5 to var4 , increment var5 . return " <unk> " if var4 = var3 otherwise return " left " if var4 is greater than var3 , otherwise " left "
you are given character arrays var0 , var1 and var2 . assign new < char * | char * > with ( [ ] ) to var5 . for every element in var0 at index var3 insert concatenation of empty string and var1 [ var3 ] in var5 at concatenation of empty string and var2 [ var3 ] . initialize var3 to zero . while var3 is less than the length of var2 store concatenation of empty string and var2 [ var3 ] in var7 , assign lowercased var7 to var7 , let var7 be concatenation of empty string and value of var7 in var5 , set var7 to uppercased var7 , concatenate var7 to var6 if var2 [ var3 ] is uppercase , otherwise concatenate concatenation of empty string and value of concatenation of empty string and var2 [ var3 ] ( indexing is 0 - based ) to var6 if var2 [ var3 ] is lowercase otherwise add concatenation of empty string and var2 [ var3 ] to var6 , increment var3 . you have to return var6
we are given an array of numbers var0 . var6 is new array of strings . let var1 be the length of var0 . var2 is a new array of numbers of length var1 . iterate var3 from 0 to var1 assign var5 - th element of var0 to var2 [ var3 ] , while incrementing var5 . sort var2 . iterate var4 from 0 to var1 , inside the loop append string value of var2 [ var4 ] to the end of var6 , add space to var6 . you have to return var6
you are given arrays of numbers var0 and var1 . var9 is an empty array of strings . initialize var3 to 0 . assign the length of var0 to var4 . assign var4 - 1 to var5 . var6 is a new array of length 1 + 100000 . 0 . for all var7 from 0 to var4 do the following . increment var6 [ var0 [ var7 ] ] . after the loop is ended , iterate var8 from 0 to var4 , inside the loop let var2 : = var6 [ var1 [ var8 ] ] plus var5 , set var3 to var5 * 2 minus var2 , add concatenation of concatenation of string value of var2 and space and string value of var3 to var9 . return var9
given integers var2 and var3 . in func0 return var0 if var1 is greater than or equal to var0 , otherwise var1 . set var4 to value returned by function func0 ( var2 , var3 ) . set var5 to 1 . assign var4 to var6 . while 1 doesn ' t exceed var6 repeat you have to set var5 to var6 multiplied by var5 and then decrement var6 . you have to return var5
we are given a number var0 , an array of numbers var1 . var9 is array of strings , which has no elements . assign len of var1 to var2 . store the sum of the numbers in var1 in var3 . iterate var5 from 0 to var2 , in each iteration you have to do the following : initialize var6 to 0 , assign maximum of 1 and var0 - var3 - var1 [ var5 ] to var7 , assign minimum of the difference of var0 and var2 - 1 and var1 [ var5 ] to var8 , set var6 to var1 [ var5 ] - var8 minus var7 - 1 if var7 is less than or equal to var8 , add concatenation of string representation of var6 and space to var9 . you have to return var9
given an array var0 . let var1 be the length of var0 . var2 is a new integer array of length var1 . for var3 in range from 0 to var1 ( exclusive ) assign var10 - th element of var0 to var4 , also increment var10 , assign var4 to var2 [ var3 ] . sort var2 . var6 is a new integer array of length var1 divided by 2 . initialize var7 to zero . set var8 to var1 - 1 . while var8 is positive repeat set var6 [ var7 ] to var2 [ var8 - 1 ] , increment var7 , decrement var8 if var2 [ var8 ] - var2 [ var8 - 1 ] doesn ' t exceed 1 and then decrement var8 . for each var9 between 0 and var1 divided by two - 1 ( exclusive ) if 0 is not equal to var6 [ var9 ] and var6 [ var9 + 1 ] is not equal to 0 increase var5 by var6 [ var9 ] * var6 [ var9 + 1 ] , increment var9 . you have to return var5
you are given an integer var0 , a string var1 . you have to return " 1 " if var0 is equal to one , otherwise initialize var3 to 1 , let var4 : = the length of var1 , var5 is a new array of numbers of length 128 , you have to store 1 in var5 [ var1 [ 0 ] ] , while var3 is less than var0 repeat you have to store 1 + var3 - var2 in var4 if var5 [ var1 [ var3 ] ] is equal to 0 , increment var5 [ var1 [ var3 ] ] , while var5 [ var1 [ var2 ] ] is greater than 1 and var2 is less than var3 decrement var5 [ var1 [ var2 ] ] , increment var2 , assign minimum of var4 and 1 + var3 minus var2 to var4 , after the loop ends increment var3 , return string representation of var4
you are given an integer var0 , an array of integers var1 . initialize var7 to 0 . in var2 you have to store the length of var1 . set var3 to var0 . iterate var6 from 0 to var2 , inside the loop increment var5 by var7 - th element of array var1 , if var5 is larger than 8 increment var4 by 8 , decrement var5 by 8 , increase var4 by var5 otherwise , if var4 is greater than or equal to var3 stop iterating . after the loop ends assign the difference of 0 and 2 to var6 if var4 is less than var3 . return var6 + 1
we are given numbers var0 and var1 . while true stop iterating if minimum between var0 and var1 is smaller than 1 or maximum of var0 and var1 is smaller than 2 , increment var2 , subtract 2 from var0 , decrement var1 if var0 exceeds var1 , otherwise increment var2 , reduce var1 by 2 , decrement var0 . return var2
we are given integers var0 and var1 . set var2 to 1 . assign minimum between var0 and var1 to var3 . for each var4 between 2 and var3 ( inclusive ) you have to store in var2 the value of var4 * var2 . return var2
you are given integers var0 and var1 . assign var0 to var2 . set var3 to var1 . set var4 to - 2147483648 . if var2 is greater than var3 set var4 to var3 , and assign var2 to var4 otherwise . set var5 to 1 . for each var6 between 1 and var4 ( inclusive ) you have to set var5 to var6 * var5 . you have to return var5
given character arrays var1 , var2 and var3 . in func0 return 32 + var0 if var0 is uppercase else var0 . in func1 return - 32 + var0 if var0 is lowercase else var0 . set var4 to new < char | char > with ( [ ] ) . iterate var5 from 0 to 26 insert var2 [ var5 ] in var4 at var1 [ var5 ] . for every element in var3 at index var7 if var3 [ var7 ] ( indexing is 0 - based ) is uppercase concatenate call function func1 with arguments value returned by function func0 ( var3 [ var7 ] ) in var4 to var6 , and if var3 [ var7 ] is lowercase concatenate value of var3 [ var7 ] in var4 to var6 , add var3 [ var7 ] to var6 otherwise otherwise . return var6
you are given a character array var0 . assign the length of var0 to var1 . in var3 you have to store var1 . you have to store in var5 the value of var0 [ 0 ] ( indexing is 0 - based ) . set var6 to 48 . assign var1 minus 1 to var7 . while var7 is greater than zero repeat decrement var3 , increment var4 , you have to store var0 [ var7 ] in var6 , if var4 is larger than var3 break , if var3 is larger than var4 or var3 is equal to var4 and var6 doesn ' t exceed var5 increment var2 , initialize var4 to 0 , stop iterating otherwise if var0 [ var7 ] ! = 48 and then decrement var7 . after the loop ends increment var2 . return var2
we are given numbers var3 and var4 . in func0 set var1 to 1 ; for each var2 between 1 and var0 ( inclusive ) set var1 to var1 times concatenation of string value of var2 and empty string ; return var1 . return value returned by function func0 ( minimum of var3 and var4 )
we are given numbers var0 , var1 . let var2 be minimum between var0 and var1 . initialize var3 to 1 . for var4 in range from 2 to var2 ( inclusive ) assign var3 times var4 to var3 . you have to return var3
given an array var0 . var6 is new array of strings . let var1 be the length of var0 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) let the var0 [ var5 ] be equal to var2 [ var3 ] , also increment var5 . after the loop ends sort var2 . iterate var4 from 0 to var1 add concatenation of string value of var2 [ var4 ] and space to var6 . you have to return var6
given integers var1 , var2 , var3 and var4 . in func0 set var5 to var1 ; let var6 be var2 ; let var7 : = var3 ; let var8 be var4 ; assign ( 1 + absolute value of var5 - var7 + absolute value of var6 minus var8 ) times 2 to var9 ; if var5 is equal to var7 or var6 is equal to var8 increase var9 by 2 ; return var9 . return value returned by function func0 ( 1 , var1 , var2 , var3 , var4 )
we are given integers var1 and var2 . in func0 var3 is a new array of length 13 ; assign 1 to var3 [ 0 ] ; for var4 in range from 1 to 13 ( exclusive ) store var4 * var3 [ var4 - 1 ] in var3 [ var4 ] ; store in var5 the value of var1 ; set var6 to var2 ; you have to return var3 [ minimum between var5 and var6 ] . return value returned by function func0 ( 1 , var1 , var2 )
given numbers var0 , var1 , var2 and var3 . you have to set var4 to var0 . assign var1 to var5 . let var6 : = var2 . assign var3 to var7 . you have to store 1 + abs of var6 - var4 in var8 . assign absolute value of var7 - var5 + 1 to var9 . increment var8 if var6 is equal to var4 otherwise increment var9 if var7 is equal to var5 . let var10 : = ( var9 + var8 ) times 2 . you have to return var10
we are given an array of characters var0 and an array of characters var1 . assign the length of var1 to var2 . set var3 to false . for each var4 between 0 and var2 for var5 in range from 1 to var2 / 4 ( inclusive ) initialize var3 to true if 42 is equal to var1 [ 3 * var5 plus var4 ] and var1 [ var4 + var5 * 4 ] ( 0 - based indices ) is equal to 42 and var1 [ var4 ] is equal to 42 and var4 + 4 * var5 is smaller than var2 and var1 [ var5 + 2 * var5 ] equals to 42 and 42 is equal to var1 [ var4 + 4 * var5 ] . you have to return " yes " if var3 else " no "
we are given numbers var1 , var2 . in func0 let var3 be var1 ; set var4 to var2 ; set var5 to minimum between var3 and var4 ; set var6 to 1 ; for var7 in range from 2 to var5 ( inclusive ) assign var7 * var6 to var6 ; you have to return var6 . return call function func0 with arguments 1 , var1 , var2
you are given an array of numbers var0 . var7 is array of strings , which has no elements . assign the length of var0 to var1 . initialize var2 to 0 . for each var3 in range from 0 to var1 - 1 and var4 from 0 to var1 - var3 - 1 if var0 [ var4 ] is bigger than var0 [ var4 + 1 ] set var5 to var0 [ var4 ] , set var0 [ var4 ] to var0 [ 1 + var4 ] , store var5 in var0 [ 1 + var4 ] . after the loop is ended , for each var6 between 0 and var1 ( exclusive ) add concatenation of string value of var0 [ var6 ] and space to var7 . return var7
given an array var0 . var6 is new array of strings . let var1 be the length of var0 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) let the var0 [ var5 ] be equal to var2 [ var3 ] , also increment var5 . after the loop ends sort var2 . iterate var4 from 0 to var1 add concatenation of string value of var2 [ var4 ] and space to var6 . you have to return var6
you are given integers var0 , var1 , var2 and var3 . set var4 to 2 times ( absolute value of var0 - var2 - 1 ) + 8 + ( absolute value of var1 - var3 - 1 ) * 2 . let var4 : = ( | var1 minus var3 | minus 1 ) * 2 + 8 if var0 = var2 . if var1 is equal to var3 let var4 be ( absolute value of var0 - var2 - 1 ) * 2 + 8 . you have to return var4
you are given a character array var2 . in __globals__.__init__ assign 1000000000 . 0 + 7 to __globals__.var0 . in func0 you have to return 10 plus var1 - 65 if var1 is uppercase ; if var1 is lowercase return <unk> plus var1 - 97 ; return 63 if var1 is equal to 45 and var1 is less than or equal to 57 , otherwise 62 if var1 is equal to 45 else 63 . initialize var3 to 1 . for every var1 in var2 you have to store call func0 with ( var1 ) in var4 , while var5 is smaller than 6 repeat if var4 and 1 bitwise is equal to 0 set var3 to var3 multiplied by 3 % __globals__.var0 and then increment var5 , let var4 be shift var4 right 1 bits . you have to return var3
we are given strings var1 , var2 and var3 . in func0 return 48 is less than or equal to var0 and var0 doesn ' t exceed 57 . in func1 you have to return var0 is uppercase . in func2 return var0 plus 32 if var0 is uppercase else var0 . in func3 return var0 plus - 32 if var0 is lowercase else var0 . iterate over all positions var5 in var3 set var6 to var3 [ var5 ] , if call func0 with ( var6 ) concatenate var6 to var4 , if call func1 with ( var6 ) add value returned by function func3 ( var2 [ position of var6 in var1 ] ) to var4 , add var2 [ position of var6 in var1 ] to var4 otherwise otherwise . you have to return var4
you are given integer var0 . assign last digit of var0 to var1 . if var1 is smaller than 5 decrement var0 by var1 , and increment var0 by 10 minus var1 otherwise . you have to return var0
we are given arrays of integers var0 , var1 . initialize var12 to zero . you have to set var11 to zero . set var2 to the length of var0 . assign new int % with ( [ ] ) to var3 . assign new int % with ( [ ] ) to var4 . iterate var5 from 0 to var2 , in each iteration you have to do the following : add var0 [ var11 ] while incrementing var11 into var3 . for var6 in range from 0 to var2 add var1 [ var12 ] while incrementing var12 into var4 . for every var8 in var3 for every var9 in var4 you have to store var8 xor var9 bitwise in var10 , if var10 is in var3 or var10 is in var4 increment var7 . return " <unk> " if var7 is even , otherwise " <unk> "
given an array of numbers var0 . var9 is a new array of numbers . initialize var8 to zero . set var1 to len of var0 . var2 is a new array of length 101 . for var3 in range from 0 to var1 ( exclusive ) let the var8 - th element of var0 be equal to var4 , also increment var8 , while 1 + decrement var4 is positive increment var2 [ var4 + 1 ] . after the loop ends iterate var5 from 0 to var1 ( exclusive ) for each var7 between 1 and 100 ( inclusive ) increment var6 , decrement var2 [ var7 ] if var2 [ var7 ] is equal to var1 - var5 , append var6 to the end of var9 . you have to return var9
you are given an array of numbers var0 . var7 is an empty array of strings . you have to store the length of var0 in var1 . for each var2 in range from 0 to var1 - 1 and var3 from 1 to var1 - var2 if var0 [ var3 - 1 ] is greater than var0 [ var3 ] store var0 [ var3 minus 1 ] in var6 , set var0 [ var3 - 1 ] to var0 [ var3 ] , store var6 in var0 [ var3 ] . for each var5 between 0 and var1 add concatenation of string representation of var0 [ var5 ] and space to var7 . return var7
given a number var0 , an array of characters var1 . var9 is a new integer array . for each var10 between 0 and var0 ( exclusive ) set var2 to from 4 until the end of string var1 [ var10 ] , initialize var3 to 1 , initialize var4 to <unk> , set var5 to 1 , while increment var5 minus 1 is less than len of var2 repeat store var3 multiplied by 10 in var3 , increase var4 by var3 , set var3 to 10 * var3 , assign concatenation of string representation of var4 and empty string to var6 , set var7 to concatenation of substring of var6 from 0 to the length of var6 - the length of var2 and var2 , set var8 to var7 , while var8 is less than var4 increment var8 by var3 , append var8 to the end of var9 . return var9
you are given character arrays var1 , var2 and var3 . in func0 let var4 be var1 ; assign var2 to var5 ; store in var6 the value of var3 ; until var8 less than the length of var6 assign var6 [ var8 ] to var9 , if value returned by function func1 ( var9 ) add var5 [ position of var9 in var4 ] to var7 , and add call function func2 with arguments var5 [ position of value returned by function func3 ( var9 ) in var4 ] to var7 otherwise if call function func1 with arguments var9 , otherwise concatenate var9 to var7 ; return var7 . in func1 return var1 is lowercase or var1 is uppercase . in func2 you have to return var1 is lowercase . in func3 you have to return var1 is uppercase if var1 is uppercase else var1 . return 32 + var1 if var1 is lowercase else var1 . in func2 return var1 + call func0 with ( 1 , var1 , var2 , var3 ) . return call func4 with ( 1 , var1 , var2 , var3 )
you are given an integer var0 , an array var1 . var11 is array of strings , which has no elements . set var2 to the length of var1 . var3 is a new integer array of length var2 . iterate var4 from 0 to var2 ( exclusive ) assign var10 - th element of var1 to var3 [ var4 ] , while incrementing var10 . sort var3 . initialize var7 to 1 . var8 is a new integer array . while var5 is less than var0 if var6 is smaller than the length of var3 and var7 is equal to var3 [ var6 ] increment var6 , and add var7 to var5 , append var7 to var8 if var5 is less than or equal to var0 otherwise , increment var7 . append string value of the length of var8 to the end of var11 . for every element in var8 at index var9 add concatenation of string value of var8 [ var9 ] and space to var11 . add empty string to var11 . you have to return var11
we are given integers var4 , var5 and var6 . in func0 store in var2 the value of maximum of var0 and var1 ; let var3 be var2 ; while var3 is positive repeat if var1 is divisible by var3 and var0 is divisible by var3 you have to return var3 , decrement var3 ; you have to return 1 . let var0 : = var4 . let var7 : = var5 . let var1 be var6 . assign - 1 to var8 . while var1 is greater than zero repeat let var9 : = call func0 with ( var0 , var1 ) , reduce var1 by var9 , if var1 is equal to 0 if var9 is less than or equal to var1 , otherwise set var8 to 1 , stop iterating , you have to set var9 to call func0 with ( var7 , var1 ) , reduce var1 by var9 , if var1 is equal to 0 initialize var8 to 1 if var9 is less than or equal to var1 , otherwise break . you have to return var8
we are given integers var1 , var2 and var3 . in __globals__.__init__ you have to store 1000000007 in __globals__.var0 . var4 is a new array of numbers of length var1 + 1 . var5 is a new array of numbers of length 1 plus var1 . fill var4 with 0 . fill var5 with 0 . assign 1 to var4 [ 0 ] . store 1 in var5 [ 0 ] . for var6 in range from 1 to var1 ( inclusive ) set var7 to var6 - 1 , while var6 - var7 doesn ' t exceed var2 and var7 is non - negative repeat set var4 [ var6 ] to var4 [ var6 ] % __globals__.var0 + var4 [ var7 ] % __globals__.var0 , decrement var7 , store var4 [ var6 ] modulo __globals__.var0 in var4 [ var6 ] . you have to store var3 - 1 in var2 . for var8 in range from 1 to var1 ( inclusive ) let var9 : = var8 minus 1 , while var9 is non - negative and var8 - var9 doesn ' t exceed var2 repeat let var5 [ var8 ] be var5 [ var9 ] modulo __globals__.var0 + var5 [ var8 ] modulo __globals__.var0 , decrement var9 , set var5 [ var8 ] to var5 [ var8 ] % __globals__.var0 . return ( __globals__.var0 plus var4 [ var1 ] - var5 [ var1 ] ) modulo __globals__.var0
we are given an array of numbers var0 . var10 is array of strings , which has no elements . let var1 : = the length of var0 . var2 is a new array of numbers of length 101 . iterate var3 from 0 to var1 , inside the loop assign var9 - th element of var0 to var4 , while incrementing var9 , iterate var5 from 0 to var4 increment var2 [ var5 ] . for var6 in range from 0 to var1 ( exclusive ) for each var8 between 0 and 100 ( inclusive ) increment var7 if var1 - var2 [ var8 ] is less than or equal to var6 , add concatenation of string representation of var7 and space to var10 . return var10
given integers var0 and var1 . for var3 in range from 0 to var1 ( inclusive ) set var4 to var0 * ( var1 minus var3 ) , set var2 to maximum of half of ( 1 + var3 ) * ( var4 + 1 ) * var4 + half of ( 1 + var3 ) multiplied by var3 multiplied by ( var4 + 1 ) and var2 . you have to return var2
you are given a number var0 . var1 is a new array of numbers of length 10 . for as long as var0 is greater than zero let var1 [ var2 ] : = last number of var0 in decimal notation , increment var2 , divide var0 by 10 . after the loop ends initialize var4 to zero . iterate var5 from 0 to var2 if var1 [ var5 ] exceeds var3 or 2 doesn ' t exceed var1 [ var5 ] ( indexing is 0 - based ) set var3 to var1 [ var5 ] , let var4 be var5 . let var6 : = shift 1 left var4 bits if var3 is equal to one else shift 1 left 1 + var4 bits - 1 . for var7 in range from 1 + var4 to var2 ( exclusive ) if var1 [ var7 ] is greater than zero increment var6 by shift 1 left var7 bits . return var6
we are given an array var0 . you have to store the length of var0 in var1 . var2 is a new array of numbers of length var1 . for each var3 between 0 and var1 ( exclusive ) let the var6 - th element of var0 be equal to var2 [ var3 ] , also increment var6 . sort var2 . for every var5 in var2 add concatenation of string representation of var5 and space to var4 . return stripped var4
we are given integers var0 and var1 . initialize var2 to 1 . for var3 in range from 1 to minimum between var0 and var1 ( inclusive ) set var2 to var3 * var2 . return var2
you are given arrays of numbers var0 and var1 . let var2 be the length of var0 . var3 is a new array of numbers . for var5 in range from 0 to var2 append var0 [ var5 ] to var3 . iterate var6 from 0 to var2 , inside the loop append var1 [ var6 ] to var3 . return " <unk> "
given the number var0 . you have to set var1 to concatenation of empty string and concatenation of empty string and string representation of var0 . let var1 be concatenation of empty string and string representation of var0 minus 1 . if var1 is smaller than 5 decrement var0 by var1 , and you have to store in var0 the value of var0 - var1 + 10 otherwise . return var0
you are given integer var0 . assign last digit of var0 to var1 . if var1 is greater than 5 increment var0 by 10 - var1 else divide var0 by 10 , let var0 : = 10 * var0 . you have to return var0
given numbers var0 , var1 . assign var0 to var2 . set var3 to var1 - 1 . set var5 to true . while var2 is greater than zero repeat increment var4 , decrement var2 , let var6 be shift 1 left var2 bits and var3 bitwise is equal to 0 , increment var4 by shift 1 left 1 plus var2 bits - 1 if var6 is not equal to var5 , in var5 you have to store not var6 . you have to return var4
given integers var0 , var1 and var2 . var3 is an empty array of strings . add YES to var3 , return var3 if var0 is equal to one or var1 is equal to 1 or var2 is equal to 1 . add YES to var3 , return var3 if 2 = var1 or var0 is equal to 2 and var2 = 2 or var0 = 2 and var2 equals to 2 or var1 is equal to 2 and var0 is equal to 2 or var2 is equal to 2 and var1 is equal to 2 . add YES to var3 , return var3 if 3 = var0 and 3 = var1 and var2 is equal to 3 . add YES to var3 , return var3 if var1 = 4 and var2 is equal to 4 and var0 is equal to 2 or var1 is equal to 2 and var2 is equal to 4 and var0 is equal to 4 or var0 is equal to 4 and var1 = 4 and var2 is equal to 2 . add NO to var3 . return var3
you are given an array of numbers var0 . var7 is array of strings , which has no elements . assign the length of var0 to var1 . var2 is a new array of numbers of length var1 . for var4 in range from 0 to var1 ( exclusive ) let the var6 - th element of var0 be equal to var2 [ var4 ] , also increment var6 . sort var2 . iterate var5 from 0 to var1 , inside the loop add concatenation of string value of var2 [ var5 ] and space to var7 . add empty string to var7 . return var7
we are given integers var0 and var1 . for var2 in range from 1 to var0 ( inclusive ) if var1 is greater than or equal to var2 decrement var1 by var2 , and stop iterating otherwise , if var0 is equal to var2 . you have to return var1
given an array of numbers var0 and an array of numbers var1 . you have to set var13 to zero . store len of var0 in var2 . set var3 to the length of var1 . var4 is a new integer array . var5 is a new array of numbers . for each var7 between 0 and var3 ( exclusive ) in var8 you have to store var13 - th element of array var1 ( increment var13 ) - 1 , append var8 to the end of var4 , append var8 to var5 if var8 is not in var5 . after the loop ends iterate var10 from 0 to var3 and var11 from 0 to the length of var5 var11 . return var9
we are given an integer var0 . initialize var2 to 1 . iterate var3 from 0 to var0 set var2 to var2 * 2 , add var2 to var1 . you have to return var1
we are given numbers var3 and var4 . in func0 set var1 to var0 ; assign var0 - 1 to var2 ; while var2 is greater than or equal to 2 repeat you have to store in var1 the value of var1 * var2 and then decrement var2 ; return var1 . return value returned by function func0 ( minimum of var3 and var4 )
we are given numbers var3 and var4 . in func0 set var1 to 1 ; you have to set var2 to var0 ; while var2 is positive repeat set var1 to var2 * var1 and then decrement var2 ; return var1 . set var5 to minimum between var3 and var4 . return value returned by function func0 ( var5 )
you are given the number var0 . set var2 to 1 . while true repeat if var2 is greater than or equal to var0 stop iterating , reduce var0 by var2 and then increment var2 . return var0
we are given numbers var0 , var1 . let var2 be minimum between var0 and var1 . initialize var3 to 1 . for var4 in range from 2 to var2 ( inclusive ) assign var3 times var4 to var3 . you have to return var3
we are given numbers var1 , var2 . in func0 let var3 : = var1 ; assign var2 to var4 ; while true repeat break if var4 is smaller than var5 + 1 , decrement var4 by 1 + var5 , assign ( 1 + var5 ) % var3 to var5 ; you have to return var4 . you have to return call func0 with ( 1 , var1 , var2 )
you are given numbers var0 , var1 . var7 is array of strings , which has no elements . assign var1 - 1 to var2 . add " - 1 - 1 " to var7 , return var7 if var1 is larger than var0 * 9 or var0 is not equal to 1 and var1 is equal to zero . for var5 in range from 0 to var0 concatenate string representation of minimum of 9 and var1 to var4 , decrement var1 by minimum between 9 and var1 . iterate var6 from 0 to var0 - 1 , inside the loop set var3 to concatenation of string representation of minimum of 9 and var2 and var3 , subtract minimum between 9 and var2 from var2 . set var3 to concatenation of string representation of 1 + var2 and var3 . add concatenation of concatenation of var3 and space and var4 to var7 . return var7
given a number var0 . let var1 be shift 1 left var0 bits . let var2 be new bool * * with ( var1 , var1 ) . store true in var2 [ 0 ] ( indexing is 0 - based ) [ 0 ] . set var3 to 1 . for each var3 and var4 in range from 0 to var1 for each var5 between 0 and var3 ( exclusive ) let var2 [ var4 + var3 ] [ var5 ] : = var2 [ var4 ] [ var5 ] , set var2 [ var4 ] [ var5 + var3 ] to var2 [ var4 ] [ var5 ] , set var2 [ var4 + var3 ] [ var5 + var3 ] to not var2 [ var4 ] [ var5 ] . after the loop ends set var3 to 2 * var3 . iterate var7 from 0 to var1 ( exclusive ) iterate var8 from 0 to var1 ( exclusive ) add 43 if var2 [ var7 ] [ var8 ] else 43 to var6 , concatenate 10 to var6 . return var6
you are given arrays of integers var0 , var1 . let var2 be the length of var0 . assign new int % with ( [ ] ) to var3 . iterate var4 from 0 to var2 , in each iteration you have to do the following : add var0 [ var4 ] into var3 . for each var5 between 0 and var2 ( exclusive ) add var1 [ var5 ] ( indexing is 0 - based ) into var3 . for each var7 and var8 in range from 0 to var2 increment var6 if var0 [ var7 ] xor var1 [ var8 ] ( indexing is 0 - based ) bitwise is in var3 . return " <unk> " if var6 is even , otherwise " <unk> "
given an array of numbers var0 and an array of numbers var1 . initialize var7 to 0 . store in var2 the value of the length of var0 . var3 is a new grid of size var2 by 2 . initialize var4 to zero . iterate var6 from 0 to var2 , inside the loop assign var7 - th element of var0 to var3 [ var6 ] [ 0 ] , while incrementing var7 , assign var8 - th element of var1 to var3 [ var6 ] [ 1 ] , also increment var8 , increment var5 by var3 [ var6 ] [ 1 ] - var3 [ var6 ] [ 0 ] , set var4 to minimum between var4 and var5 . you have to return var4
you are given integer arrays var0 and var1 . let var2 be the length of var0 . var3 is a new integer array of length var2 * var2 . initialize var4 to 0 . for each var7 in range from 0 to var2 and var8 from 0 to var2 let var3 [ var5 ] : = var0 [ var8 ] xor var1 [ var7 ] bitwise , increment var4 if var3 [ var5 ] ( 0 - based indices ) is equal to var0 [ var8 ] or var3 [ var5 ] is equal to var1 [ var7 ] , increment var5 . return " <unk> " if var4 is even , otherwise " <unk> "
given an array var0 . var6 is new array of strings . let var1 be the length of var0 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) let the var0 [ var5 ] be equal to var2 [ var3 ] , also increment var5 . after the loop ends sort var2 . iterate var4 from 0 to var1 add concatenation of string value of var2 [ var4 ] and space to var6 . you have to return var6
you are given integers var0 , var1 , var2 and var3 . var5 is a new array of numbers . increase var0 by var2 * 8 . if var1 is less than or equal to var0 append 0 to the end of var5 else append - 1 to var5 , you have to return var5 if var2 is less than or equal to var3 . increase var4 by rounded up ( var1 - var0 ) / 12 * var2 - var3 . increment var0 by 12 * ( var2 - var3 ) . append var4 to var5 . you have to return var5
you are given a character array var0 . for every var2 in var0 assign 1 if 91 is bigger than var2 and 64 is smaller than var2 else 0 to var3 , assign 1 if <unk> is bigger than var2 and var2 is smaller than 96 else 0 to var4 , you have to set var5 to var2 - 97 + 1 if var2 > = 97 else var2 - 65 + 1 , increment var1 by var5 * var3 - var4 * var5 . you have to return var1
given integers var1 , var2 and var3 . in func0 set var4 to var1 ; set var5 to var2 ; you have to store var3 in var6 ; let var7 be maximum between var6 + var4 + var5 and var4 * var5 times var6 ; if var4 is equal to 1 assign maximum between var7 and ( var4 + var5 ) * var6 to var7 ; if var5 is equal to 1 set var7 to maximum between var7 and maximum between ( var5 + var4 ) multiplied by var6 and ( var6 + var5 ) multiplied by var4 ; if var6 is equal to 1 let var7 : = maximum between var7 and ( var6 + var5 ) * var4 ; you have to return var7 . you have to return call function func0 with arguments 1 , var1 , var2 , var3
we are given an array of numbers var0 . var6 is new array of strings . you have to set var1 to len of var0 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) assign var5 - th element of var0 to var2 [ var3 ] , while incrementing var5 . sort var2 . append string representation of var2 [ 0 ] to var6 . iterate var4 from 1 to the length of var2 ( exclusive ) add concatenation of space and string representation of var2 [ var4 ] to var6 . you have to return var6
you are given integers var0 , var1 and a number var2 . if var1 is equal to 1 or var0 and 1 bitwise is equal to 0 return " <unk> " else if var2 is equal to 1 return " <unk> " , set var3 to 2 , while var3 squared < = var1 and var1 is not divisible by var3 repeat increment var3 , return " <unk> " if square of var3 is larger than var1 or var1 / var3 is smaller than var2 , otherwise " <unk> " otherwise
given an array var0 . var6 is new array of strings . let var1 be the length of var0 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) let the var0 [ var5 ] be equal to var2 [ var3 ] , also increment var5 . after the loop ends sort var2 . iterate var4 from 0 to var1 add concatenation of string value of var2 [ var4 ] and space to var6 . you have to return var6
you are given numbers var0 , var1 . assign new < char * | int > with ( [ ] ) to var2 . assign new < char * | char * > with ( [ ] ) to var3 . initialize var4 to 1 . while var4 doesn ' t exceed var1 repeat reduce var1 by var4 , increment var4 , initialize var4 to 1 if var4 is larger than var0 . you have to return var1
given an array var0 . var6 is new array of strings . let var1 be the length of var0 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) let the var0 [ var5 ] be equal to var2 [ var3 ] , also increment var5 . after the loop ends sort var2 . iterate var4 from 0 to var1 add concatenation of string value of var2 [ var4 ] and space to var6 . you have to return var6
we are given an array of numbers var0 . var6 is an empty array of strings . let var1 be the length of var0 . var2 is a new array of numbers of length var1 . for var3 in range from 0 to var1 ( exclusive ) assign var5 - th element of var0 to var2 [ var3 ] , while incrementing var5 . sort var2 . for every var4 in var2 add concatenation of string value of var4 and space to var6 . return var6
we are given integers var0 and var1 . initialize var2 to 1 . for var3 in range from 1 to minimum between var0 and var1 ( inclusive ) set var2 to var3 * var2 . return var2
given numbers var1 , var2 . in func0 assign var1 to var3 ; assign var2 to var4 ; assign minimum between var3 and var4 to var5 ; set var6 to 1 ; for each var7 between 1 and var5 ( inclusive ) assign var6 * var7 to var6 ; you have to return var6 . return call function func0 with arguments 1 , var1 , var2
given integers var0 , var1 and var2 . create an array var3 with size 101 of type integer . you have to create an array of numbers var4 of length 101 . set var5 to 1000000007 . assign 1 to var3 [ 0 ] . for each var6 between 1 and var0 ( inclusive ) set var7 to 1 , while var7 doesn ' t exceed var1 and var7 is less than or equal to var6 repeat let var3 [ var6 ] : = ( var3 [ var6 - var7 ] + var3 [ var6 ] ) % var5 and then increment var7 . you have to store 1 in var4 [ 0 ] . for var8 in range from 1 to var0 ( inclusive ) set var9 to 1 , while var9 is smaller than var2 and var8 is greater than or equal to var9 repeat store ( var4 [ var8 ] + var4 [ var8 - var9 ] ) modulo var5 in var4 [ var8 ] and then increment var9 . after the loop is ended , you have to return ( var3 [ var0 ] + var5 - var4 [ var0 ] ) % var5
given numbers var1 and var2 . in func0 assign var1 to var3 ; let var4 be var2 ; assign minimum between var3 and var4 to var5 ; set var6 to 1 ; assign var5 to var7 ; while var7 is greater than or equal to 1 repeat you have to set var6 to var6 * var7 and then decrement var7 ; you have to return var6 . return call function func0 with arguments 1 , var1 , var2
you are given arrays of integers var0 , var1 . let var2 be the length of var0 . assign new int % with ( [ ] ) to var3 . iterate var4 from 0 to var2 , in each iteration you have to do the following : add var0 [ var4 ] into var3 . for each var5 between 0 and var2 ( exclusive ) add var1 [ var5 ] ( indexing is 0 - based ) into var3 . for each var7 and var8 in range from 0 to var2 increment var6 if var0 [ var7 ] xor var1 [ var8 ] ( indexing is 0 - based ) bitwise is in var3 . return " <unk> " if var6 is even , otherwise " <unk> "
we are given integers var4 , var5 . in __globals__.__init__ let __globals__.var0 : = 0 ; set __globals__.var1 to 0 ; set __globals__.var2 to 0 ; set __globals__.var3 to 0 . var6 is array of strings , which has no elements . set __globals__.var0 to var4 . you have to set __globals__.var2 to var5 . assign __globals__.var0 to __globals__.var3 . if __globals__.var0 is odd decrement __globals__.var3 . divide __globals__.var1 by 2 . set __globals__.var2 to half of __globals__.var1 - __globals__.var3 modulo ( 1 + __globals__.var1 ) . if __globals__.var2 is equal to 0 add concatenation of concatenation of concatenation of concatenation of string representation of 0 and space and string value of 0 and space and string representation of __globals__.var3 to var6 , and add concatenation of concatenation of concatenation of concatenation of string value of __globals__.var3 and space and string value of __globals__.var3 * __globals__.var1 and space to var6 , append string representation of __globals__.var3 - ( 1 + __globals__.var2 ) * __globals__.var2 to the end of var6 otherwise . return var6
we are given a number var0 . you have to set var2 to last number of var0 in decimal notation . if var2 is less than 5 assign var0 - var2 to var1 , and if var2 is greater than 5 let var1 be 10 + var0 - var2 , and assign var0 - var2 to var1 otherwise otherwise . you have to return var1
given an integer var1 . in func0 you have to set var2 to var1 ; assign last digit of var2 to var3 ; if 5 is greater than or equal to var3 subtract var3 from var2 else increase var2 by 10 - var3 ; you have to return var2 . return value returned by function func0 ( 1 , var1 )
you are given strings var0 , var0 , var3 . in struct0 . __init__ assign empty string to this . var0 ; set this . var1 to empty string ; assign " <unk> " to this . var2 ; you have to return this . in func1 return var3 if concatenation of empty string and var3 is in this . var1 , otherwise this . var0 [ position of var3 in this . var0 ] . in func2 assign var0 to this . var0 ; add uppercased this . var0 to this . var1 ; assign var1 to this . var0 ; add uppercased this . var1 to this . var2 ; set var5 to var3 ; until var6 less than the length of var5 assign call function func1 with arguments this , var5 [ var6 ] to var5 [ var6 ] ; return var5 . store call function struct0 . __init__ in var7 . you have to return value returned by function func2 ( var7 , 1 , var0 , var3 )
you are given character arrays var0 , var1 and var2 . in func0 return var0 is uppercase or var0 is lowercase . in func1 you have to return var0 is uppercase . in func2 return - 32 + var0 if var0 is lowercase else var0 . var3 is a new array of numbers of length 26 . for all var5 from 0 to 26 do the following . set var6 to var0 [ var5 ] - 97 , assign var5 to var3 [ var6 ] . iterate over all positions var7 in var2 you have to store in var8 the value of var2 [ var7 ] ( indexing is 0 - based ) , if call func0 with ( var8 ) set var9 to var8 - 65 , concatenate concatenation of call function func2 with arguments var1 [ var3 [ var9 ] ] and empty string to var4 if value returned by function func1 ( var8 ) , otherwise you have to store var8 - 97 in var9 , add concatenation of var1 [ var3 [ var9 ] ] and empty string to var4 , and add concatenation of var8 and empty string to var4 otherwise . you have to return var4
given an integer var0 . if last number of var0 in decimal notation doesn ' t exceed 5 decrement var0 by last digit of var0 , and in var0 you have to store var0 - last number of var0 in decimal notation + 10 otherwise . return var0
you are given numbers var0 , var1 . initialize var4 to 1 . initialize var6 to zero . initialize var9 to zero . set var2 to var0 if var0 is less than var1 else var1 . for each var10 between 1 and var2 ( inclusive ) let var4 be var10 * var4 . return var4
you are given the number var0 . assign last number of var0 in decimal notation to var1 . assign var0 to var2 . if var1 doesn ' t exceed 5 decrement var2 by var1 , and add 10 - var1 to var2 otherwise . you have to return var2
you are given arrays of integers var0 , var1 . let var2 be the length of var0 . assign new int % with ( [ ] ) to var3 . iterate var4 from 0 to var2 , in each iteration you have to do the following : add var0 [ var4 ] into var3 . for each var5 between 0 and var2 ( exclusive ) add var1 [ var5 ] into var3 . for each var7 and var8 in range from 0 to var2 increment var6 if var0 [ var7 ] xor var1 [ var8 ] ( indexing is 0 - based ) bitwise is in var3 . you have to return " <unk> " if var6 is even else " <unk> "
you are given numbers var1 , var2 . in func0 you have to set var3 to var1 ; assign var2 to var4 ; assign minimum between var3 and var4 to var5 ; set var6 to 1 ; while var5 is positive repeat set var6 to var5 * var6 , decrement var5 ; you have to return concatenation of string value of var6 and empty string . return call func0 with ( 1 , var1 , var2 )
we are given numbers var0 and var1 . if var0 is less than var1 let var0 be var0 xor store in var1 the value of var1 xor you have to set var0 to var0 xor var1 bitwise . in var2 you have to store " 1 " . assign var1 to var3 . while 1 doesn ' t exceed var3 repeat you have to set var2 to var3 * var2 and then decrement var3 . return var2
you are given numbers var0 , var1 and var2 . initialize var3 to zero . set var4 to 1000000007 . var5 is a new array of numbers of length var0 + 1 . assign 1 to var5 [ 0 ] . for var6 in range from 1 to var0 ( inclusive ) for each var7 between 1 and var1 ( inclusive ) increment var5 [ var6 ] by var5 [ var6 - var7 ] % var4 if var7 is less than or equal to var6 . set var3 to var5 [ var0 ] . fill var5 with 0 . you have to set var5 [ 0 ] to 1 . for var8 in range from 1 to var0 ( inclusive ) for var9 in range from 1 to var2 ( exclusive ) if var8 > = var9 increment var5 [ var8 ] by var5 [ var8 minus var9 ] % var4 . reduce var3 by var5 [ var0 ] % var4 . you have to return var3 % var4
given numbers var4 , var5 and var6 . in __globals__.__init__ set __globals__.var0 to None . in func0 __globals__.var0 is a new grid of size var1 by var1 ; store 1 in __globals__.var0 [ 0 ] ( 0 - based indices ) [ 0 ] ; for each var2 between 1 and var1 let __globals__.var0 [ var2 ] [ 0 ] be 1 , for var3 in range from 1 to var2 ( inclusive ) assign __globals__.var0 [ var2 - 1 ] [ var3 ] + __globals__.var0 [ var2 - 1 ] [ var3 - 1 ] to __globals__.var0 [ var2 ] [ var3 ] . call function func0 with arguments 70 . iterate var2 from 4 to var6 , in each iteration you have to do the following : increase var7 by __globals__.var0 [ var5 ] [ var6 - var2 ] * __globals__.var0 [ var4 ] [ var2 ] . return var7
you are given a number var0 . assign last number of var0 in decimal notation to var2 . if 5 is less than or equal to var2 assign var0 + 10 - var2 to var1 , and you have to store var0 - var2 in var1 otherwise . you have to return var1
you are given an array of numbers var0 . var7 is array of strings , which has no elements . assign the length of var0 to var1 . for each var4 in range from 0 to var1 and var5 from 0 to var1 if var0 [ var4 ] is less than var0 [ var5 ] store var0 [ var4 ] in var2 , set var0 [ var4 ] ( indexing is 0 - based ) to var0 [ var5 ] , set var0 [ var5 ] to var2 . for each var6 between 0 and var1 add concatenation of string representation of var0 [ var6 ] and space to var7 . return var7
you are given arrays of integers var0 , var1 . let var2 be the length of var0 . assign new int % with ( [ ] ) to var3 . iterate var4 from 0 to var2 , in each iteration you have to do the following : add var0 [ var4 ] into var3 . for each var5 between 0 and var2 ( exclusive ) add var1 [ var5 ] ( indexing is 0 - based ) into var3 . for each var7 and var8 in range from 0 to var2 increment var6 if var0 [ var7 ] xor var1 [ var8 ] ( indexing is 0 - based ) bitwise is in var3 . return " <unk> " if var6 is even , otherwise " <unk> "
you are given a character array var2 . in func0 you have to store var0 in var1 ; return 62 if var1 is equal to 95 else var1 - 55 if var1 is bigger than 96 else var1 - 48 if var1 is bigger than 96 else var1 - 48 . set var3 to <unk> - " . set var4 to 1000000007 . var5 is a new array of length 64 . set var6 to 1 . for integer var8 from 0 to 64 and inside it loop another integer var7 from 0 to 64 and increment var5 [ var8 and var7 bitwise ] . for as long as var8 is less than the length of var2 set var6 to var5 [ call function func0 with arguments var2 [ var8 ] ] * var6 % var4 , increment var8 . return var6
given numbers var1 and var2 . in func0 store var1 in var3 ; let var4 be var2 ; set var7 to var4 ; while var7 is non negative repeat set var5 to maximum of var5 and ( 1 + var7 ) * var7 / 2 + half of ( var6 + 1 ) * var6 * ( var7 + 1 ) , decrement var7 , add var3 to var6 ; return var5 . you have to return call func0 with ( 1 , var1 , var2 )
given numbers var1 , var2 . in func0 assign var1 to var3 ; let var4 be var2 ; for var6 in range from 0 to var4 ( inclusive ) store var3 * ( var4 - var6 ) in var7 , you have to store maximum between ( 1 + var7 ) multiplied by var7 / 2 * ( 1 + var6 ) + var5 multiplied by half of ( 1 plus var6 ) * var6 and var5 in var5 ; you have to return var5 . you have to return call func0 with ( 1 , var1 , var2 )
given integers var1 , var2 and an integer var6 . in __globals__.__init__ let __globals__.var0 be 1000000007 . in func0 var3 is a new array of numbers of length 1 + var1 ; assign 1 to var3 [ 0 ] ; for var4 in range from 0 to var1 ( inclusive ) set var5 to 1 , while var5 doesn ' t exceed var2 and var4 minus var5 is non - negative repeat in var3 [ var4 ] you have to store ( var3 [ var4 ] plus var3 [ var4 - var5 ] ) % __globals__.var0 and then increment var5 ; after the loop is ended , return var3 [ var1 ] . decrement var6 . in var3 you have to store ( __globals__.var0 + call func0 with ( var1 , var2 ) - call function func0 with arguments var1 , var6 ) % __globals__.var0 . return var3
