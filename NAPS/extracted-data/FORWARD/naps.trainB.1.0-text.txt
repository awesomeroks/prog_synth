given integers var0 , var1 , var2 , var3 . initialize var4 to var0 , var5 to var1 , var6 to var2 , var7 to var3 , var8 to the integer division of ( var4 + var6 - 1 ) by var6 . initialize var9 to var8 * var5 . return " YES " , if var7 is less than var9 - var5 . otherwise , return " NO " . 
given integers var0 , var1 , var2 , var3 . initialize var4 to var0 , var5 to var1 , var6 to var2 , var7 to var3 , var8 to the integer division of ( var4 + var6 - 1 ) by var6 . initialize var9 to var8 * var5 . 
given integers var0 , var1 , var2 , var3 . initialize var4 to var0 , var5 to var1 , var6 to var2 , var7 to var3 , var8 to the integer division of ( var4 + var6 - 1 ) by var6 . 
given integer array var0 . assign 1 and 6 to var2 and var4 . assign var0 to var3 . sort var3 . let var6 be the sum of all modules ( ( var7 + 1 ) - var3 [ var7 ] ) . 
given integer array var0 . assign 1 and 6 to var2 and var4 . assign var0 to var3 . sort var3 . 
given integer array var0 . assign 1 and 6 to var2 and var4 . assign var0 to var3 . sort var3 . 
given integer array var0 . assign 1 and 6 to var2 and var4 . assign var0 to var3 . sort var3 . return the sum of all modules ( ( var7 + 1 ) - var3 [ var7 ] ) . 
given integer array var0 . assign 1 and 6 to var2 and var4 . assign var0 to var3 . 
given an array var1 and an integer var2 . initialize var3 to the length of var1 , var4 to an array of length var3 . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] to var1 [ var2 ] and increase var2 by 1 . sort elements of var4 in increasing $$CONSTANT$$ . initialize var6 to 0 . for each var7 from 1 to var3 , add the absolute value of var4 [ var7 - 1 ] - var7 to var6 . 
given an array var1 and an integer var2 . initialize var3 to the length of var1 , var4 to an array of length var3 . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] to var1 [ var2 ] and increase var2 by 1 . sort elements of var4 in increasing $$CONSTANT$$ . 
given an array var1 and an integer var2 . initialize var3 to the length of var1 , var4 to an array of length var3 . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] to var1 [ var2 ] and increase var2 by 1 . 
given an array var1 and an integer var2 . initialize var3 to the length of var1 , var4 to an array of length var3 . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] to var1 [ var2 ] and increase var2 by 1 . sort elements of var4 in increasing $$CONSTANT$$ . initialize var6 to 0 . for each var7 from 1 to var3 , add the absolute value of var4 [ var7 - 1 ] - var7 to var6 . return var6 . 
given integers var3 , var4 . initialize var5 to 0 , var2 to $$CONSTANT$$ . while var3 - th bit of var2 equals to var4 - th bit of var2 , decrease var2 by 1 . 
given integers var3 , var4 . initialize var5 to 0 , var2 to $$CONSTANT$$ . while var3 - th bit of var2 equals to var4 - th bit of var2 , decrease var2 by 1 . return 2 in power of ( var2 + 1 ) - 1 . 
given integer var0 and integer typed arrays var1 , var2 . let var4 be the sum of all elements in var1 . create an integer typed array var5 of size var3 at var6 th position containing the value var2 [ var6 ] - b [ var6 ] . sort var5 . 
given integer var0 and integer typed arrays var1 , var2 . let var4 be the sum of all elements in var1 . create an integer typed array var5 of size var3 at var6 th position containing the value var2 [ var6 ] - b [ var6 ] . 
given integer var0 and integer typed arrays var1 , var2 . create an integer typed array var5 of size var3 . let var4 be the sum of all elements in var1 . 
given integers var0 , var1 , var2 and var3 , initialize var4 to var3 / var1 , rounded up , multiply var4 by var2 and substract var4 from var0 . if var0 < = 0 , then return " NO " , otherwise if var3 % var1 ! = 0 , then return " YES " , otherwise if var0 > var2 , then return " YES " , otherwise return " NO " . 
given integers var0 , var1 , var2 and var3 , initialize var4 to var3 / var1 , rounded up , multiply var4 by var2 and substract var4 from var0 . 
given integers var3 and var1 , initialize var4 to var3 / var1 , rounded up . 
you are given an array of numbers var4 ( indexing is 0 - based ) , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var3 . set var7 to var2 and var8 to var3 . return the number of positions var11 in var4 with var4 [ var11 ] greater than var7 and var4 [ var11 ] less than var8 . 
you are given an array of numbers var4 ( indexing is 0 - based ) , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var3 . set var7 to var2 and var8 to var3 . store in var9 the number of positions var11 in var4 with var4 [ var11 ] greater than var7 and var4 [ var11 ] less than var8 . 
you are given an array of numbers var4 , an index var5 , $$CONSTANT$$ number var7 , $$CONSTANT$$ number var8 , $$CONSTANT$$ number var9 . set var12 to var4 [ var5 ] and add 1 to var5 . if var12 is greater than var7 and var12 is less than var8 , add 1 to var9 . 
given an integer var4 , an integer var5 , and an array of integers var6 . set the value of cnt to the number of integers in var6 which are smaller than var5 and bigger than var4 . 
given an array of integer var6 , an integer var8 , an integer var11 , and $$CONSTANT$$ record $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . add 1 to var8 if ( $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . b < var6 [ var11 ] < $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ ) . 
given integers var0 , var1 . initialize var2 to $$CONSTANT$$ . for each var3 from $$CONSTANT$$ to 0 , if var3 - th bit of var0 equals to var3 - th bit of var1 , set var2 to var3 and break the loop . 
given integers var0 , var1 , var2 and an array var3 . return the number of elements var7 in var3 such that var7 is greater than var1 and var7 is less than var2 . 
given integers var0 , var1 , var2 and an array var3 . return the number of elements var7 in var3 such that var7 is greater than var1 and var7 is less than var2 . 
given integers var0 , var1 . initialize var2 to $$CONSTANT$$ . for each var3 from $$CONSTANT$$ to 0 , if var3 - th bit of var0 equals to var3 - th bit of var1 , set var2 to var3 and break the loop . return 2 ^ ( var2 + 1 ) - 1 . 
given an array var0 . initialize var1 to var0 . sort elements of var1 in increasing $$CONSTANT$$ . initialize var2 to the length of var0 , var6 to an array of length var2 . for each var5 from 0 to var2 exclusive , set var6 [ var5 ] to var5 + 1 . initialize var5 to 0 . for each element var7 in var1 , add the absolute value of var6 [ var5 ] - var7 to var3 and increase var5 by 1 . 
given an array var0 . initialize var1 to var0 . sort elements of var1 in increasing $$CONSTANT$$ . initialize var2 to the length of var0 , var6 to an array of length var2 . for each var5 from 0 to var2 exclusive , set var6 [ var5 ] to var5 + 1 . 
given an array var0 . initialize var1 to var0 . sort elements of var1 in increasing $$CONSTANT$$ . 
given an array var0 . initialize var1 to var0 . 
given an array var0 . initialize var1 to var0 . sort elements of var1 in increasing $$CONSTANT$$ . initialize var2 to the length of var0 , var6 to an array of length var2 . for each var5 from 0 to var2 exclusive , set var6 [ var5 ] to var5 + 1 . initialize var5 to 0 . for each element var7 in var1 , add the absolute value of var6 [ var5 ] - var7 to var3 and increase var5 by 1 . return var3 . 
you are given integers var0 and var1 . if var1 is equal to 0 or to 2 : ( assign var0 to var0 divided by 3 rounded down . if var0 is odd number assign var1 to remainder of ( var1 + 2 ) divided by 4 . if var1 is equal to zero and var2 is equal to 1 or 2 update var1 to 1 else if var1 and var2 are equal to 2 update var1 to 0 ) else if var1 is equal to 1 : ( assign var3 to remainder of var0 divided by 3 . assign var0 to var0 divided by 3 rounded down . if var3 is equal to 1 assign var1 to 0 . if var3 is equal to 2 assign var1 to 2 ) . return var1 as answer . 
you are given $$CONSTANT$$ number var0 and an array of numbers var1 ( indexing is 0 - based ) . you have to set var2 to the length of var1 . you have to create two associative containers var3 and var4 . you have to store in var4 all different numbers in var1 at positions greater than zero as key and its frequency as value . you have to set var7 to zero and add the key var1 [ 0 ] with value 1 in var3 . for each var8 between 1 and var2 - 2 , you have to subtract 1 to the value of the key var1 [ var8 ] in var4 , if var1 [ var8 ] is divisible by var0 and var3 contains the key var1 [ var8 ] divided by var0 ( rounded down ) and var4 contains the key var1 [ var8 ] * var0 ; you have to add the multiplication of the value of the key var1 [ var8 ] divided by var0 ( rounded down ) in var3 and the value of the key var1 [ var8 ] * var0 in var4 to var7 ; if var3 contains the key var1 [ var8 ] you have to add 1 to the value of the key var1 [ var8 ] in var3 ; otherwise you have to insert the key var1 [ var8 ] with value 1 in var3 . 
you are given $$CONSTANT$$ number var0 and an array of numbers var1 ( indexing is 0 - based ) . you have to set var2 to the length of var1 . you have to create two associative containers var3 and var4 . you have to store in var4 all different numbers in var1 at positions greater than zero as key and its frequency as value . you have to set var7 to zero and add the key var1 [ 0 ] with value 1 in var3 . for each var8 between 1 and var2 - 2 , you have to subtract 1 to the value of the key var1 [ var8 ] in var4 , if var1 [ var8 ] is divisible by var0 and var3 contains the key var1 [ var8 ] divided by var0 ( rounded down ) and var4 contains the key var1 [ var8 ] * var0 ; you have to add the multiplication of the value of the key var1 [ var8 ] divided by var0 ( rounded down ) in var3 and the value of the key var1 [ var8 ] * var0 in var4 to var7 ; if var3 contains the key var1 [ var8 ] you have to add 1 to the value of the key var1 [ var8 ] in var3 ; otherwise you have to insert the key var1 [ var8 ] with value 1 in var3 . after the loop in var8 ends you have to return var7 . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 , an associative container var3 , an associative container var4 , an index var8 , $$CONSTANT$$ number var7 . you have to subtract 1 to the value of the key var1 [ var8 ] in var4 . if var1 [ var8 ] is divisible by var0 and var3 contains the key var1 [ var8 ] divided by var0 ( rounded down ) and var4 contains the key var1 [ var8 ] * var0 ; you have to add the multiplication of the value of the key var1 [ var8 ] divided by var0 ( rounded down ) in var3 and the value of the key var1 [ var8 ] * var0 in var4 to var7 . if var3 contains the key var1 [ var8 ] you have to add 1 to the value of the key var1 [ var8 ] in var3 ; otherwise you have to insert the key var1 [ var8 ] with value 1 in var3 . 
you are given $$CONSTANT$$ number var0 and an array of numbers var1 . you have to set var2 to the length of var1 . you have to create two associative containers var3 and var4 . for each var6 between 1 and var2 - 1 , if var4 contains the key var1 [ var6 ] you have to add 1 to the value of the key var1 [ var6 ] in var4 ; otherwise you have to add the key var1 [ var6 ] with value 1 in var4 . you have to set var7 to zero and add the key var1 [ 0 ] with value 1 in var3 . 
you are given $$CONSTANT$$ number var0 and an array of numbers var1 . you have to set var2 to the length of var1 . you have to create two associative containers var3 and var4 . for each var6 between 1 and var2 - 1 , if var4 contains the key var1 [ var6 ] you have to add 1 to the value of the key var1 [ var6 ] in var4 ; otherwise you have to add the key var1 [ var6 ] with value 1 in var4 . you have to set var7 to zero and add the key var1 [ 0 ] with value 1 in var3 . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 , an associative container var3 , an associative container var4 , an index var8 , $$CONSTANT$$ number var7 . you have to subtract 1 to the value of the key var1 [ var8 ] in var4 . if var1 [ var8 ] is divisible by var0 and var3 contains the key var1 [ var8 ] divided by var0 ( rounded down ) and var4 contains the key var1 [ var8 ] * var0 ; you have to add the multiplication of the value of the key var1 [ var8 ] divided by var0 ( rounded down ) in var3 and the value of the key var1 [ var8 ] * var0 in var4 to var7 . 
given integers var0 , var1 . set var0 to var0 modulo 6 . for each var2 from var0 to 0 excluisve , if var2 is even , set var1 to 3 - var1 ; else set var1 to 1 - var1 . 
given integers var0 , var1 . set var0 to var0 modulo 6 . for each var2 from var0 to 0 excluisve , if var2 is even , set var1 to 3 - var1 ; else set var1 to 1 - var1 . return var1 . 
given integers var0 , var1 , var2 . assign $$CONSTANT$$ % 6 to var3 . assign var2 to var4 . for all var5 $$CONSTANT$$ from var3 downto 1 do following operations . if var5 $$CONSTANT$$ odd value then if var4 equals 0 then assign 1 to var4 . otherwise , if it equals 1 then assign 0 to var4 . if var5 is even value then if var4 is 2 then assign 1 to var4 . otherwise , if var4 equals 1 then assign 2 to var4 . 
given integers var0 , var1 , var2 . assign $$CONSTANT$$ % 6 to var3 . assign var2 to var4 . for all var5 $$CONSTANT$$ from var3 downto 1 do following operations . if var5 $$CONSTANT$$ odd value then if var4 equals 0 then assign 1 to var4 . otherwise , if it equals 1 then assign 0 to var4 . if var5 is even value then if var4 is 2 then assign 1 to var4 . otherwise , if var4 equals 1 then assign 2 to var4 . when the loop is ended , return var4 . 
given integer array var0 . insert the value var0 [ var4 ] into var1 . as long as , var1 contains the value var2 , add var2 to the end of var7 and substract 1 from var2 . 
given two arrays of numbers var0 and var1 , store in var10 the minimum number between the amount of ones in var0 and the amount of numbers not equal to one in var0 , store in var11 the minimum number between the amount of ones in var1 and the amount of numbers not equal to one in var1 . 
given two arrays of numbers var0 and var1 , store in var3 the amount of ones in var0 , store in var6 the amount of numbers not equal to one in var0 , store in var4 the amount of ones in var1 , store in var5 the amount of numbers not equal to one in var1 . 
given two arrays of numbers var0 and var1 , store in var10 the minimum number between the amount of ones in var0 and the amount of numbers not equal to one in var0 , store in var11 the minimum number between the amount of ones in var1 and the amount of numbers not equal to one in var1 . if var0 does not have ones or if all numbers in var0 are ones and if var1 does not have ones or if all numbers in var1 are ones then return 0 , else return var10 + var11 . 
given an integer var2 , $$CONSTANT$$ integer var0 , an integer var1 , and an integer var3 . set the value of var4 to var1 * ( var0 / var2 ) ( rounded up ) . set the value of var6 to ( var3 + var1 * ( var0 / ( var2 * 2 ) ) ( rounded up ) ) . return " YES " if var6 is smaller than var4 . return " YES " if there exists an integer $$CONSTANT$$ ( 1 < = $$CONSTANT$$ ) such that ( ( var3 < $$CONSTANT$$ * var1 < var4 ) and ( var0 - var2 * $$CONSTANT$$ > var2 ) ) . 
given an integer var2 , $$CONSTANT$$ integer var0 , an integer var1 , and an integer var3 . create an array of strings var8 . set the value of var5 to 0 . set the value of var4 to var1 * ( var0 / var2 ) ( rounded up ) . set the value of var6 to ( var3 + var1 * ( var0 / ( var2 * 2 ) ) ( rounded up ) ) . return " YES " if var6 is smaller than var4 . 
given an integer var2 , $$CONSTANT$$ integer var0 , an integer var1 , and an integer var3 . create an array of strings var8 . set the value of var5 to 0 . set the value of var4 to var1 * ( var0 / var2 ) ( rounded up ) . set the value of var6 to ( var3 + var1 * ( var0 / ( var2 * 2 ) ) ( rounded up ) ) . 
given an integer var2 , $$CONSTANT$$ integer var0 , an integer var1 , and an integer var3 . create an array of strings var8 . set the value of var5 to 0 . set the value of var6 to var3 . set the value of var4 to var1 * ( var0 / var2 ) ( rounded up ) . 
given an integer var2 , $$CONSTANT$$ integer var0 , an integer var1 , and an integer var3 . create an array of strings var8 . set the value of var5 to 0 . set the value of var6 to var3 . set the value of var4 to var1 * ( var0 / var2 ) ( rounded up ) . 
given an integer var2 , $$CONSTANT$$ integer var0 , an integer var1 , and an integer var3 . set the value of var4 to var1 * ( var0 / var2 ) ( rounded up ) . set the value of var6 to ( var3 + var1 * ( var0 / ( var2 * 2 ) ) ( rounded up ) ) . return " YES " if var6 is smaller than var4 . return " YES " if there exists an integer $$CONSTANT$$ ( 1 < = $$CONSTANT$$ ) such that ( ( var3 < $$CONSTANT$$ * var1 < var4 ) and ( var0 - var2 * $$CONSTANT$$ > var2 ) ) . otherwise , return " NO " . 
given integers var0 , var1 , var2 , var3 . assign 0 to var4 . assign var3 to var5 . as long as var0 exceeds 0 do following operations . if var4 exceeds var5 then substract var2 from var0 and add var1 to var5 . otherwise , if var5 exceeds var4 then substract var2 from var0 and add var1 to var4 . otherwise , substract * $$CONSTANT$$ from var0 and add var1 to var4 and to var5 . 
given integers var0 , var1 , var2 , var3 . assign 0 to var4 . assign var3 to var5 . as long as var0 exceeds 0 do following operations . if var4 exceeds var5 then substract var2 from var0 and add var1 to var5 . otherwise , if var5 exceeds var4 then substract var2 from var0 and add var1 to var4 . otherwise , substract * $$CONSTANT$$ from var0 and add var1 to var4 and to var5 . when the loop is ended , return the larger of var4 and var5 . 
given integers var0 , var1 , var2 . create integer array var5 of size 3 at position var2 containing the value 1 . for all var6 $$CONSTANT$$ from $$CONSTANT$$ % 6 + 6 downto 1 do following operations . if var6 is even value then exchange values of var5 [ 1 ] and var5 [ 2 ] . otherwise , exhcange values of var5 [ 0 ] , var5 [ 1 ] . when the loop is ended , let var10 be the $$CONSTANT$$ position in var5 where the value 1 stands . 
given integers var0 , var1 , var2 . create integer array var5 of size 3 at position var2 containing the value 1 . for all var6 $$CONSTANT$$ from $$CONSTANT$$ % 6 + 6 downto 1 do following operations . if var6 is even value then exchange values of var5 [ 1 ] and var5 [ 2 ] . otherwise , exhcange values of var5 [ 0 ] , var5 [ 1 ] . 
given integers var0 , var1 , var2 . create integer array var5 of size 3 at position var2 containing the value 1 . for all var6 $$CONSTANT$$ from $$CONSTANT$$ % 6 + 6 downto 1 do following operations . if var6 is even value then exchange values of var5 [ 1 ] and var5 [ 2 ] . otherwise , exhcange values of var5 [ 0 ] , var5 [ 1 ] . when the loop is ended , return the $$CONSTANT$$ position in var5 where the value 1 stands . 
given integers var0 , var1 , var2 and var3 , initialize var4 to var0 , var5 to var1 , var6 to var2 , var7 to var3 , var8 to 0 , var9 to 0 . initialize var10 to 0 and for as long as var10 < var4 , add 1 to var8 , add var6 to var10 if var8 % var5 = 0 . set var10 to 0 and for as long as var10 < var4 , add 1 to var9 , add 2 * var6 to var10 if var9 % var5 = 0 and var9 > var7 , add var6 to var10 if var9 % var5 = 0 and var9 < = var7 . 
given integers var0 , var1 , var2 and var3 , initialize var4 to var0 , var5 to var1 , var6 to var2 , var7 to var3 , var8 to 0 , var9 to 0 . initialize var10 to 0 and for as long as var10 < var4 , add 1 to var8 , add var6 to var10 if var8 % var5 = 0 . 
given integers var0 , var1 , var2 and var3 , initialize var4 to var0 , var5 to var1 , var6 to var2 , var7 to var3 , var8 to 0 , var9 to 0 . initialize var10 to 0 and for as long as var10 < var4 , add 1 to var8 , add var6 to var10 if var8 % var5 = 0 . 
given integers var9 , var5 , var10 , var7 and var6 , add 1 to var9 , add 2 * var6 to var10 if var9 % var5 = 0 and var9 > var7 , add var6 to var10 if var9 % var5 = 0 and var9 < = var7 . 
given integers var8 , var5 , var10 and var6 , add 1 to var8 , add var6 to var10 if var8 % var5 = 0 . 
you are given an array of numbers var3 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 . you have to store in var4 the number of elements in var3 greater than var1 and less than var2 . 
you are given an array of numbers var3 , an index var8 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var4 . you have to set var7 to var3 [ var8 ] and add 1 to var8 . if var7 is greater than var1 and var7 is less than var2 you have to add 1 to var4 . 
you are given an array of numbers var3 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 . you have to store in var4 the number of elements in var3 greater than var1 and less than var2 . you have to return var4 . 
given integers var0 , var1 , var2 and an array var3 . return the number of elements x in var3 such that x is greater than var1 and x is less than var2 . 
given integers var0 , var1 , var2 and an array var3 . initialize var7 to the length of var3 . 
given integers var0 , var1 , var2 and an array var3 . return the number of elements x in var3 such that x is greater than var1 and x is less than var2 . 
given integers var0 , var1 , var2 and integer typed array var3 . let var5 be the number of elements in var3 whuch are in the range from first + 1 to sec - 1 . 
given integers var0 , var1 , var2 and integer typed array var3 . if var3 [ var6 ] is in the range from first + 1 to sec - 1 then add 1 to var5 . 
given integers var0 , var1 , var2 and integer typed array var3 . return the number of elements in var3 whuch are in the range from first + 1 to sec - 1 . 
given integer var0 and integer arrays var1 , var2 . let var5 be the sum of all elements of var1 . create integer array var4 of size var3 at var6 th position containing the value var2 [ var6 ] - $$CONSTANT$$ [ var6 ] . sort var4 . add to var5 the sum of all negative elements of var4 . 
you are given integers var0 , var1 , var2 and an array var3 of integer type . let var6 be the number of elements in var3 which are larger than var1 and less than var2 . 
you are given integers var0 , var1 , var2 and an array var3 of integer type ( 0 - based ) . return the number of elements in var3 which are larger than var1 and less than var2 . 
given integer var0 and integer arrays var1 , var2 . let var5 be the sum of all elements of var1 . create integer array var4 of size var3 at var6 th position containing the value var2 [ var6 ] - $$CONSTANT$$ [ var6 ] . sort var4 . add to var5 the sum of all negative elements of var4 . return var5 . 
you are given an array of numbers var3 ( indexing is 0 - based ) , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 . you have to return the number of positions var7 in var3 with var3 [ var7 ] greater than var1 and var3 [ var7 ] less than var2 and var0 greater than var1 and var0 less than var2 . 
you are given an array of numbers var3 ( indexing is 0 - based ) , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 . you have to store in var5 the number of positions var7 in var3 with var3 [ var7 ] greater than var1 and var3 [ var7 ] less than var2 and var0 greater than var1 and var0 less than var2 . 
given integer var0 and integer arrays var1 , var2 . create array var4 of size var3 , at var6 th position containing the value var1 [ var6 ] - b [ var6 ] . let var5 be the sum of all minimums between pairwise elements from var1 and var2 . sort var4 . let var5 be the sum of positive elements from var4 with positions less than var0 . 
given integer var0 and integer arrays var1 , var2 . create array var4 of size var3 , at var6 th position containing the value var1 [ var6 ] - b [ var6 ] . let var5 be the sum of all minimums between pairwise elements from var1 and var2 . sort var4 . 
given integer var0 and integer arrays var1 , var2 . create array var4 of size var3 , at var6 th position containing the value var1 [ var6 ] - b [ var6 ] . let var5 be the sum of all minimums between pairwise elements from var1 and var2 . sort var4 . 
given integer var0 and integer arrays var1 , var2 . create array var4 of size var3 , at var6 th position containing the value var1 [ var6 ] - b [ var6 ] . let var5 be the sum of all minimums between pairwise elements from var1 and var2 . 
given integer var0 and integer arrays var1 , var2 . create array var4 of size var3 , at var6 th position containing the value var1 [ var6 ] - b [ var6 ] . let var5 be the sum of all minimums between pairwise elements from var1 and var2 . sort var4 . return the sum of positive elements from var4 with positions less than var0 . 
given an array of integer var1 , and array of integer var2 . create an array var4 of integers of the same length of var1 . set the value of var5 to the sum of integers in array var1 . set the value of var4 [ var6 ] ( 0 < = var6 < | var4 | ) to ( var1 [ var6 ] - var2 [ var6 ] ) . 
given an array of integer var1 . create an array var4 of integers of the same length of var1 . set the value of var5 to the sum of integers in array var1 . 
given an array of integer var1 , and array of integer var2 . create an array var4 of integers of the same length of var1 . set the value of var5 to the sum of integers in array var1 . set the value of var4 [ var6 ] ( 0 < = var6 < | var4 | ) to ( var1 [ var6 ] - var2 [ var6 ] ) . sort array var4 in non - decreasing $$CONSTANT$$ . 
given an array of integer var1 . create an array var4 of integers of the same length of var1 . set the value of var5 to the sum of integers in array var1 . 
you are given integers var1 , var0 . create an array var2 of size 3 with elements { 0 , 1 , 2 } . set var0 to var0 mod 6 . iterate from 0 to var0 - 1 with index var3 , in each iteration if var3 is divisible by 2 , swap var2 [ 0 ] with var2 [ 1 ] , otherwise swap var2 [ 1 ] with var2 [ 2 ] . 
you are given integers var1 , var0 . create an array var2 of size 3 with elements { 0 , 1 , 2 } . set var0 to var0 mod 6 . iterate from 0 to var0 - 1 with index var3 , in each iteration if var3 is divisible by 2 , swap var2 [ 0 ] with var2 [ 1 ] , otherwise swap var2 [ 1 ] with var2 [ 2 ] . return var2 [ var1 ] . 
given $$CONSTANT$$ string var0 and an array of strings var1 , find the number of positions var3 in var1 such that var0 occurs in var1 [ var3 ] at least once . store the result in var4 . 
given $$CONSTANT$$ string var0 , an array of strings var1 and integers var3 and var4 , add 1 to var4 if var0 occurs in var1 [ var3 ] at least once . 
given $$CONSTANT$$ string var0 and an array of strings var1 , find the number of positions var3 in var1 such that var0 occurs in var1 [ var3 ] at least once . return " $$CONSTANT$$ " if the result is even , return " $$CONSTANT$$ " otherwise . 
given integers var0 , var1 , var2 , integer array var3 . initialize var5 to the number of elements in var3 which are in the range between var1 , var2 , exclusive . 
given integers var0 , var1 , var2 , integer array var3 . assign var3 [ var7 ] to var6 . if var6 is less than var2 abd exceeds var1 then increment var5 . 
given integers var0 , var1 , var2 , integer array var3 . return the number of elements in var3 which are in the range between var1 , var2 , exclusive . 
you are given integers var0 , var1 , var2 . assign var1 , var2 to var3 and places , respectively . create an array var5 of size 3 containing 1 at position var4 . take var3 modulo 6 . for all var6 $$CONSTANT$$ from var3 to var6 > = 1 , if var6 is odd number then exchange values of var5 [ 0 ] and var5 [ 1 ] . otherwise , exchange values of var5 [ 1 ] and var5 [ 2 ] . 
you are given integers var0 , var1 , var2 . assign var1 , var2 to var3 and places , respectively . create an array var5 of size 3 containing 1 at position var4 . take var3 modulo 6 . for all var6 $$CONSTANT$$ from var3 to var6 > = 1 , if var6 is odd number then exchange values of var5 [ 0 ] and var5 [ 1 ] . otherwise , exchange values of var5 [ 1 ] and var5 [ 2 ] . after the loop is ended , if var5 [ 0 ] does not equal 0 then return 0 . otherwise , if var5 [ 1 ] does not equal 0 then return 1 . otherwise , return 2 . 
you are given $$CONSTANT$$ string var0 . you have to set string var1 to " " . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to concatenate string " http : / / " to var1 , otherwise you have to concatenate string " ftp : / / " to var1 . you have to set var2 to zero . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to set var3 to 4 , otherwise you have to set var3 to 3 . while var3 is less than the length of var0 , if var0 [ var3 ] is equal to $$CONSTANT$$ and ( var3 + 1 ) is less than the length of var0 and var0 [ var3 + 1 ] is equal to 117 , you have to set var2 to var3 ; you have to add 1 to var3 . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to set var4 to 4 , otherwise you have to set var4 to 3 . while var4 is less than var2 you have to concatenate var0 [ var4 ] to var1 and add 1 to var4 . you have to concatenate " . ru " to var1 . if var4 + 2 is less than the length of var0 , you have to concatenate " / " to var1 ; for each position var5 greater than var4 + 1 in var0 you have to concatenate var0 [ var5 ] to var1 . 
you are given $$CONSTANT$$ string var0 . you have to set string var1 to " " . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to concatenate string " http : / / " to var1 , otherwise you have to concatenate string " ftp : / / " to var1 . you have to set var2 to zero . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to set var3 to 4 , otherwise you have to set var3 to 3 . while var3 is less than the length of var0 , if var0 [ var3 ] is equal to $$CONSTANT$$ and ( var3 + 1 ) is less than the length of var0 and var0 [ var3 + 1 ] is equal to 117 , you have to set var2 to var3 ; you have to add 1 to var3 . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to set var4 to 4 , otherwise you have to set var4 to 3 . while var4 is less than var2 you have to concatenate var0 [ var4 ] to var1 and add 1 to var4 . you have to concatenate " . ru " to var1 . 
you are given $$CONSTANT$$ string var0 . you have to set string var1 to " " . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to concatenate string " http : / / " to var1 , otherwise you have to concatenate string " ftp : / / " to var1 . you have to set var2 to zero . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to set var3 to 4 , otherwise you have to set var3 to 3 . while var3 is less than the length of var0 , if var0 [ var3 ] is equal to $$CONSTANT$$ and ( var3 + 1 ) is less than the length of var0 and var0 [ var3 + 1 ] is equal to 117 , you have to set var2 to var3 ; you have to add 1 to var3 . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to set var4 to 4 , otherwise you have to set var4 to 3 . while var4 is less than var2 you have to concatenate var0 [ var4 ] to var1 and add 1 to var4 . 
you are given $$CONSTANT$$ string var0 . you have to set string var1 to " " . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to concatenate string " http : / / " to var1 , otherwise you have to concatenate string " ftp : / / " to var1 . you have to set var2 to zero . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to set var3 to 4 , otherwise you have to set var3 to 3 . while var3 is less than the length of var0 , if var0 [ var3 ] is equal to $$CONSTANT$$ and ( var3 + 1 ) is less than the length of var0 and var0 [ var3 + 1 ] is equal to 117 , you have to set var2 to var3 ; you have to add 1 to var3 . 
you are given $$CONSTANT$$ string var0 . you have to set string var1 to " " . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to concatenate string " http : / / " to var1 , otherwise you have to concatenate string " ftp : / / " to var1 . you have to set var2 to zero . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to set var3 to 4 , otherwise you have to set var3 to 3 . while var3 is less than the length of var0 , if var0 [ var3 ] is equal to $$CONSTANT$$ and ( var3 + 1 ) is less than the length of var0 and var0 [ var3 + 1 ] is equal to 117 , you have to set var2 to var3 ; you have to add 1 to var3 . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to set var4 to 4 , otherwise you have to set var4 to 3 . while var4 is less than var2 you have to concatenate var0 [ var4 ] to var1 and add 1 to var4 . you have to concatenate " . ru " to var1 . if var4 + 2 is less than the length of var0 , you have to concatenate " / " to var1 ; for each position var5 greater than var4 + 1 in var0 you have to concatenate var0 [ var5 ] to var1 . you have to return var1 . 
given integers var0 , var1 . create array var2 containing three zeros . assign 1 to var2 [ var1 ] . take var0 modulo 6 . while var0 is larger than 0 , if var0 is even value then exchange values of var2 [ 2 ] and var2 [ 1 ] , or excange values of var2 [ 0 ] and var2 [ 1 ] in other case , then substract 1 from var0 . create integer array var6 of size 3 containing the positions of appearances of 1 in var2 . 
given integers var0 , var1 . create array var2 containing three zeros . assign 1 to var2 [ var1 ] . take var0 modulo 6 . while var0 is larger than 0 , if var0 is even value then exchange values of var2 [ 2 ] and var2 [ 1 ] , or excange values of var2 [ 0 ] and var2 [ 1 ] in other case , then substract 1 from var0 . return positions of appearances of 1 in var2 in increasing $$CONSTANT$$ . 
given integers var0 , var1 . create integer array var6 . create array var2 containing three zeros . assign 1 to var2 [ var1 ] . take var0 modulo 6 . while var0 is larger than 0 , if var0 is even value then exchange values of var2 [ 2 ] and var2 [ 1 ] , or excange values of var2 [ 0 ] and var2 [ 1 ] in other case , then substract 1 from var0 . 
given integers var0 , var1 . create integer array var6 . create array var2 containing three zeros . assign 1 to var2 [ var1 ] . take var0 modulo 6 . while var0 is larger than 0 , if var0 is even value then exchange values of var2 [ 2 ] and var2 [ 1 ] , or excange values of var2 [ 0 ] and var2 [ 1 ] in other case , then substract 1 from var0 . 
given integers var0 , var1 . if var0 is even value then exchange values of var2 [ 2 ] and var2 [ 1 ] , or excange values of var2 [ 0 ] and var2 [ 1 ] in other case , then substract 1 from var0 . 
you are given $$CONSTANT$$ string var0 . you have to set string var1 to " " . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to concatenate string " http : / / " to var1 , otherwise you have to concatenate string " ftp : / / " to var1 . you have to set var2 to zero . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to set var3 to 4 , otherwise you have to set var3 to 3 . while var3 is less than the length of var0 , if var0 [ var3 ] is equal to $$CONSTANT$$ and ( var3 + 1 ) is less than the length of var0 and var0 [ var3 + 1 ] is equal to 117 , you have to set var2 to var3 ; you have to add 1 to var3 . 
you are given $$CONSTANT$$ string var0 , $$CONSTANT$$ string var1 , an index var4 . you have to concatenate " / " to var1 . for each position var5 greater than var4 + 1 in var0 you have to concatenate var0 [ var5 ] to var1 . 
you are given $$CONSTANT$$ string var0 . you have to set string var1 to " " . if var0 [ 0 ] is equal to $$CONSTANT$$ you have to concatenate string " http : / / " to var1 , otherwise you have to concatenate string " ftp : / / " to var1 . 
given $$CONSTANT$$ string var1 , if var1 [ 0 ] = " $$CONSTANT$$ " , then set var3 to the position of the rightmost occurrence of " ru " in var1 , return $$CONSTANT$$ string , obtained by concatenation of " http : / / " , $$CONSTANT$$ of var1 from position 4 to position var3 - 1 ( both inclusive ) , " . ru / " and $$CONSTANT$$ of var1 from position var3 + 2 to the end of var1 , if var3 is less than length of var1 minus 2 , return $$CONSTANT$$ string , obtained by concatenation of " http : / / " , $$CONSTANT$$ $$CONSTANT$$ of var1 from position 4 to position var3 - 1 ( both inclusive ) and " . ru " , otherwise . otherwise , set var4 to the position of the rightmost occurrence of " ru " in var1 , return $$CONSTANT$$ string , obtained by concatenation of " ftp : / / " , $$CONSTANT$$ of var1 from position 3 to position var4 - 1 ( both inclusive ) , " . ru / " and $$CONSTANT$$ of var1 from position var4 + 2 to the end of var1 , if var4 is less than length of var1 minus 2 , return $$CONSTANT$$ string , obtained by concatenation of " ftp : / / " , $$CONSTANT$$ $$CONSTANT$$ of var1 from position 3 to position var4 - 1 ( both inclusive ) and " . ru " , otherwise . 
given integers var0 , var1 , var2 and var3 , initialize var4 to var0 , var5 to var1 , var6 to var2 , var7 to var3 , var8 to 0 , var9 to 0 . initialize var10 to 0 and for as long as var10 < var4 , add 1 to var8 , add var6 to var10 if var8 % var5 = 0 . set var10 to 0 and for as long as var10 < var4 , add 1 to var9 , add 2 * var6 to var10 if var9 % var5 = 0 and var9 > var7 , add var6 to var10 if var9 % var5 = 0 and var9 < = var7 . return " YES " if var9 < var8 , return " NO " otherwise . 
given array var0 of char type and matrix var1 of char type . let var3 be the number of subarrays in var1 which start at 0 - th and end at 3 - rd positions , and which are equal to var0 . let var4 be the number of ending subarrays in var1 which start at 5 - th positions and which are equal to var0 . 
given array var0 of char type and matrix var1 of char type . assign var1 [ var5 ] to var6 . if $$CONSTANT$$ of var6 starting at 0 and ending at 3 - rd position equals var0 then increase var3 by 1 . if the ending $$CONSTANT$$ of var6 starting at 5 - th position , equals var0 then increase var4 by 1 . 
given array var0 of char type and matrix var1 of char type . assign var1 [ var5 ] to var6 . if $$CONSTANT$$ of var6 starting at 0 and ending at 3 - rd position equals var0 then increase var3 by 1 . 
given strings var0 , var1 . initialize var3 to an array consisting of all strings in var0 splitted by $$CONSTANT$$ string " - > " . initialize var6 to the number of occurences of string var0 in var3 . 
given array var0 of char type and matrix var1 of char type . let var3 be the number of subarrays in var1 which start at 0 - th and end at 3 - rd positions , and which are equal to var0 . let var4 be the number of ending subarrays in var1 which start at 5 - th positions and which are equal to var0 . if var3 exceeds var4 then return " $$CONSTANT$$ " . otherwise , return " $$CONSTANT$$ " . 
given strings var0 , var1 . initialize var3 to an array consisting of all strings in var0 splitted by $$CONSTANT$$ string " - > " . 
given integer var0 . create $$CONSTANT$$ matrix var7 of char type . assign 0 , var2 to var6 , var4 , respectively . let var2 be the length of var1 . create $$CONSTANT$$ sorted set var3 of integer type . for all var5 $$CONSTANT$$ from 1 to var5 < = var2 do following operations . insert the next character in var1 into the set var3 . while var3 contains var4 do following operations . remove var4 from var3 . add var4 to the end of var7 . decrement var4 . 
given integer var0 . insert the next character in var1 into the set var3 . while var3 contains var4 do following operations . remove var4 from var3 . add var4 to the end of var7 . decrement var4 . 
given strings var0 , var1 . initialize var3 to an array consisting of all strings in var0 splitted by $$CONSTANT$$ string " - > " . initialize var6 to the number of occurences of string var0 in var3 . if var6 is even , return " $$CONSTANT$$ " ; else return " $$CONSTANT$$ " . 
given an array of integers var0 , initialize var8 to empty array of strings , var1 to length of var0 , var3 to array of $$CONSTANT$$ of length var1 , filled with false , and var5 to var1 - 1 . for each position var6 in var0 set var3 [ var0 [ var6 ] - 1 ] to true and var7 to var5 ; for as long as var7 > = 0 and var3 [ var7 ] is true , append var7 + 1 , converted to string , and " " to the end of var8 and decrease var7 by 1 ; set var5 to var7 . 
given an array of integers var0 , an array of $$CONSTANT$$ var3 , an array of strings var8 and integers var6 and var5 , set var3 [ var0 [ var6 ] - 1 ] to true and var7 to var5 ; for as long as var7 > = 0 and var3 [ var7 ] is true , append var7 + 1 , converted to string , and " " to the end of var8 and decrease var7 by 1 . set var5 to var7 . 
given an array of integers var0 , an array of $$CONSTANT$$ var3 , an array of strings var8 and integers var6 and var5 , set var3 [ var0 [ var6 ] - 1 ] to true and var7 to var5 ; for as long as var7 > = 0 and var3 [ var7 ] is true , append var7 + 1 , converted to string , and " " to the end of var8 and decrease var7 by 1 . 
given an array of integers var0 , initialize var8 to empty array of strings , var1 to length of var0 , var3 to array of $$CONSTANT$$ of length var1 , filled with false , and var5 to var1 - 1 . 
given an array of integers var0 , initialize var8 to empty array of strings , var1 to length of var0 , var3 to array of $$CONSTANT$$ of length var1 , filled with false , and var5 to var1 - 1 . 
given an array of integers var0 , initialize var8 to empty array of strings , var1 to length of var0 and var3 to array of $$CONSTANT$$ of length var1 , filled with false . 
given integer var0 . create $$CONSTANT$$ matrix var7 of char type . assign 0 , var2 to var6 , var4 , respectively . let var2 be the length of var1 . create $$CONSTANT$$ sorted set var3 of integer type . for all var5 $$CONSTANT$$ from 1 to var5 < = var2 do following operations . insert the next character in var1 into the set var3 . while var3 contains var4 do following operations . remove var4 from var3 . add var4 to the end of var7 . decrement var4 . after all loops are ended , return var7 . 
you are given $$CONSTANT$$ number var0 and an array of numbers var1 . you have to set var2 to the length of var1 . you have to create two associative containers var3 and var4 . for each var6 between 1 and var2 - 1 , if var4 contains the key var1 [ var6 ] you have to add 1 to the value of the key var1 [ var6 ] in var4 ; otherwise you have to add the key var1 [ var6 ] with value 1 in var4 . 
given an array of integers var0 , initialize var8 to empty array of strings , var1 to length of var0 , var3 to array of $$CONSTANT$$ of length var1 , filled with false , and var5 to var1 - 1 . for each position var6 in var0 set var3 [ var0 [ var6 ] - 1 ] to true and var7 to var5 ; for as long as var7 > = 0 and var3 [ var7 ] is true , append var7 + 1 , converted to string , and " " to the end of var8 and decrease var7 by 1 ; set var5 to var7 . return var8 . 
given integers var0 , var1 and integer typed array var2 . assign the length of var2 to var3 . assign var1 to var4 . create maps var5 , var6 both of types integer and integer . assing 0 to var7 . for all var8 $$CONSTANT$$ from 0 to n - 1 do following operations . if map var6 contains the key var2 [ var8 ] then add 1 to the value standing with this key in map . otherwise , insert the value 1 with key var2 [ var8 ] into var6 . insert value 0 with key var2 [ var8 ] into map var5 . when the current loop is ended , for all var9 $$CONSTANT$$ from 0 to n - 1 do following operations . substract 1 from the value with key var2 [ var9 ] in var6 . if var2 [ var9 ] is divisible by var4 and maps var5 and var6 contain keys var2 [ var9 ] / $$CONSTANT$$ and var2 [ var9 ] * $$CONSTANT$$ , respectively , then add to var7 the multiplication of values with these keys from var5 and var6 . add 1 to the value with key var2 [ var9 ] in the map var5 . 
given integers var0 , var1 and integer typed array var2 . substract 1 from the value with key var2 [ var9 ] in var6 . if var2 [ var9 ] is divisible by var4 and maps var5 and var6 contain keys var2 [ var9 ] / $$CONSTANT$$ and var2 [ var9 ] * $$CONSTANT$$ , respectively , then add to var7 the multiplication of values with these keys from var5 and var6 . add 1 to the value with key var2 [ var9 ] in the map var5 . 
given integers var0 , var1 and integer typed array var2 . substract 1 from the value with key var2 [ var9 ] in var6 . if var2 [ var9 ] is divisible by var4 and maps var5 and var6 contain keys var2 [ var9 ] / $$CONSTANT$$ and var2 [ var9 ] * $$CONSTANT$$ , respectively , then add to var7 the multiplication of values with these keys from var5 and var6 . 
given integers var0 , var1 and integer typed array var2 . assign the length of var2 to var3 . assign var1 to var4 . create maps var5 , var6 both of types integer and integer . assing 0 to var7 . for all var8 $$CONSTANT$$ from 0 to n - 1 do following operations . if map var6 contains the key var2 [ var8 ] then add 1 to the value standing with this key in map . otherwise , insert the value 1 with key var2 [ var8 ] into var6 . insert value 0 with key var2 [ var8 ] into map var5 . when the current loop is ended , for all var9 $$CONSTANT$$ from 0 to n - 1 do following operations . substract 1 from the value with key var2 [ var9 ] in var6 . if var2 [ var9 ] is divisible by var4 and maps var5 and var6 contain keys var2 [ var9 ] / $$CONSTANT$$ and var2 [ var9 ] * $$CONSTANT$$ , respectively , then add to var7 the multiplication of values with these keys from var5 and var6 . add 1 to the value with key var2 [ var9 ] in the map var5 . when the loop is ended , return var7 . 
given integers var0 , var1 and integer typed array var2 . assign the length of var2 to var3 . assign var1 to var4 . create maps var5 , var6 both of types integer and integer . assing 0 to var7 . for all var8 $$CONSTANT$$ from 0 to n - 1 do following operations . if map var6 contains the key var2 [ var8 ] then add 1 to the value standing with this key in map . otherwise , insert the value 1 with key var2 [ var8 ] into var6 . insert value 0 with key var2 [ var8 ] into map var5 . 
given integers var0 , var1 and integer typed array var2 . if map var6 contains the key var2 [ var8 ] then add 1 to the value standing with this key in map . otherwise , insert the value 1 with key var2 [ var8 ] into var6 . insert value 0 with key var2 [ var8 ] into map var5 . 
given an array of numbers var0 , initialize var6 and var3 to 0 . for each position var7 in var0 , if var0 [ var7 ] = 1 add one to var3 else add one to var6 . 
given an array of numbers var0 , store in var3 the amount of numbers in var0 equals to 1 and store in var6 the amount of numbers in var0 not equals to 1 . 
given integers var1 , var2 , var3 , var4 , var5 , var6 , var7 . initialize var8 to absolute value of ( var2 - var3 ) * var5 . if var2 is greater than var3 and var7 equals - 1 and if var6 is less than var2 , set var8 to the minimum between var8 and var6 * var4 + ( var1 - var3 ) * var4 + ( var1 * var4 ) ; else set var8 to to the minimum between var8 and ( var6 - var3 ) * var4 . 
you are given arrays var2 , var3 , var1 and integers var4 , var5 . let var7 be the size of var2 . initialize var10 to 0 . iterate from 0 to var7 - 1 . in each iteration , set var12 to var2 [ var4 ] and var13 to var3 [ var5 ] , increment var5 and var4 . let var14 be the sum of all elements in array var1 on range from var12 - 1 to var13 - 1 . if var14 is positive , add it to var10 . 
given char typed array var0 and matrix var1 . create char typed 3 - dimensional array var3 at any position var3 [ var4 ] [ 0 ] containing the $$CONSTANT$$ of var1 [ var4 ] with positions 0 , 3 , and at any position var3 [ var4 ] [ 1 ] containing the ending $$CONSTANT$$ of var1 [ var4 ] with starting position at 5 . create $$CONSTANT$$ boolean array var6 of size var2 . assign true to var7 . assign var0 to var8 . as long as var7 is true , do following operations . assign false to var7 . if there is such position that var6 [ var9 ] is false and var3 [ var9 ] [ 0 ] equals var8 then assign true to var6 [ var9 ] and to var7 , and assign var3 [ var9 ] [ 1 ] to var8 where var9 obtains values from 0 to n - 1 . eventually , if var8 equals var0 then return " $$CONSTANT$$ " . otherwise , return " $$CONSTANT$$ " . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , an array of numbers var3 . you have to set var5 to zero . for each position var6 in var3 you have to set var7 to var3 [ var6 ] - var1 - 1 ; if var7 is greater than or equal to zero and var7 is less than var2 - var1 - 1 you have to add 1 to var5 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , an array of numbers var3 , an index var8 . you have to set var7 to var3 [ var8 ] - var1 - 1 and add 1 to var8 . if var7 is greater than or equal to zero and var7 is less than var2 - var1 - 1 you have to add 1 to var5 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , an array of numbers var3 . you have to set var5 to zero . for each position var6 in var3 you have to set var7 to var3 [ var6 ] - var1 - 1 ; if var7 is greater than or equal to zero and var7 is less than var2 - var1 - 1 you have to add 1 to var5 . you have to return var5 . 
you are given an index var8 , an array of numbers var3 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var6 . you have to set var5 to var3 [ var8 ] and add 1 to var8 . if var5 is greater than var1 and var5 is less than var2 you have to add 1 to var6 . 
given integers var0 , var1 , var2 and 0 - based array var3 of integer type . let var5 be the number of elements in var3 which are less than var2 and exceed var1 . 
given integers var0 , var1 , var2 and 0 - based array var3 of integer type . if var3 [ var6 ] exceeds var1 and is less than var2 then increase var5 by 1 . 
given integers var0 , var1 , var2 and 0 - based array var3 of integer type . return the number of elements in var3 which are less than var2 and exceed var1 . 
given an array var0 of integer type ( 0 - based ) . initialize var0 to var2 . sort the array var2 . return the sum of values $$CONSTANT$$ $$CONSTANT$$ 1 + 1 - var2 [ var5 ] taken by module where var5 obtains values from 0 to n - 1 , both inclusive . 
given char typed array var1 and an integer var2 . assign to var3 the lowercase representation of var1 . assign var2 to var4 . in each case , when the integer value var3 [ var5 ] - 97 is not less than var4 , update var3 [ var5 ] by its lowercase value . otherwise , update it by uppercase value where var5 obtains values from 0 to length of var3 minus 1 . 
given an array var0 of integer type ( 0 - based ) . initialize var0 to var2 . sort the array var2 . let var3 be the sum of values $$CONSTANT$$ $$CONSTANT$$ 1 + 1 - var2 [ var5 ] taken by module where var5 obtains values from 0 to n - 1 , both inclusive . 
given an array var0 of integer type ( 0 - based ) . initialize var0 to var2 . sort the array var2 . 
given an array var0 of integer type ( 0 - based ) . initialize var0 to var2 . sort the array var2 . 
given an array var0 of integer type ( 0 - based ) . initialize var0 to var2 . 
given char typed array var1 and an integer var2 . assign to var3 the lowercase representation of var1 . assign var2 to var4 . in each case , when the integer value var3 [ var5 ] - 97 is not less than var4 , update var3 [ var5 ] by its lowercase value . otherwise , update it by uppercase value where var5 obtains values from 0 to length of var3 minus 1 . return the resultant var3 . 
you are given an array of numbers var1 . you have to create an array of numbers var3 and store in it the numbers 0 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 10 , 10 , 10 , 10 , 10 , 10 , in $$CONSTANT$$ . store in var5 the bitwise xor of the numbers var3 [ var1 [ var6 ] ] for each position var6 in var1 . 
you are given an array of numbers var1 ( indexing is 0 - based ) . you have to create an array of numbers var3 and store in it the numbers 0 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 10 , 10 , 10 , 10 , 10 , 10 , in $$CONSTANT$$ . store in var5 the bitwise xor of the numbers var3 [ var1 [ var6 ] ] for each position var6 in var1 . if var5 is equal to zero return " YES " , otherwise return " NO " . 
given arrays var0 , var1 . initialize var3 to the sum of elements of var0 , var4 to the sum of elements of var1 . 
given integer var0 . assign 2 and 1 to var1 and var2 , respectively . let var4 be the position of $$CONSTANT$$ value in 0 - based fibonacci sequence which exceeds var0 . 
given an integer var0 , initialize var1 to 1 , var2 to 2 and var3 to 1 . for as long as var1 + var2 < = var0 , add var1 to var2 , set var1 to var2 - var1 and increase var3 by 1 . 
given arrays var0 , var1 . initialize var3 to the sum of elements of var0 , var4 to the sum of elements of var1 , var2 to the length of var0 . return the value of the minimum between var3 and var2 - var3 + the minimum between var4 and var2 - var4 . 
given three integers var0 , var1 and var2 . initialize var4 to zero . if difference between maximum and minimum of var3 is bigger than one , increase var4 by that difference . if difference between maximum and second maximum is bigger than one , increase var4 by that difference minus one . 
given three integers var0 , var1 and var2 . initialize var4 to zero . if difference between maximum and minimum of var3 is bigger than one , increase var4 by that difference . if difference between maximum and second maximum is bigger than one , increase var4 by that difference minus one . return var4 . 
given three integers var0 , var1 and var2 . initialize var4 to zero . if difference between maximum and minimum of var3 is bigger than one , increase var4 by that difference . if difference between maximum and second maximum is bigger than one , increase var4 by that difference minus one . 
given three integers var0 , var1 and var2 . initialize var4 to zero . if difference between maximum and minimum of var3 is bigger than one , increase var4 by that difference minus one . 
given an integer var0 , initialize var1 to 1 , var2 to 2 and var3 to 1 . for as long as var1 + var2 < = var0 , add var1 to var2 , set var1 to var2 - var1 and increase var3 by 1 . return var3 . 
given integer var0 . assign 2 and 1 to var1 and var2 , respectively . return the position of $$CONSTANT$$ value in 0 - based fibonacci sequence which exceeds var0 . 
given an array var0 . initialize var6 to an empty array , var3 to $$CONSTANT$$ boolean array , var4 to the length of var0 . for each var5 from 0 to the length of var0 exclusive , perform the following operations . set var3 [ var0 [ var5 ] ] to true . while var4 is greater than 0 and var3 [ var4 ] is true , push var4 into var6 and decrease var4 by 1 . 
given arrays var0 , var3 , var6 and integers var5 , var4 . set var3 [ var0 [ var5 ] ] to true . while var4 is greater than 0 and var3 [ var4 ] is true , push var4 into var6 and decrease var4 by 1 . 
you are given arrays var2 , var3 , var1 and integers var4 , var5 . let var7 be the size of var2 . initialize var10 to 0 . iterate from 0 to var7 - 1 . in each iteration , set var12 to var2 [ var4 ] and var13 to var3 [ var5 ] , increment var5 and var4 . let var14 be the sum of all elements in array var1 on range from var12 - 1 to var13 - 1 . if var14 is positive , add it to var10 . ( end of loop ) return var10 . 
given char typed array var0 . create char typed array var1 . if var0 [ 0 ] equals $$CONSTANT$$ then assign " http : / / " to var1 and delete elements of var0 standing at positions from 0 to 3 , inclusive . otherwise , assign " ftp : / / " to var1 and delete elements of var0 standing at positions from 0 to 2 , inclusive . for all var2 $$CONSTANT$$ from 1 to length of var0 minus 2 , inclusive , if the $$CONSTANT$$ of var0 with positions range from var2 to $$CONSTANT$$ + 2 , inclusive , equals " ru " then do following operations . add to the end of var1 the $$CONSTANT$$ of var0 with positions range from 0 to var2 , inclusive and add the character " . ru " to the end of var1 . if var2 does nor equal the length of var0 minus 2 then " . ru " add the character " / " to the end of var1 and add to the end of var1 , the ending $$CONSTANT$$ of var0 with starting position at $$CONSTANT$$ + 2 and exit from the loop . when the loop is ended , return var1 . 
given an array var0 . initialize var6 to an empty array , var3 to $$CONSTANT$$ boolean array , var4 to the length of var0 . for each var5 from 0 to the length of var0 exclusive , perform the following operations . set var3 [ var0 [ var5 ] ] to true . while var4 is greater than 0 and var3 [ var4 ] is true , push var4 into var6 and decrease var4 by 1 . return var6 . 
you are given $$CONSTANT$$ string var0 and $$CONSTANT$$ number var1 . you have to store in var2 the decimal value of the number represented in var0 modulo var1 . you have to store in var4 the least power of 10 greater than the number represented in var0 modulo var1 . you have to set var3 to var2 . for each position var9 in var0 except the last you have to , store in var11 the decimal digit in var0 [ var9 ] , multiplicate var2 by 10 , subtract var4 * var11 to var2 , add var11 to var2 , set var2 to var2 modulo var1 , set var2 to var2 + var1 modulo var1 , if var0 [ var9 + 1 ] is different to 48 store in var3 the minimum between var3 and var2 . 
you are given $$CONSTANT$$ string var0 and $$CONSTANT$$ number var1 , an index var9 , $$CONSTANT$$ number var4 . you have to store in var11 the decimal digit in var0 [ var9 ] . you have to , multiplicate var2 by 10 , subtract var4 * var11 to var2 , add var11 to var2 , set var2 to var2 modulo var1 , set var2 to var2 + var1 modulo var1 . if var0 [ var9 + 1 ] is different to 48 you have to store in var3 the minimum between var3 and var2 . 
you are given $$CONSTANT$$ string var0 and $$CONSTANT$$ number var1 . you have to store in var2 the decimal value of the number represented in var0 modulo var1 . you have to set var3 to var2 . 
you are given $$CONSTANT$$ string var0 and $$CONSTANT$$ number var1 . you have to store in var2 the decimal value of the number represented in var0 modulo var1 . you have to set var3 to var2 . 
you are given $$CONSTANT$$ string var0 and $$CONSTANT$$ number var1 . you have to store in var2 the decimal value of the number represented in var0 modulo var1 . 
you are given $$CONSTANT$$ string var0 and $$CONSTANT$$ number var1 . you have to store in var2 the decimal value of the number represented in var0 modulo var1 . you have to store in var4 the least power of 10 greater than the number represented in var0 modulo var1 . you have to set var3 to var2 . for each position var9 in var0 except the last you have to , store in var11 the decimal digit in var0 [ var9 ] , multiplicate var2 by 10 , subtract var4 * var11 to var2 , add var11 to var2 , set var2 to var2 modulo var1 , set var2 to var2 + var1 modulo var1 , if var0 [ var9 + 1 ] is different to 48 store in var3 the minimum between var3 and var2 . you have to return var3 . 
given char typed array var0 . create char typed array var1 . if var0 [ 0 ] equals $$CONSTANT$$ then assign " http : / / " to var1 and delete elements of var0 standing at positions from 0 to 3 , inclusive . otherwise , assign " ftp : / / " to var1 and delete elements of var0 standing at positions from 0 to 2 , inclusive . for all var2 $$CONSTANT$$ from 1 to length of var0 minus 2 , inclusive , if the $$CONSTANT$$ of var0 with positions range from var2 to $$CONSTANT$$ + 2 , inclusive , equals " ru " then do following operations . add to the end of var1 the $$CONSTANT$$ of var0 with positions range from 0 to var2 , inclusive and add the character " . ru " to the end of var1 . if var2 does nor equal the length of var0 minus 2 then " . ru " add the character " / " to the end of var1 and add to the end of var1 , the ending $$CONSTANT$$ of var0 with starting position at $$CONSTANT$$ + 2 and exit from the loop . 
given char typed array var0 . add to the end of var1 the $$CONSTANT$$ of var0 with positions range from 0 to var2 , inclusive and add the character " . ru " to the end of var1 . if var2 does nor equal the length of var0 minus 2 then " . ru " add the character " / " to the end of var1 and add to the end of var1 , the ending $$CONSTANT$$ of var0 with starting position at $$CONSTANT$$ + 2 and exit from the loop . 
given char typed array var0 . create char typed array var1 . if var0 [ 0 ] equals $$CONSTANT$$ then assign " http : / / " to var1 and delete elements of var0 standing at positions from 0 to 3 , inclusive . otherwise , assign " ftp : / / " to var1 and delete elements of var0 standing at positions from 0 to 2 , inclusive . 
given char typed array var0 . create char typed array var1 . if var0 [ 0 ] equals $$CONSTANT$$ then assign " http : / / " to var1 and delete elements of var0 standing at positions from 0 to 3 , inclusive . otherwise , assign " ftp : / / " to var1 and delete elements of var0 standing at positions from 0 to 2 , inclusive . 
you are given an array of strings var1 , $$CONSTANT$$ string var0 . you have to store in var3 the number of strings in var1 with var0 as $$CONSTANT$$ prefix , minus , the number of strings in var1 without var0 as $$CONSTANT$$ prefix . 
you are given an array of strings var1 , $$CONSTANT$$ string var0 , an index var6 , $$CONSTANT$$ number var3 . if the $$CONSTANT$$ of var1 [ var6 ] starting at position 0 and ending at position 2 is equal to var0 , you have to add 1 to var3 ; otherwise you have to subtract 1 to var3 . you have to add 1 to var6 . 
you are given an array of strings var1 , $$CONSTANT$$ string var0 . you have to store in var3 the number of strings in var1 with var0 as $$CONSTANT$$ prefix , minus , the number of strings in var1 without var0 as $$CONSTANT$$ prefix . if var3 is equal to zero return " $$CONSTANT$$ " , otherwise return " $$CONSTANT$$ " . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 ( indexing is 0 - based ) and an array of numbers var4 ( indexing is 0 - based ) . you have to set var8 to zero and var6 to the length of var2 . for each var5 between 1 and var6 you have to set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . input [ var5 ] to var2 [ var5 - 1 ] . for each var5 between 1 and var6 you have to set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var5 ] to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var5 - 1 ] plus $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . input [ var5 ] . for each var5 in var3 you have to set var9 to var3 [ var5 ] and var10 to var4 [ var5 ] , you have to set var11 to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var10 ] - $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var9 - 1 ] , and if var11 is greater than zero you have to add var11 to var8 . you have to return var8 . 
set var10 to an empty string . set var9 to 0 . the boolean var1 is false . var4 is equal to $$CONSTANT$$ . var5 is the length of the given array var0 . make $$CONSTANT$$ new set var6 . make an array var7 of length var5 . set max equal to var5 . set var2 equal to 0 . while x is smaller than var5 , place var0 [ var9 ] in the set var6 . increment var9 by 1 . while var6 contains var8 . add var8 to the string var10 seperated by " " . decrease var8 by 1 . 
given $$CONSTANT$$ set var6 , an array var0 and integers var9 and var8 . place var0 [ var9 ] in the set var6 . while var6 contains var8 . add var8 to the string var10 seperated by " " . decrease var8 by 1 . 
given $$CONSTANT$$ string array var1 and string var0 . set var3 to zero . check every element of var1 , and increment var3 if current element contains var0 as $$CONSTANT$$ $$CONSTANT$$ . 
given $$CONSTANT$$ string array var1 and index var7 into it . increment var3 , if var1 [ var7 ] contains given var0 as $$CONSTANT$$ $$CONSTANT$$ . 
you are given arrays var0 , var1 of integer types . let var3 and var4 be the sum of elements in var0 and var1 , respectively . 
set var10 to an empty string . set var9 to 0 . the boolean var1 is false . var4 is equal to $$CONSTANT$$ . var5 is the length of the given array var0 . make $$CONSTANT$$ new set var6 . make an array var7 of length var5 . set max equal to var5 . set var2 equal to 0 . while x is smaller than var5 , place var0 [ var9 ] in the set var6 . increment var9 by 1 . while var6 contains var8 . add var8 to the string var10 seperated by " " . decrease var8 by 1 . return the string var10 . 
you are given arrays var0 , var1 of integer types . let var3 and var4 be the sum of elements in var0 and var1 , respectively . let var2 be the length of var0 . update var5 by the minimum of var3 and n - $$CONSTANT$$ . increment var5 by the minimum of var4 and n - $$CONSTANT$$ . return var5 . 
you are given $$CONSTANT$$ string var1 , an array of strings var2 . you have to set var6 to zero . for each position var7 in var2 you have to split var2 [ var7 ] by " - > " and store resultant strings in array of strings var9 , set var10 to var9 [ 0 ] and var11 to var9 [ 1 ] , if var10 is equal to var1 you have to add 1 to var6 , otherwise if var11 is equal to var1 you have to subtract 1 to var6 . 
given $$CONSTANT$$ string array var1 and string var0 . set var3 to zero . check every element of var1 , and increment var3 if current element contains var0 as $$CONSTANT$$ $$CONSTANT$$ . return " $$CONSTANT$$ " if var3 is even , otherwise return " $$CONSTANT$$ " . 
given integers var0 and var1 . assign the values var1 , 1 , 2 to var2 , var3 and var4 , respectively . assign 1 to var5 . as long as var4 does not exceed var2 , do following operations . increase var3 by 1 . assign cur + prev to var6 . assign var4 to var5 . assign var6 to var4 . when var4 becomes larger than var2 , return ans - 1 . 
you are given $$CONSTANT$$ string var1 , an array of strings var2 . you have to set var6 to zero . for each position var7 in var2 you have to split var2 [ var7 ] by " - > " and store resultant strings in array of strings var9 , set var10 to var9 [ 0 ] and var11 to var9 [ 1 ] , if var10 is equal to var1 you have to add 1 to var6 , otherwise if var11 is equal to var1 you have to subtract 1 to var6 . if var6 is equal to zero you have to return " $$CONSTANT$$ " , otherwise return " $$CONSTANT$$ " . 
given integers var0 , var1 , var3 , var2 . if var3 - th bit of var0 equals to var3 - th bit of var1 , set var2 to var3 and break the loop . 
given integers var0 , var1 . set var0 to var0 modulo 6 . for each var2 from var0 to 1 , perform the following operations . if var2 is even and var1 equals 1 or var1 equals 2 , set var1 to 3 - var1 ; else if var2 is odd and var1 equals 0 or var1 equals 1 , set var1 to 1 - var1 . 
given integers var0 , var1 . set var0 to var0 modulo 6 . for each var2 from var0 to 1 , perform the following operations . if var2 is even and var1 equals 1 or var1 equals 2 , set var1 to 3 - var1 ; else if var2 is odd and var1 equals 0 or var1 equals 1 , set var1 to 1 - var1 . return var1 . 
given an integer var0 , integer var2 , char array var1 . length of var1 is equal to var0 div 2 . for var2 in range from 0 to var0 div 2 - 1 : assign var1 [ var2 ] to $$CONSTANT$$ . if var0 is odd assign var1 [ 0 ] to $$CONSTANT$$ . 
given integers var0 , var1 , var2 and 0 - based array var3 of integer type . assign to var5 the number of elements in var3 which are larger than var1 and less than var2 . 
given integers var0 , var1 , var2 and 0 - based array var3 of integer type . return the number of elements in var3 which are larger than var1 and less than var2 . 
given integer array var0 . assign var0 to var2 . sort var2 . let var4 be the sum of all modules var2 [ $$CONSTANT$$ - 1 ] - $$CONSTANT$$ . 
given integer array var0 . assign var0 to var2 . sort var2 . 
given integer array var0 . assign var0 to var2 . 
given integer array var0 . sort var0 . let var4 be the sum of all modules ( ( var2 [ var5 ] - var5 ) - 1 ) where var5 is the position of current element of var2 . 
given integer array var0 . assign var0 to var2 . sort var2 . 
given integer array var0 . assign var0 to var2 . 
given integer array var0 . assign var0 to var2 . sort var2 . return the sum of all modules var2 [ $$CONSTANT$$ - 1 ] - $$CONSTANT$$ . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 ( indexing is 0 - based ) , $$CONSTANT$$ number var1 . set var6 to var1 . you have to create an array of numbers var8 of the length the length of var2 . store in var7 the sum of the elements in var3 . store in var8 [ var10 ] the difference var2 [ var10 ] - var3 [ var10 ] , for each position var10 in var2 . you have to sort var8 . 
given integer array var0 . sort var0 . return the sum of all modules ( ( var2 [ var5 ] - var5 ) - 1 ) where var5 is the position of current element of var2 . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 ( indexing is 0 - based ) , $$CONSTANT$$ number var1 . set var6 to var1 . you have to create an array of numbers var8 of the length the length of var2 . store in var7 the sum of the elements in var3 . store in var8 [ var10 ] the difference var2 [ var10 ] - var3 [ var10 ] , for each position var10 in var2 . 
given integer arrays var2 , var3 and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . flower . initialize var15 , var14 , var13 to 0 , var5 to length of var2 and var6 to length of var3 . for each var7 from 0 to var6 - 1 , initialize var11 to the sum of elements of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . flower with indices from var3 [ var7 ] - 1 to var4 [ var7 ] - 1 inclusive . if var11 is greater than 0 , add var11 to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . $$CONSTANT$$ . return the value of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . $$CONSTANT$$ . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 ( indexing is 0 - based ) , $$CONSTANT$$ number var1 . you have to create an array of numbers var8 of the length the length of var2 . store in var7 the sum of the elements in var3 . store in var8 [ var10 ] the difference var2 [ var10 ] - var3 [ var10 ] , for each position var10 in var2 . you have to sort var8 . set var12 to zero . for each position var13 in var8 , if var8 [ var13 ] is greater than zero and var13 is greater than or equal to var1 , you have to break from the enclosing loop , you have to add var8 [ var13 ] to var12 . you have to return var7 + var12 . 
you are given an index var13 , $$CONSTANT$$ number var6 , an array of numbers var8 , $$CONSTANT$$ number var12 . if var8 [ var13 ] is greater than zero and var13 is greater than or equal to var6 , you have to break from the enclosing loop . you have to add var8 [ var13 ] to var12 . 
you are given an array of numbers var2 , $$CONSTANT$$ number var1 . set var5 to the length of var2 , set var6 to var1 . you have to create an array of numbers var8 of length var5 . 
you are given integers var0 and var1 . assign var2 to remainder of var0 divided by 3 . assign var0 to var0 divided by 3 rounded down . if var0 is odd number assign var1 to remainder of ( var1 + 2 ) divided by 4 . if var1 is equal to zero and var2 is equal to 1 or 2 update var1 to 1 else if var1 and var2 are equal to 2 update var1 to 0 . 
you are given integers var0 and var1 . assign var2 to remainder of var0 divided by 3 . assign var0 to var0 divided by 3 rounded down . if var0 is odd number assign var1 to remainder of ( var1 + 2 ) divided by 4 . 
given integers var0 , var1 . assign the value var0 % 6 to var0 . for all var2 $$CONSTANT$$ from var0 to var2 > = 1 do following operations . if var0 % 2 equals 0 then if var1 equals 1 then assign 2 to var1 . otherwise , if var1 equals 2 then assign 1 to var1 . if var0 % 2 was not equal 0 then if var1 equals 0 then assign 1 to var1 . otherwise , if var1 equals 1 then assign 0 to var1 . after this , decrement var0 . 
given integers var0 , var1 . assign the value var0 % 6 to var0 . for all var2 $$CONSTANT$$ from var0 to var2 > = 1 do following operations . if var0 % 2 equals 0 then if var1 equals 1 then assign 2 to var1 . otherwise , if var1 equals 2 then assign 1 to var1 . if var0 % 2 was not equal 0 then if var1 equals 0 then assign 1 to var1 . otherwise , if var1 equals 1 then assign 0 to var1 . after this , decrement var0 . after the loop is ended , return var1 . 
given integers var0 , var1 . if var0 % 2 equals 0 then if var1 equals 1 then assign 2 to var1 . otherwise , if var1 equals 2 then assign 1 to var1 . if var0 % 2 was not equal 0 then if var1 equals 0 then assign 1 to var1 . otherwise , if var1 equals 1 then assign 0 to var1 . after this , decrement var0 . 
you are given an array var0 of integer type . create $$CONSTANT$$ matrix var5 of char type . let var1 be the length of var0 . create $$CONSTANT$$ sorted set var2 of integer type . assign var1 to var3 . for all var4 $$CONSTANT$$ from 0 to var4 < var1 , do following operations . insert var0 [ var4 ] into var2 . while var2 is not empty , do followign operations . if var2 contains var3 then add the string representation of var3 to the end of var5 . decrement var3 . when var2 becomes empty , exit from current loop . add an empty $$CONSTANT$$ to the end of var5 . 
you are given an array var0 of integer type . insert var0 [ var4 ] into var2 . while var2 is not empty , do followign operations . if var2 contains var3 then add the string representation of var3 to the end of var5 . decrement var3 . when var2 becomes empty , exit from current loop . add an empty $$CONSTANT$$ to the end of var5 . 
you are given an array var0 of integer type . insert var0 [ var4 ] into var2 . while var2 is not empty , do followign operations . if var2 contains var3 then add the string representation of var3 to the end of var5 . decrement var3 . 
you are given $$CONSTANT$$ number var0 . you have to return false if var0 has $$CONSTANT$$ divisor greater than 2 . 
given an integer var0 , return false if var0 is composite number . 
you are given an array of numbers var2 , $$CONSTANT$$ number var1 . set var5 to the length of var2 , set var6 to var1 . you have to create an array of numbers var8 of length var5 . 
you are given an array var0 of integer type . create $$CONSTANT$$ matrix var5 of char type . let var1 be the length of var0 . create $$CONSTANT$$ sorted set var2 of integer type . assign var1 to var3 . for all var4 $$CONSTANT$$ from 0 to var4 < var1 , do following operations . insert var0 [ var4 ] into var2 . while var2 is not empty , do followign operations . if var2 contains var3 then add the string representation of var3 to the end of var5 . decrement var3 . when var2 becomes empty , exit from current loop . add an empty $$CONSTANT$$ to the end of var5 . when var4 becomes equal to var1 , return var5 . 
given an integer var0 , return whether var0 is prime number . 
given char typed array var0 and matrix var1 . create char typed 3 - dimensional array var3 at any position var3 [ var4 ] [ 0 ] containing the $$CONSTANT$$ of var1 [ var4 ] with positions 0 , 3 , and at any position var3 [ var4 ] [ 1 ] containing the ending $$CONSTANT$$ of var1 [ var4 ] with starting position at 5 . create $$CONSTANT$$ boolean array var6 of size var2 . assign true to var7 . assign var0 to var8 . as long as var7 is true , do following operations . assign false to var7 . if there is such position that var6 [ var9 ] is false and var3 [ var9 ] [ 0 ] equals var8 then assign true to var6 [ var9 ] and to var7 , and assign var3 [ var9 ] [ 1 ] to var8 where var9 obtains values from 0 to n - 1 . 
given char typed array var0 and matrix var1 . assign false to var7 . if there is such position that var6 [ var9 ] is false and var3 [ var9 ] [ 0 ] equals var8 then assign true to var6 [ var9 ] and to var7 , and assign var3 [ var9 ] [ 1 ] to var8 where var9 obtains values from 0 to n - 1 . 
given char typed array var0 and matrix var1 . create char typed 3 - dimensional array var3 at any position var3 [ var4 ] [ 0 ] containing the $$CONSTANT$$ of var1 [ var4 ] with positions 0 , 3 , and at any position var3 [ var4 ] [ 1 ] containing the ending $$CONSTANT$$ of var1 [ var4 ] with starting position at 5 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to set the string var2 to " " . you have to create an array of numbers var3 . you have to iterate var4 from 1 and while var4 * var4 is less than or equal to var0 . inside the loop , if var0 is divisible by var4 you have to insert var4 in var3 and insert var0 divided by var4 in var3 if var4 * var4 is different from var0 . after the loop ends you have to sort var3 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to set the string var2 to " " . you have to create an array of numbers var3 . you have to iterate var4 from 1 and while var4 * var4 is less than or equal to var0 . inside the loop , if var0 is divisible by var4 you have to insert var4 in var3 and insert var0 divided by var4 in var3 if var4 * var4 is different from var0 . 
you are given an array of numbers var3 , $$CONSTANT$$ number var0 and an index var4 . you have to insert var4 in var3 . if var4 * var4 is different from var0 you have to insert var0 divided by var4 in var3 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to store in array var3 ( indexing is 0 - based ) all the divisors of var0 sorted from lowest to highest . if length of var3 is less than var1 you have to return - 1 , otherwise you have to return var3 [ var1 - 1 ] . 
given an array var0 . initialize var3 to var0 , var2 to 0 . sort elements of var3 in increasing $$CONSTANT$$ . for each var5 from 0 to the length of var0 exclusive , add the absolute value of var3 [ var5 ] - var5 - 1 to var2 . 
given an array var0 . initialize var3 to var0 . sort elements of var3 in increasing $$CONSTANT$$ . 
given an array var0 . initialize var3 to var0 . sort elements of var3 in increasing $$CONSTANT$$ . 
given an array var0 . initialize var3 to var0 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of numbers var2 and store in it all elements into var0 . you have to sort var2 . you have to store in var4 the sum of the absolute value of var5 + 1 - var2 [ var5 ] , for each position var5 in var2 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of numbers var2 and store in it all elements into var0 . you have to sort var2 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of numbers var2 and store in it all elements into var0 . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 . sort var2 in non - decreasing $$CONSTANT$$ . find the sum of absolute values of var2 [ var5 ] - var5 - 1 over all positions var5 in var2 and store the result in var3 . 
given an array var0 . initialize var3 to var0 , var2 to 0 . sort elements of var3 in increasing $$CONSTANT$$ . for each var5 from 0 to the length of var0 exclusive , add the absolute value of var3 [ var5 ] - var5 - 1 to var2 . return var2 . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and initialize var3 to 0 . sort var2 in non - decreasing $$CONSTANT$$ . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and initialize var3 to 0 . sort var2 in non - decreasing $$CONSTANT$$ . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and initialize var3 to 0 . 
you are given integer arrays var1 , var2 . let var6 be the size of var1 and var7 the size of var2 . create $$CONSTANT$$ zero - initialized array var8 of size var6 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of numbers var2 and store in it all elements into var0 . you have to sort var2 . you have to return the sum of the absolute value of var5 + 1 - var2 [ var5 ] , for each position var5 in var2 . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 . sort var2 in non - decreasing $$CONSTANT$$ . return the sum of absolute values of var2 [ var5 ] - var5 - 1 over all positions var5 in var2 . 
given 0 - based arrays var0 , var1 , var2 of integer types . create integer typed array var6 of size n + 1 containing 0 at first position and at any other var5 th position containing the sum of elements in beginning subarray of var0 ending at $$CONSTANT$$ - 1 . assign 0 to var9 . for all var5 $$CONSTANT$$ from 0 to $$CONSTANT$$ - 1 , if the value var6 [ var1 [ var5 ] ] - var6 [ ( var2 [ var5 ] - 1 ) ] is larger than 0 then add it to var9 . 
given 0 - based arrays var0 , var1 , var2 of integer types . create integer typed array var6 of size n + 1 containing 0 at first position and at any other var5 th position containing the sum of elements in beginning subarray of var0 ending at $$CONSTANT$$ - 1 . 
given 0 - based arrays var0 , var1 , var2 of integer types . assign var1 [ var5 ] and var2 [ var5 ] to var11 and var12 , respectively . if the value var6 [ var12 ] - var6 [ ( var11 - 1 ) ] is larger than 0 then add it to var9 . 
given 0 - based arrays var0 , var1 , var2 of integer types . create integer typed array var6 of size n + 1 containing 0 at first position and at any other var5 th position containing the sum of elements in beginning subarray of var0 ending at $$CONSTANT$$ - 1 . assign 0 to var9 . for all var5 $$CONSTANT$$ from 0 to $$CONSTANT$$ - 1 , if the value var6 [ var1 [ var5 ] ] - var6 [ ( var2 [ var5 ] - 1 ) ] is larger than 0 then add it to var9 . return var9 . 
given arrays of integers var0 , var1 and var2 , initialize var5 to length of var0 , var7 to array of integers of length var5 + 1 . for each integer var8 from 0 to var5 - 1 set var7 [ var8 + 1 ] to var7 [ var8 ] + var0 [ var8 ] . initialize var11 to 0 . for each position var12 in var1 add var7 [ var2 [ var12 ] ] - var7 [ var1 [ var12 ] - 1 ] to var11 if var7 [ var2 [ var12 ] ] - var7 [ var1 [ var12 ] - 1 ] > 0 . 
given an array of integers var0 , initialize var1 to length of var0 . if var1 = 1 , then return " DOWN " if var0 [ 0 ] = 15 , return " UP " if var0 [ 0 ] = 0 , return " - 1 " otherwise . otherwise , if var0 [ var1 - 1 ] = 0 and var0 [ var1 - 2 ] = 1 , then return " UP " , otherwise , if var0 [ var1 - 1 ] = 15 and var0 [ var1 - 2 ] = $$CONSTANT$$ , then return " DOWN " , otherwise , if var0 [ var1 - 1 ] > var0 [ var1 - 2 ] , then return " UP " , otherwise return " DOWN " . 
given $$CONSTANT$$ string var0 . initialize var3 to the length of var0 , var4 to $$CONSTANT$$ two - dimensional array consisting of var3 rows and var3 columns . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] [ var5 ] to 1 . for each var6 from 0 to var3 - 1 exclusive , if var0 [ var6 ] equals to var0 [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] , set var4 [ var6 ] [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] to 1 . for each var7 from 3 to var3 and var8 from 0 to var3 - var7 , perform the following operations . initialize var9 to var8 + var7 - 1 . if var4 [ $$CONSTANT$$ $$CONSTANT$$ 2 + 1 ] [ $$CONSTANT$$ - 1 ] equals 1 and var0 [ var8 ] equals var0 [ var9 ] , set var4 [ var8 ] [ var9 ] to 1 . initialize var10 , var11 to arrays of length var3 . set var10 [ 0 ] to 1 . for each var12 from 1 to var3 exclusive , perform the following operations . set var11 [ var12 ] to var11 [ $$CONSTANT$$ $$CONSTANT$$ 3 - 1 ] , var10 [ var12 ] to var10 [ $$CONSTANT$$ $$CONSTANT$$ 3 - 1 ] . for each var13 from 1 to var12 , add var4 [ var13 ] [ var12 ] * var10 [ $$CONSTANT$$ $$CONSTANT$$ 1 - 1 ] to var11 [ var12 ] and add var4 [ var13 ] [ var12 ] to var10 [ var12 ] . add var4 [ 0 ] [ var12 ] to var10 [ var12 ] . 
given arrays of integers var0 , var1 and var2 , initialize var5 to length of var0 , var7 to array of integers of length var5 + 1 . for each integer var8 from 0 to var5 - 1 set var7 [ var8 + 1 ] to var7 [ var8 ] + var0 [ var8 ] . initialize var11 to 0 . for each position var12 in var1 add var7 [ var2 [ var12 ] ] - var7 [ var1 [ var12 ] - 1 ] to var11 if var7 [ var2 [ var12 ] ] - var7 [ var1 [ var12 ] - 1 ] > 0 . return var11 . 
given an integer var0 and an array var1 . initialize var2 to the length of var1 , var4 to $$CONSTANT$$ map where element with key x stores the number of elements x in var1 . initialize var7 to 0 . for each var8 from 0 to var2 exclusive , perform the following operations . put pair ( var1 [ var8 ] , var4 [ var1 [ var8 ] ] ) into var4 . if var1 [ var8 ] modulo var0 equals 0 and var8 not equals 0 and var8 not equals var2 - 1 and var3 contains var1 [ var8 ] / var0 and $$CONSTANT$$ contains var1 [ var8 ] * var0 , set var9 to var3 [ var1 [ var8 ] / var0 ] , var10 to var4 [ var1 [ var8 ] * var0 ] , add var9 * var10 to var7 . if var3 contains var1 [ var8 ] , increase value of element with this key by 1 ; else put ( var1 [ var8 ] , 1 ) into var3 . 
given an array var1 , $$CONSTANT$$ map var4 and integers var0 , var8 , var7 . put pair ( var1 [ var8 ] , var4 [ var1 [ var8 ] ] ) into var4 . if var1 [ var8 ] modulo var0 equals 0 and var8 not equals 0 and var8 not equals var2 - 1 and var3 contains var1 [ var8 ] / var0 and $$CONSTANT$$ contains var1 [ var8 ] * var0 , set var9 to var3 [ var1 [ var8 ] / var0 ] , var10 to var4 [ var1 [ var8 ] * var0 ] , add var9 * var10 to var7 . if var3 contains var1 [ var8 ] , increase value of element with this key by 1 ; else put ( var1 [ var8 ] , 1 ) into var3 . 
given an array var1 , $$CONSTANT$$ map var4 and integers var0 , var8 , var7 . put pair ( var1 [ var8 ] , var4 [ var1 [ var8 ] ] ) into var4 . if var1 [ var8 ] modulo var0 equals 0 and var8 not equals 0 and var8 not equals var2 - 1 and var3 contains var1 [ var8 ] / var0 and $$CONSTANT$$ contains var1 [ var8 ] * var0 , set var9 to var3 [ var1 [ var8 ] / var0 ] , var10 to var4 [ var1 [ var8 ] * var0 ] , add var9 * var10 to var7 . 
given integers var2 , var3 and an array var4 . return the number of integers var6 in var4 such that var6 is greater than var2 and var6 is less than var3 . 
given an array var4 and integers var9 , var2 , var3 , var8 . initialize var6 to var4 [ var9 ] . if var2 is less than var6 and var6 is less than var3 , increase var8 by 1 . 
given integers var2 , var3 and an array var4 . return the number of integers var6 in var4 such that var6 is greater than var2 and var6 is less than var3 . 
given an integer var0 and an array var1 . initialize var2 to the length of var1 , var4 to $$CONSTANT$$ map where element with key x stores the number of elements x in var1 . initialize var7 to 0 . for each var8 from 0 to var2 exclusive , perform the following operations . put pair ( var1 [ var8 ] , var4 [ var1 [ var8 ] ] ) into var4 . if var1 [ var8 ] modulo var0 equals 0 and var8 not equals 0 and var8 not equals var2 - 1 and var3 contains var1 [ var8 ] / var0 and $$CONSTANT$$ contains var1 [ var8 ] * var0 , set var9 to var3 [ var1 [ var8 ] / var0 ] , var10 to var4 [ var1 [ var8 ] * var0 ] , add var9 * var10 to var7 . if var3 contains var1 [ var8 ] , increase value of element with this key by 1 ; else put ( var1 [ var8 ] , 1 ) into var3 . return var7 . 
given $$CONSTANT$$ string var0 . initialize var3 to the length of var0 , var4 to $$CONSTANT$$ two - dimensional array consisting of var3 rows and var3 columns . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] [ var5 ] to 1 . for each var6 from 0 to var3 - 1 exclusive , if var0 [ var6 ] equals to var0 [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] , set var4 [ var6 ] [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] to 1 . for each var7 from 3 to var3 and var8 from 0 to var3 - var7 , perform the following operations . initialize var9 to var8 + var7 - 1 . if var4 [ $$CONSTANT$$ $$CONSTANT$$ 2 + 1 ] [ $$CONSTANT$$ - 1 ] equals 1 and var0 [ var8 ] equals var0 [ var9 ] , set var4 [ var8 ] [ var9 ] to 1 . initialize var10 , var11 to arrays of length var3 . set var10 [ 0 ] to 1 . for each var12 from 1 to var3 exclusive , perform the following operations . set var11 [ var12 ] to var11 [ $$CONSTANT$$ $$CONSTANT$$ 3 - 1 ] , var10 [ var12 ] to var10 [ $$CONSTANT$$ $$CONSTANT$$ 3 - 1 ] . for each var13 from 1 to var12 , add var4 [ var13 ] [ var12 ] * var10 [ $$CONSTANT$$ $$CONSTANT$$ 1 - 1 ] to var11 [ var12 ] and add var4 [ var13 ] [ var12 ] to var10 [ var12 ] . add var4 [ 0 ] [ var12 ] to var10 [ var12 ] . return var11 [ n - 1 ] . 
you are given the strings var0 and var1 . you have to store in var4 the number of characters of type " 1 " in var0 . if the value of var4 is not divisible by 2 you have to add 1 to var4 . 
you are given the strings var0 and var1 . you have to store in var4 the number of characters of type " 1 " in var0 . if the value of var4 is not divisible by 2 you have to add 1 to var4 . you have to store in var5 the number of characters of type " 1 " in var1 . if the value of var4 is greater than or equal to var5 you have to return " YES " , return " NO " otherwise . 
given integers var0 , var1 , var2 . assign to var3 the larger of var0 , var1 and var2 . assign 0 to var4 . in each case when var0 , var1 or var2 is less than days - 1 then add days - 1 - b , days - 1 - $$CONSTANT$$ or days - 1 - d to var4 , respectively . return var4 . 
given integers var0 , var1 , var2 . assign to var3 the larger of var0 , var1 and var2 . assign 0 to var4 . in each case when var0 , var1 or var2 is less than days - 1 then add days - 1 - b , days - 1 - $$CONSTANT$$ or days - 1 - d to var4 , respectively . 
given integers var0 , var1 , var2 . assign to var3 the larger of var0 , var1 and var2 . assign 0 to var4 . if var0 is less than days - 1 then assign days - 1 - b to var4 . if var1 is less than days - 1 then add days - 1 - $$CONSTANT$$ to var4 . 
given integers var0 , var1 , var2 . assign to var3 the larger of var0 , var1 and var2 . assign 0 to var4 . if var0 is less than days - 1 then assign days - 1 - b to var4 . 
given an array of integers var0 , initialize var1 to length of var0 , var2 to array of integers of length var1 , filled with zeroes . for each position var4 in var0 if var4 ! = 0 and var2 [ var4 - 1 ] ! = 0 , then substract 1 from var0 [ var4 ] and if var0 [ var4 ] < 0 , then set var2 [ var1 - 1 ] to 1 and break from the enclosing loop , set var2 [ var4 ] to 1 if var0 [ var4 ] is odd . 
given arrays of integers var0 and var2 and integers var1 and var4 , if var4 ! = 0 and var2 [ var4 - 1 ] ! = 0 , then substract 1 from var0 [ var4 ] and if var0 [ var4 ] < 0 , then set var2 [ var1 - 1 ] to 1 and break from the enclosing loop , set var2 [ var4 ] to 1 if var0 [ var4 ] is odd . 
given arrays of integers var0 and var2 and integers var1 and var4 , substract 1 from var0 [ var4 ] , if var0 [ var4 ] < 0 , then set var2 [ var1 - 1 ] to 1 and break from the enclosing loop . 
given an array of integers var0 , initialize var1 to length of var0 , var2 to array of integers of length var1 , filled with zeroes . for each position var4 in var0 if var4 ! = 0 and var2 [ var4 - 1 ] ! = 0 , then substract 1 from var0 [ var4 ] and if var0 [ var4 ] < 0 , then set var2 [ var1 - 1 ] to 1 and break from the enclosing loop , set var2 [ var4 ] to 1 if var0 [ var4 ] is odd . return " YES " if var2 [ var1 - 1 ] = 0 , return " NO " otherwise . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of strings var11 initially empty . you have to set var7 to the length of var0 , var2 to var7 and var3 to var7 - 1 . you have to create an array of numbers var8 of length var7 . for each position var1 in var0 you have to , set var9 to var0 [ var1 ] , you have to set var8 [ var9 - 1 ] to var9 , if var3 is greater than or equal to zero and var8 [ var3 ] is equal to var2 you have to , while var3 is greater than or equal to zero and var8 [ var3 ] is different to zero you have to , add the decimal representation of var8 [ var3 ] with $$CONSTANT$$ space at the end to var11 , if var2 is greater than or equal to zero subtract 1 to var3 , set var2 to var3 + 1 . 
you are given an array of numbers var8 , an array of numbers var0 , an index var10 , $$CONSTANT$$ number var3 , an array of strings var11 , $$CONSTANT$$ number var2 . you have to set var9 to var0 [ var10 ] and add 1 to var10 . you have to set var8 [ var9 - 1 ] to var9 . if var3 is greater than or equal to zero and var8 [ var3 ] is equal to var2 you have to , while var3 is greater than or equal to zero and var8 [ var3 ] is different to zero you have to , add the decimal representation of var8 [ var3 ] with $$CONSTANT$$ space at the end to var11 , if var2 is greater than or equal to zero subtract 1 to var3 , set var2 to var3 + 1 . 
you are given an array of numbers var8 , $$CONSTANT$$ number var3 , an array of strings var11 , $$CONSTANT$$ number var2 . you have to add the decimal representation of var8 [ var3 ] with $$CONSTANT$$ space at the end to var11 . if var2 is greater than or equal to zero you have to subtract 1 to var3 . you have to set var2 to var3 + 1 . 
you are given an array of numbers var8 , $$CONSTANT$$ number var3 , an array of strings var11 , $$CONSTANT$$ number var2 . you have to add the decimal representation of var8 [ var3 ] with $$CONSTANT$$ space at the end to var11 . if var2 is greater than or equal to zero you have to subtract 1 to var3 . 
given integers var0 , var1 . create char typed matrix var6 . if var1 exceeds n / 2 then update it by n - $$CONSTANT$$ . assign 1 to var2 , var3 and to var4 . for all var5 $$CONSTANT$$ from 1 to var0 do following operations . if ind + $$CONSTANT$$ does not exceed var0 then add the values var4 and var1 to var3 and to var2 , respectively . otherwise , do following operations . add to var2 the value $$CONSTANT$$ - n . if var2 equals 1 then add it to var3 . otherwise , add to var3 the value last + 1 and add 2 to var4 . add the string representation of var3 to the end of var6 . 
given integers var0 , var1 . if ind + $$CONSTANT$$ does not exceed var0 then add the values var4 and var1 to var3 and to var2 , respectively . otherwise , do following operations . add to var2 the value $$CONSTANT$$ - n . if var2 equals 1 then add it to var3 . otherwise , add to var3 the value last + 1 and add 2 to var4 . add the string representation of var3 to the end of var6 . 
given integers var0 , var1 . create char typed matrix var6 . if var1 exceeds n / 2 then update it by n - $$CONSTANT$$ . assign 1 to var2 , var3 and to var4 . for all var5 $$CONSTANT$$ from 1 to var0 do following operations . if ind + $$CONSTANT$$ does not exceed var0 then add the values var4 and var1 to var3 and to var2 , respectively . otherwise , do following operations . add to var2 the value $$CONSTANT$$ - n . if var2 equals 1 then add it to var3 . otherwise , add to var3 the value last + 1 and add 2 to var4 . add the string representation of var3 to the end of var6 . when the loop is ended , return var6 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of strings var11 initially empty . you have to set var7 to the length of var0 , var2 to var7 and var3 to var7 - 1 . you have to create an array of numbers var8 of length var7 . for each position var1 in var0 you have to , set var9 to var0 [ var1 ] , set var8 [ var9 - 1 ] to var9 , if var3 is greater than or equal to zero and var8 [ var3 ] is equal to var2 you have to , while var3 is greater than or equal to zero and var8 [ var3 ] is different to zero you have to , add the decimal representation of var8 [ var3 ] with $$CONSTANT$$ space at the end to var11 , if var2 is greater than or equal to zero subtract 1 to var3 , set var2 to var3 + 1 . you have to return var11 . 
you are given $$CONSTANT$$ number var0 . if var0 is not divisible by 2 you have to return - 1 . you have to create an array of numbers var1 of length var0 . for each var2 between 0 and var0 - 1 you have to set var1 [ var2 ] to var2 + 2 if var2 is divisible by 2 , or set var1 [ var2 ] to var2 otherwise . you have to store in var5 the decimal representation of all numbers in var1 separated by $$CONSTANT$$ space . 
you are given $$CONSTANT$$ number var0 . you have to create an array of numbers var1 of length var0 . for each var2 between 0 and var0 - 1 you have to set var1 [ var2 ] to var2 + 2 if var2 is divisible by 2 , or set var1 [ var2 ] to var2 otherwise . you have to store in var5 the decimal representation of all numbers in var1 separated by $$CONSTANT$$ space . 
you are given $$CONSTANT$$ number var0 . you have to create an array of numbers var1 of length var0 . for each var2 between 0 and var0 - 1 you have to set var1 [ var2 ] to var2 + 2 if var2 is divisible by 2 , or set var1 [ var2 ] to var2 otherwise . 
you are given $$CONSTANT$$ number var0 . you have to create an array of numbers var1 of length var0 . for each var2 between 0 and var0 - 1 you have to set var1 [ var2 ] to var2 + 2 if var2 is divisible by 2 , or set var1 [ var2 ] to var2 otherwise . 
you are given $$CONSTANT$$ number var0 . you have to create an array of numbers var1 of length var0 . for each var2 between 0 and var0 - 1 and divisible by 2 you have to set var1 [ var2 ] to var2 + 2 . 
you are given $$CONSTANT$$ number var0 . you have to create an array of numbers var1 of length var0 . for each var2 between 0 and var0 - 1 and divisible by 2 you have to set var1 [ var2 ] to var2 + 2 . 
you are given $$CONSTANT$$ number var0 . if var0 is not divisible by 2 you have to return - 1 . you have to create an array of numbers var1 of length var0 . for each var2 between 0 and var0 - 1 you have to set var1 [ var2 ] to var2 + 2 if var2 is divisible by 2 , or set var1 [ var2 ] to var2 otherwise . you have to store in var5 the decimal representation of all numbers in var1 separated by $$CONSTANT$$ space . you have to return var5 . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 ( indexing is 0 - based ) and an array of numbers var4 ( indexing is 0 - based ) . you have to set var8 to zero and var6 to the length of var2 . for each var5 between 1 and var6 you have to set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . input [ var5 ] to var2 [ var5 - 1 ] . for each var5 between 1 and var6 you have to set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var5 ] to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var5 - 1 ] plus $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . input [ var5 ] . for each var5 in var3 you have to set var9 to var3 [ var5 ] and var10 to var4 [ var5 ] , you have to set var11 to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var10 ] - $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var9 - 1 ] , and if var11 is greater than zero you have to add var11 to var8 . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 . you have to set var14 to zero , var13 to zero , var8 to zero , var6 to the length of var2 and var7 to the length of var3 . for each var5 between 1 and var6 you have to set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . input [ var5 ] to var2 [ var5 - 1 ] . for each var5 between 1 and var6 you have to set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var5 ] to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var5 - 1 ] plus $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . input [ var5 ] . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 . you have to set var14 to zero , var13 to zero , var8 to zero , var6 to the length of var2 and var7 to the length of var3 . for each var5 between 1 and var6 you have to set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . input [ var5 ] to var2 [ var5 - 1 ] . for each var5 between 1 and var6 you have to set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var5 ] to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var5 - 1 ] plus $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . input [ var5 ] . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 , an array of numbers var4 , an index var13 , an index var14 , $$CONSTANT$$ number var8 . you have to set var9 to var3 [ var13 ] and var10 to var4 [ var14 ] , you have to add 1 to var13 and 1 to var14 . you have to set var11 to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var10 ] , you have to subtract $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . sum [ var9 - 1 ] to var11 . if var11 is greater than zero you have to add var11 to var8 . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 . you have to set var14 to zero , var13 to zero , var8 to zero , var6 to the length of var2 and var7 to the length of var3 . for each var5 between 1 and var6 you have to set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . input [ var5 ] to var2 [ var5 - 1 ] . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 . you have to set var14 to zero , var13 to zero , var8 to zero , var6 to the length of var2 and var7 to the length of var3 . for each var5 between 1 and var6 you have to set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main . input [ var5 ] to var2 [ var5 - 1 ] . 
given an array var0 . initialize var5 to an empty array , var2 to 0 , var1 to the length of var0 . for each var4 from 0 to var1 - 1 exclusive , perform the following operatons . subtract var2 from var0 [ var4 ] . if var0 [ var4 ] is less than 0 , return " NO " . set var2 to var0 [ var4 ] modulo 2 . subtract var2 from var0 [ n - 1 ] . if var0 [ n - 1 ] is even , return " YES " ; else return " NO " . 
given an array var0 . initialize var5 to an empty array , var2 to 0 , var1 to the length of var0 . for each var4 from 0 to var1 - 1 exclusive , perform the following operatons . subtract var2 from var0 [ var4 ] . if var0 [ var4 ] is less than 0 , return " NO " . set var2 to var0 [ var4 ] modulo 2 . subtract var2 from var0 [ n - 1 ] . if var0 [ n - 1 ] is even , return " YES " ; else return " NO " . 
given an array var0 . initialize var5 to an empty array , var2 to 0 , var1 to the length of var0 . for each var4 from 0 to var1 - 1 exclusive , perform the following operatons . subtract var2 from var0 [ var4 ] . if var0 [ var4 ] is less than 0 , return " NO " . set var2 to var0 [ var4 ] modulo 2 . subtract var2 from var0 [ n - 1 ] . 
given an array var0 . initialize var5 to an empty array , var2 to 0 , var1 to the length of var0 . for each var4 from 0 to var1 - 1 exclusive , perform the following operatons . subtract var2 from var0 [ var4 ] . if var0 [ var4 ] is less than 0 , return " NO " . set var2 to var0 [ var4 ] modulo 2 . 
given an integer arrays var0 , var1 and var2 ( every 0 - based ) , an integers var11 is equal to zero , var10 is equal to zero , var9 is equal to zero , var3 is equal to length of var0 , var4 is equal to length of var1 , var5 is equal to zero , an array var6 of length var3 + 1 ( 1 - based ) , an integer var7 in range from 1 to var3 . var6 [ var7 ] is equal to sum of all var0 [ $$CONSTANT$$ ] for $$CONSTANT$$ in range from 0 to var7 - 1 . given an integer var8 in range from 0 to var4 - 1 . increase var5 by maximum from 0 and sum of all var0 [ $$CONSTANT$$ ] for $$CONSTANT$$ in range from var1 [ var10 ] to var2 [ var11 ] . 
given an integer arrays var0 , var1 and var2 ( every 0 - based ) , an integers var11 is equal to zero , var10 is equal to zero , var9 is equal to zero , var3 is equal to length of var0 , var4 is equal to length of var1 , var5 is equal to zero , an array var6 of length var3 + 1 ( 1 - based ) , an integer var7 in range from 1 to var3 . var6 [ var7 ] is equal to sum of all var0 [ $$CONSTANT$$ ] for $$CONSTANT$$ in range from 0 to var7 - 1 . 
if two given numbers var2 and var3 have $$CONSTANT$$ sum greater than another given number var0 then break from the enclosing loop . otherwise , set var2 to var3 and var3 to sum of var2 and var3 . 
initialize var4 to sum of two given variables var2 and var3 . given an integer var0 . if var4 is bigger than var0 break from the enclosing loop . 
given integers var0 and var1 . assign the values var1 , 1 , 2 to var2 , var3 and var4 , respectively . assign 1 to var5 . as long as var4 does not exceed var2 , do following operations . increase var3 by 1 . assign cur + prev to var6 . assign var4 to var5 . assign var6 to var4 . 
you are given an integer var1 . initialize var3 to 2 , var4 to 3 , var5 to 1 . while var4 is less than or equal to var1 , set var6 to var3 + var4 , var3 to var4 , and var4 to var6 in that $$CONSTANT$$ , increment var5 . 
given an integer arrays var0 , var1 and var2 ( every 0 - based ) , an integers var11 is equal to zero , var10 is equal to zero , var9 is equal to zero , var3 is equal to length of var0 , var4 is equal to length of var1 , var5 is equal to zero , an array var6 of length var3 + 1 ( 1 - based ) , an integer var7 in range from 1 to var3 . var6 [ var7 ] is equal to sum of all var0 [ $$CONSTANT$$ ] for $$CONSTANT$$ in range from 0 to var7 - 1 . given an integer var8 in range from 0 to var4 - 1 . increase var5 by maximum from 0 and sum of all var0 [ $$CONSTANT$$ ] for $$CONSTANT$$ in range from var1 [ var10 ] to var2 [ var11 ] . return var5 . 
you are given an integer var1 . initialize var3 to 2 , var4 to 3 , var5 to 1 . while var4 is less than or equal to var1 , set var6 to var3 + var4 , var3 to var4 , and var4 to var6 in that $$CONSTANT$$ , increment var5 . after the loop is finished , return var5 . 
given integers var0 , var1 . create integer array var2 of size 3 filled by var1 $$CONSTANT$$ . assign 0 to var3 . while true do following operations . sort var2 . assign to var2 [ 0 ] the minimum of var0 and ( var2 [ 1 ] + var2 [ 2 ] ) - 1 . add 1 to var3 . if var2 [ 0 ] equals var0 then add 2 to var3 and exit from the loop . 
given integers var0 , var1 . sort var2 . assign to var2 [ 0 ] the minimum of var0 and ( var2 [ 1 ] + var2 [ 2 ] ) - 1 . add 1 to var3 . if var2 [ 0 ] equals var0 then add 2 to var3 and exit from the loop . 
given integers var0 , var1 . create integer array var2 of size 3 filled by var1 $$CONSTANT$$ . assign 0 to var3 . while true do following operations . sort var2 . assign to var2 [ 0 ] the minimum of var0 and ( var2 [ 1 ] + var2 [ 2 ] ) - 1 . add 1 to var3 . if var2 [ 0 ] equals var0 then add 2 to var3 and exit from the loop . when the loop is ended , return var3 . 
you are given $$CONSTANT$$ string var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var3 , $$CONSTANT$$ number var4 . for each position var6 in var0 , if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var1 , otherwise if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var2 , otherwise if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var3 , otherwise if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var4 . you have to set var5 to ( the sum of the absolte value of var1 - var2 and the absolute value of var3 - var4 ) divided by 2 ( rounded down ) . you have to return var5 . 
you are given $$CONSTANT$$ string var0 . set var1 to zero , var2 to zero , var3 to zero , var4 to zero . if the length of var0 is divisible by 2 you have to , for each position var6 in var0 , if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var1 , otherwise if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var2 , otherwise if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var3 , otherwise if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var4 ; set var5 to ( the sum of the absolte value of var1 - var2 and the absolute value of var3 - var4 ) divided by 2 ( rounded down ) , and return var5 ; otherwise you have to return - 1 . 
given integer arrays var2 , var3 and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . flower . initialize var15 , var14 , var13 to 0 , var5 to length of var2 and var6 to length of var3 . for each var7 from 0 to var6 - 1 , initialize var11 to the sum of elements of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . flower with indices from var3 [ var7 ] - 1 to var4 [ var7 ] - 1 inclusive . if var11 is greater than 0 , add var11 to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . $$CONSTANT$$ . 
given arrays $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . flower , var3 , var4 and integers var6 , $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . $$CONSTANT$$ . for each var7 from 0 to var6 - 1 , initialize var11 to the sum of elements of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . flower with indices from var3 [ var7 ] - 1 to var4 [ var7 ] - 1 inclusive . if var11 is greater than 0 , add var11 to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . $$CONSTANT$$ . 
given integer arrays var2 and var3 . initialize var15 , var14 , var13 to 0 , var5 to length of var2 and var6 to length of var3 . initialize an array $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . flower to an array var2 . 
given integer arrays var2 and var3 . initialize var15 , var14 , var13 to 0 , var5 to length of var2 and var6 to length of var3 . initialize an array $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . flower to an array var2 . 
given arrays $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . flower , var3 , var4 and an integer var6 . for each var7 from 0 to var6 - 1 , initialize var11 to the sum of elements of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . b . flower with indices from var3 [ var7 ] - 1 to var4 [ var7 ] - 1 inclusive . 
given integer arrays var0 , var1 , var2 . assign 0 to var6 . for all var5 $$CONSTANT$$ from 0 to $$CONSTANT$$ - 1 let var10 be the sum of elements from var0 with positions from var1 [ var5 ] to var2 [ var5 ] and if var10 is not negative value then add it to var6 . 
given integer arrays var0 , var1 , var2 . let var10 be the sum of elements from var0 with positions from var1 [ var5 ] to var2 [ var5 ] . if var10 is not negative value then add it to var6 . 
given integer arrays var0 , var1 , var2 . let var10 be the sum of elements from var0 with positions from var1 [ var5 ] to var2 [ var5 ] . if var10 is negative value then go to the next step of the loop . 
given integer arrays var0 , var1 , var2 . let var10 be the sum of elements from var0 with positions from var1 [ var5 ] to var2 [ var5 ] . 
given integer arrays var0 , var1 , var2 . assign 0 to var6 . for all var5 $$CONSTANT$$ from 0 to $$CONSTANT$$ - 1 let var10 be the sum of elements from var0 with positions from var1 [ var5 ] to var2 [ var5 ] and if var10 is not negative value then add it to var6 . return the resultant var6 . 
you are given $$CONSTANT$$ number var0 . you have to create an array of numbers var1 of length $$CONSTANT$$ . you have to set var1 [ 1 ] to 2 and var1 [ 2 ] to 3 . for each var2 between 3 and $$CONSTANT$$ you have to set var1 [ var2 ] to var1 [ var2 - 1 ] + var1 [ $$CONSTANT$$ - 2 ] . you have to set var3 to the less index in var1 with var1 [ var3 ] greater than var0 . you have to return var3 - 1 . 
you are given $$CONSTANT$$ number var0 . you have to create an array of numbers var1 of length $$CONSTANT$$ . you have to set var1 [ 1 ] to 2 and var1 [ 2 ] to 3 . for each var2 between 3 and $$CONSTANT$$ you have to set var1 [ var2 ] to var1 [ var2 - 1 ] + var1 [ $$CONSTANT$$ - 2 ] . 
given an integer var0 , integer var2 , char array var1 . length of var1 is equal to var0 div 2 . for var2 in range from 0 to var0 div 2 - 1 : assign var1 [ var2 ] to $$CONSTANT$$ . 
you are given an array of numbers var0 . you have to create an array of strings var7 , create an array of numbers var2 of the length of var0 , set var3 to the length of var0 minus 1 . for each position var5 in var0 you have to set var4 to var0 [ var5 ] , set var2 [ var4 - 1 ] to var4 , while var3 is greater than or equal to zero and var2 [ var3 ] is greater than zero you have to insert in var7 the decimal representation of var2 [ var3 ] with $$CONSTANT$$ space at the end , subtract 1 to var3 . 
you are given an array of numbers var0 , an array of numbers var2 , $$CONSTANT$$ number var3 , an index var6 and an array of strings var7 . you have to set var4 to var0 [ var6 ] and add 1 to var6 . you have to set var2 [ var4 - 1 ] to var4 . while var3 is greater than or equal to zero and var2 [ var3 ] is greater than zero you have to insert in var7 the decimal representation of var2 [ var3 ] with $$CONSTANT$$ space at the end , subtract 1 to var3 . 
you are given an array var0 of char type . let result be an array of char type . let var2 be the rightmost position in var0 where " ru " is stanging . if the beginning $$CONSTANT$$ of var0 ending at 3 , equals " ftp " then let the result consist of values " ftp : / / " , $$CONSTANT$$ $$CONSTANT$$ of var0 starting at position 3 and ending at var2 , and the value " . ru " , and if ru + 2 equals the length of var0 then add the ending $$CONSTANT$$ of var0 starting at ru + 2 to the end of the result . if the beginning $$CONSTANT$$ of var0 ending at 3 was not equal to " ftp " then let the result consist of values " http : / / " , $$CONSTANT$$ $$CONSTANT$$ of var0 starting at position 4 and ending at var2 , and the value " . ru " , and if ru + 2 equals the length of var0 then add the ending $$CONSTANT$$ of var0 starting at ru + 2 to the end of the result . return the result . 
you are given an array of numbers var0 . you have to create an array of strings var7 , create an array of numbers var2 of the length of var0 , set var3 to the length of var0 minus 1 . for each position var5 in var0 you have to set var4 to var0 [ var5 ] , set var2 [ var4 - 1 ] to var4 , while var3 is greater than or equal to zero and var2 [ var3 ] is greater than zero you have to insert in var7 the decimal representation of var2 [ var3 ] with $$CONSTANT$$ space at the end , subtract 1 to var3 . after the loop in var5 ends , you have to return var7 . 
given integers var0 and var1 , count the number of pairs ( var5 ; var6 ) such that var5 * var5 + var6 = var0 and var5 + var6 * var6 = var1 . store the result in var4 . 
given an integer var0 . if var0 is prime , return true , else return false . 
given integers var2 , var3 , var5 and var4 , count the number of integers var6 such that var5 * var5 + var6 = var2 and var5 + var6 * var6 = var3 . add the result to var4 . 
given integer var0 and an array var1 of char type . assign values of var0 , var1 , var3 to variables var2 , var3 , var4 , respectively . create arrays var5 consisting of positions of array var4 containing the value which does not equal 68 , var6 consisting of positions of array var4 containing the value 68 , both of integer types . while length of var5 does not equal 0 and length of var6 does not equal 0 do following operations . initialize var8 to the length of array var5 after deleting its first element . initialize var9 to the length of array var6 after deleting its first element . if var8 is larger than var9 then insert the value var9 + var2 into array var6 . otherwise , insert the value var8 + var2 into array var5 . 
given integer var0 and an array var1 of char type . initialize var8 to the length of array var5 after deleting its first element . initialize var9 to the length of array var6 after deleting its first element . if var8 is larger than var9 then insert the value var9 + var2 into array var6 . otherwise , insert the value var8 + var2 into array var5 . 
given integer var0 and an array var1 of char type . assign values of var0 , var1 , var3 to variables var2 , var3 , var4 , respectively . create arrays var5 consisting of positions of array var4 containing the value which does not equal 68 , var6 consisting of positions of array var4 containing the value 68 , both of integer types . 
given integer var0 and an array var1 of char type . assign values of var0 , var1 , var3 to variables var2 , var3 , var4 , respectively . create arrays var5 consisting of positions of array var4 containing the value which does not equal 68 , var6 consisting of positions of array var4 containing the value 68 , both of integer types . while length of var5 does not equal 0 and length of var6 does not equal 0 do following operations . initialize var8 to the length of array var5 after deleting its first element . initialize var9 to the length of array var6 after deleting its first element . if var8 is larger than var9 then insert the value var9 + var2 into array var6 . otherwise , insert the value var8 + var2 into array var5 . after the loop is ended , if length of var5 equals 0 then return " $$CONSTANT$$ " . otherwise , return " $$CONSTANT$$ " . 
given integer arrays var0 , var1 , var2 . create 0 - based integer matrix var6 at first $$CONSTANT$$ containing the array var1 and at second $$CONSTANT$$ containing var2 with all values being decreased by 1 . assign 0 to var8 . for each var13 from 0 to $$CONSTANT$$ - 1 , do following operations . assign 0 to var10 . for each var5 from var9 to $$CONSTANT$$ - 1 , initialize var12 to the sum of all values var0 [ var13 ] whre var13 is from var6 [ var11 ] [ 0 ] to var6 [ var11 ] [ 1 ] and assign the larger of sum + total and var10 to var10 . when var5 becomes equal to var4 , assign the larger of var10 and var8 to var8 . 
given integer arrays var0 , var1 , var2 . assign 0 to var10 . for each var5 from var9 to $$CONSTANT$$ - 1 , initialize var12 to the sum of all values var0 [ var13 ] whre var13 is from var6 [ var11 ] [ 0 ] to var6 [ var11 ] [ 1 ] and assign the larger of sum + total and var10 to var10 . when var5 becomes equal to var4 , assign the larger of var10 and var8 to var8 . 
given an integer var0 , initialize var1 to 2 , var2 to 1 and var3 to 1 . for as long as var1 + var2 < = var0 , add var2 to var1 , set var2 to var1 - var2 and increase var3 by 1 . 
you are given $$CONSTANT$$ number var0 . you have to create an array of numbers var1 of length $$CONSTANT$$ . you have to set var1 [ 1 ] to 2 and var1 [ 2 ] to 3 . for each var2 between 3 and $$CONSTANT$$ you have to set var1 [ var2 ] to var1 [ var2 - 1 ] + var1 [ $$CONSTANT$$ - 2 ] . you have to set var3 to the less index in var1 with var1 [ var3 ] greater than var0 . you have to return var3 - 1 . 
given an integer var0 , initialize var1 to 2 , var2 to 1 and var3 to 1 . for as long as var1 + var2 < = var0 , add var2 to var1 , set var2 to var1 - var2 and increase var3 by 1 . return var3 . 
given an array var0 of length var1 . if ( var0 [ var1 - 2 ] is less than var0 [ var1 - 1 ] and var0 [ var1 - 1 ] not equals to 15 ) or ( var0 [ var1 - 2 ] is greater than var0 [ var1 - 1 ] and var0 [ var1 - 1 ] not equals to 0 ) , return " UP " . otherwise , return " DOWN " . 
you are given integers var4 and var5 . create an array var8 of integer type . update var4 by the value n % 6 . create an array var6 of size 3 , consisting of ' - 1 ' $$CONSTANT$$ . assign 1 to var6 [ var5 ] . for all var1 $$CONSTANT$$ from var4 to var1 > = 1 , if var1 is even number then exchange the elements of var6 at positions 1 and 2 . otherwise , exchange the elements of var6 at positions 0 and 1 . insert the positions of var6 containing ' 1 ' , into var8 . 
you are given integers var4 and var5 . create an array var8 of integer type . update var4 by the value n % 6 . create an array var6 of size 3 , consisting of ' - 1 ' $$CONSTANT$$ . assign 1 to var6 [ var5 ] . for all var1 $$CONSTANT$$ from var4 to var1 > = 1 , if var1 is even number then exchange the elements of var6 at positions 1 and 2 . otherwise , exchange the elements of var6 at positions 0 and 1 . 
you are given integers var4 and var5 . update var4 by the value n % 6 . create an array var6 of size 3 , consisting of ' - 1 ' $$CONSTANT$$ . assign 1 to var6 [ var5 ] . for all var1 $$CONSTANT$$ from var4 to var1 > = 1 , if var1 is even number then exchange the elements of var6 at positions 1 and 2 . otherwise , exchange the elements of var6 at positions 0 and 1 . return in increasing $$CONSTANT$$ the positions of var6 containing ' 1 ' $$CONSTANT$$ . 
you are given integers var4 and var5 . create an array var8 of integer type . update var4 by the value n % 6 . create an array var6 of size 3 , consisting of ' - 1 ' $$CONSTANT$$ . assign 1 to var6 [ var5 ] . for all var1 $$CONSTANT$$ from var4 to var1 > = 1 , if var1 is even number then exchange the elements of var6 at positions 1 and 2 . otherwise , exchange the elements of var6 at positions 0 and 1 . 
given array var4 of char type and an integer var2 . initialize the length of var4 to var5 . assign var2 to result . initialize 0 to var7 . for all var8 $$CONSTANT$$ from 0 to var8 < var5 , incremenet var7 by the result of function func0 ( 10 , var5 - $$CONSTANT$$ - 1 ) , var2 ) * ( var4 [ var8 ] - 48 ) ) % var2 ) ) modulo var2 . when var8 becomes equal var5 , exit from current loop and do following one . for all var9 $$CONSTANT$$ from 0 to var9 < var5 , do following operations . if var4 [ var9 ] does not equal 48 then update the result by the minimum of its current value and var7 . otherwise , do nothing . increase var7 by the value ( var7 * 10 ) + ( var4 [ var9 ] - 48 ) - func0 ( 10 , ( var5 - 1 ) , var2 ) * ( var4 [ var9 ] - 48 ) ) % var2 ) ) + var2 taken by modulo var2 . 
given 3 arrays of integers var1 , var2 and var0 . assign var14 and var15 to 0 . assign var3 to length of var0 . assign var4 to length of var1 . assign var5 to empty array of length var4 . assign var6 to 0 . for each var6 in range from 0 to var4 - 1 : ( assign var5 [ var7 ] to sum of array var0 in range from var1 [ var14 ] - 1 to var2 [ var15 ] - 1 . increment var14 and var15 ) . sort array var5 . assign var12 to sum of all positive elements in var5 . 
given array var4 of char type and an integer var2 . initialize the length of var4 to var5 . assign var2 to result . initialize 0 to var7 . for all var8 $$CONSTANT$$ from 0 to var8 < var5 , incremenet var7 by the result of function func0 ( 10 , var5 - $$CONSTANT$$ - 1 ) , var2 ) * ( var4 [ var8 ] - 48 ) ) % var2 ) ) modulo var2 . when var8 becomes equal var5 , exit from current loop and do following one . for all var9 $$CONSTANT$$ from 0 to var9 < var5 , do following operations . if var4 [ var9 ] does not equal 48 then update the result by the minimum of its current value and var7 . otherwise , do nothing . increase var7 by the value ( var7 * 10 ) + ( var4 [ var9 ] - 48 ) - func0 ( 10 , ( var5 - 1 ) , var2 ) * ( var4 [ var9 ] - 48 ) ) % var2 ) ) + var2 taken by modulo var2 . when var9 becomes equal var5 , exit from the loop and return the result . 
given 3 arrays of integers var1 , var2 and var0 . assign var14 and var15 to 0 . assign var3 to length of var0 . assign var4 to length of var1 . assign var5 to empty array of length var4 . assign var6 to 0 . for each var6 in range from 0 to var4 - 1 : ( assign var5 [ var7 ] to sum of array var0 in range from var1 [ var14 ] - 1 to var2 [ var15 ] - 1 . increment var14 and var15 ) . sort array var5 . 
given integers var0 , var1 , var2 . if var6 is even value then exchange values of var5 [ 1 ] and var5 [ 2 ] . otherwise , exhcange values of var5 [ 0 ] , var5 [ 1 ] . 
given integers var0 and var1 , count the number of pairs ( var5 ; var6 ) such that var5 * var5 + var6 = var0 and var5 + var6 * var6 = var1 . return the result . 
given integers var3 , var1 and an array var2 . initialize var4 to the length of var2 , var5 to var1 , var6 to var2 . sort var6 in increasing $$CONSTANT$$ . initialize var8 to 0 , var9 to var6 [ 0 ] , var10 , var11 to 0 . for each var12 from 0 to var4 exclusive , perform the following operations . add var6 [ $$CONSTANT$$ - 1 ] to var10 . if var12 is greater than 0 , add var6 [ $$CONSTANT$$ $$CONSTANT$$ 1 - 1 ] to var10 ; else add var6 [ var12 ] * ( var12 - var11 ) to var10 . while var10 is greater than var5 and var11 is less than var12 , subtract var6 [ var12 ] - var6 [ var11 ] from var10 and increase var11 by 1 . if var12 - var11 + 1 is greater than var8 , set var8 to var12 - var11 + 1 and set var9 to var6 [ var12 ] . 
given an array var6 and integers var12 , var10 , var11 , var5 , var8 , var9 . add var6 [ $$CONSTANT$$ - 1 ] to var10 . if var12 is greater than 0 , add var6 [ $$CONSTANT$$ $$CONSTANT$$ 1 - 1 ] to var10 ; else add var6 [ var12 ] * ( var12 - var11 ) to var10 . while var10 is greater than var5 and var11 is less than var12 , subtract var6 [ var12 ] - var6 [ var11 ] from var10 and increase var11 by 1 . if var12 - var11 + 1 is greater than var8 , set var8 to var12 - var11 + 1 and set var9 to var6 [ var12 ] . 
given an array var6 and integers var12 , var10 , var11 , var5 . add var6 [ $$CONSTANT$$ - 1 ] to var10 . if var12 is greater than 0 , add var6 [ $$CONSTANT$$ $$CONSTANT$$ 1 - 1 ] to var10 ; else add var6 [ var12 ] * ( var12 - var11 ) to var10 . while var10 is greater than var5 and var11 is less than var12 , subtract var6 [ var12 ] - var6 [ var11 ] from var10 and increase var11 by 1 . 
given 3 arrays of integers var1 , var2 and var0 . assign var14 and var15 to 0 . assign var3 to length of var0 . assign var4 to length of var1 . assign var5 to empty array of length var4 . assign var6 to 0 . for each var6 in range from 0 to var4 - 1 : ( assign var5 [ var7 ] to sum of array var0 in range from var1 [ var14 ] - 1 to var2 [ var15 ] - 1 . increment var14 and var15 ) . sort array var5 . assign var12 to sum of all positive elements in var5 . return var12 . 
given $$CONSTANT$$ string var0 . initialize var3 to the length of var0 , var4 to $$CONSTANT$$ two - dimensional array consisting of var3 rows and var3 columns . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] [ var5 ] to 1 . for each var6 from 0 to var3 - 1 exclusive , if var0 [ var6 ] equals to var0 [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] , set var4 [ var6 ] [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] to 1 . for each var7 from 3 to var3 and var8 from 0 to var3 - var7 , perform the following operations . initialize var9 to var8 + var7 - 1 . if var4 [ $$CONSTANT$$ $$CONSTANT$$ 2 + 1 ] [ $$CONSTANT$$ - 1 ] equals 1 and var0 [ var8 ] equals var0 [ var9 ] , set var4 [ var8 ] [ var9 ] to 1 . initialize var10 , var11 to arrays of length var3 . set var10 [ 0 ] to 1 . 
given $$CONSTANT$$ string var0 . initialize var3 to the length of var0 , var4 to $$CONSTANT$$ two - dimensional array consisting of var3 rows and var3 columns . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] [ var5 ] to 1 . for each var6 from 0 to var3 - 1 exclusive , if var0 [ var6 ] equals to var0 [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] , set var4 [ var6 ] [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] to 1 . for each var7 from 3 to var3 and var8 from 0 to var3 - var7 , perform the following operations . initialize var9 to var8 + var7 - 1 . if var4 [ $$CONSTANT$$ $$CONSTANT$$ 2 + 1 ] [ $$CONSTANT$$ - 1 ] equals 1 and var0 [ var8 ] equals var0 [ var9 ] , set var4 [ var8 ] [ var9 ] to 1 . initialize var10 , var11 to arrays of length var3 . set var10 [ 0 ] to 1 . 
given $$CONSTANT$$ string var0 . initialize var3 to the length of var0 , var4 to $$CONSTANT$$ two - dimensional array consisting of var3 rows and var3 columns . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] [ var5 ] to 1 . for each var6 from 0 to var3 - 1 exclusive , if var0 [ var6 ] equals to var0 [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] , set var4 [ var6 ] [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] to 1 . for each var7 from 3 to var3 and var8 from 0 to var3 - var7 , perform the following operations . initialize var9 to var8 + var7 - 1 . if var4 [ $$CONSTANT$$ $$CONSTANT$$ 2 + 1 ] [ $$CONSTANT$$ - 1 ] equals 1 and var0 [ var8 ] equals var0 [ var9 ] , set var4 [ var8 ] [ var9 ] to 1 . 
given arrays var10 , var11 , var4 and an integer var12 . set var11 [ var12 ] to var11 [ $$CONSTANT$$ $$CONSTANT$$ 3 - 1 ] , var10 [ var12 ] to var10 [ $$CONSTANT$$ $$CONSTANT$$ 3 - 1 ] . for each var13 from 1 to var12 , add var4 [ var13 ] [ var12 ] * var10 [ $$CONSTANT$$ $$CONSTANT$$ 1 - 1 ] to var11 [ var12 ] and add var4 [ var13 ] [ var12 ] to var10 [ var12 ] . add var4 [ 0 ] [ var12 ] to var10 [ var12 ] . 
given arrays var10 , var11 , var4 and an integer var12 . set var11 [ var12 ] to var11 [ $$CONSTANT$$ $$CONSTANT$$ 3 - 1 ] , var10 [ var12 ] to var10 [ $$CONSTANT$$ $$CONSTANT$$ 3 - 1 ] . for each var13 from 1 to var12 , add var4 [ var13 ] [ var12 ] * var10 [ $$CONSTANT$$ $$CONSTANT$$ 1 - 1 ] to var11 [ var12 ] and add var4 [ var13 ] [ var12 ] to var10 [ var12 ] . 
given $$CONSTANT$$ string var0 . initialize var3 to the length of var0 , var4 to $$CONSTANT$$ two - dimensional array consisting of var3 rows and var3 columns . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] [ var5 ] to 1 . for each var6 from 0 to var3 - 1 exclusive , if var0 [ var6 ] equals to var0 [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] , set var4 [ var6 ] [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] to 1 . 
given $$CONSTANT$$ string var0 . initialize var3 to the length of var0 , var4 to $$CONSTANT$$ two - dimensional array consisting of var3 rows and var3 columns . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] [ var5 ] to 1 . for each var6 from 0 to var3 - 1 exclusive , if var0 [ var6 ] equals to var0 [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] , set var4 [ var6 ] [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] to 1 . 
given integers var3 , var1 and an array var2 . initialize var4 to the length of var2 , var5 to var1 , var6 to var2 . sort var6 in increasing $$CONSTANT$$ . initialize var8 to 0 , var9 to var6 [ 0 ] , var10 , var11 to 0 . for each var12 from 0 to var4 exclusive , perform the following operations . add var6 [ $$CONSTANT$$ - 1 ] to var10 . if var12 is greater than 0 , add var6 [ $$CONSTANT$$ $$CONSTANT$$ 1 - 1 ] to var10 ; else add var6 [ var12 ] * ( var12 - var11 ) to var10 . while var10 is greater than var5 and var11 is less than var12 , subtract var6 [ var12 ] - var6 [ var11 ] from var10 and increase var11 by 1 . if var12 - var11 + 1 is greater than var8 , set var8 to var12 - var11 + 1 and set var9 to var6 [ var12 ] . return the concatenation of var8 , " " , var9 . 
given $$CONSTANT$$ string var0 , $$CONSTANT$$ two - dimensional array var4 and integers var7 , var3 . for each var8 from 0 to var3 - var7 , perform the following operations . initialize var9 to var8 + var7 - 1 . if var4 [ $$CONSTANT$$ $$CONSTANT$$ 2 + 1 ] [ $$CONSTANT$$ - 1 ] equals 1 and var0 [ var8 ] equals var0 [ var9 ] , set var4 [ var8 ] [ var9 ] to 1 . 
given integers var3 , var1 and an array var2 . initialize var4 to the length of var2 , var5 to var1 , var6 to var2 . sort var6 in increasing $$CONSTANT$$ . initialize var8 to 0 , var9 to var6 [ 0 ] . 
given integers var3 , var1 and an array var2 . initialize var4 to the length of var2 , var5 to var1 , var6 to var2 . sort var6 in increasing $$CONSTANT$$ . 
given integers var3 , var1 and an array var2 . initialize var4 to the length of var2 , var5 to var1 , var6 to var2 . 
given $$CONSTANT$$ string var0 . initialize var3 to the length of var0 , var4 to $$CONSTANT$$ two - dimensional array consisting of var3 rows and var3 columns . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] [ var5 ] to 1 . 
given $$CONSTANT$$ string var0 . initialize var3 to the length of var0 , var4 to $$CONSTANT$$ two - dimensional array consisting of var3 rows and var3 columns . for each var5 from 0 to var3 exclusive , set var4 [ var5 ] [ var5 ] to 1 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var1 to the length of var0 . if var1 is equal to 1 you have to , if var0 [ 0 ] is different to 15 and var0 [ 0 ] is different to zero return - 1 , otherwise if var0 [ 0 ] is equal to 15 return " DOWN " , otherwise return " UP " ; otherwise you have to , if var0 [ var1 - 1 ] is greater than var0 [ var1 - 2 ] and ( var0 [ var1 - 1 ] is different to 15 or var0 [ var1 - 1 ] is equal to zero ) return " UP " , otherwise return " DOWN " . 
given 0 - based integer array var0 . if it consists of only one element then if it is 0 or 15 then return " UP " or " DOWN " , respectively , or return " - 1 " if it has another value . if var0 consists of several elements then if last element has value 0 or 15 then return " UP " or " DOWN " , respectively . otherwise , if the element standing before the last one is larger than the last one then return " UP " . otherwise , return " DOWN " . 
given integers var1 , var2 . initialize var7 to an array , var3 to 1 , var2 to the minimum between var2 and var1 - var2 , var4 to 0 , var5 to 1 . for each var6 from 0 to var1 exclusive , perform the following operations . if var4 + var2 is not greater than var1 , add var3 to var5 ; else add var3 + 1 to var5 , add 2 to var3 . push var5 into var7 . set var4 to ( var4 + var2 ) modulo var1 . 
given integers var4 , var2 , var1 , var5 , var3 and an array $$CONSTANT$$ ret . if var4 + var2 is not greater than var1 , add var3 to var5 ; else add var3 + 1 to var5 , add 2 to var3 . push var5 into var7 . set var4 to ( var4 + var2 ) modulo var1 . 
given an integer var0 , return false if there exists an integer var1 such that var1 > = 2 , var1 * var1 < = var0 and var0 is divisible by var1 . 
given integers var1 , var2 . initialize var7 to an array , var3 to 1 , var2 to the minimum between var2 and var1 - var2 , var4 to 0 , var5 to 1 . for each var6 from 0 to var1 exclusive , perform the following operations . if var4 + var2 is not greater than var1 , add var3 to var5 ; else add var3 + 1 to var5 , add 2 to var3 . push var5 into var7 . set var4 to ( var4 + var2 ) modulo var1 . return var7 . 
you are given $$CONSTANT$$ number var0 . if var0 is divisible by 2 you have to set var1 to 2 , otherwise you have to set var1 to 3 . you have to store in var2 the greatest divisor of var0 less than or equal to the square root of var0 . if var2 is equal to 1 you have to set var1 to 1 . you have to store in var2 the greatest divisor of var0 - 2 less than or equal to the square root of var0 - 2 . if var2 is equal to 1 set var1 to the minimum between var1 and 2 . 
given an integer var0 , return true if var0 is $$CONSTANT$$ prime number , return false otherwise . 
you are given $$CONSTANT$$ number var0 . if var0 is divisible by 2 you have to set var1 to 2 , otherwise you have to set var1 to 3 . you have to store in var2 the greatest divisor of var0 less than or equal to the square root of var0 . if var2 is equal to 1 you have to set var1 to 1 . you have to store in var2 the greatest divisor of var0 - 2 less than or equal to the square root of var0 - 2 . 
you are given $$CONSTANT$$ number var0 . if var0 is divisible by 2 you have to set var1 to 2 , otherwise you have to set var1 to 3 . you have to store in var2 the greatest divisor of var0 less than or equal to the square root of var0 . if var2 is equal to 1 you have to set var1 to 1 . 
you are given $$CONSTANT$$ number var0 . if var0 is divisible by 2 you have to set var1 to 2 , otherwise you have to set var1 to 3 . you have to store in var2 the greatest divisor of var0 less than or equal to the square root of var0 . if var2 is equal to 1 you have to set var1 to 1 . 
you are given $$CONSTANT$$ number var0 . if var0 is divisible by 2 you have to set var1 to 2 , otherwise you have to set var1 to 3 . you have to store in var2 the greatest divisor of var0 less than or equal to the square root of var0 . 
you are given $$CONSTANT$$ number var0 . if var0 is divisible by 2 you have to set var1 to 2 , otherwise you have to set var1 to 3 . 
given strings var0 and var1 . initialize var3 to 0 and var4 to true . iterate over var0 from begin to end and for each character if var3 is less than the length of var1 and current character equals to var1 [ var3 ] increase var3 by one , otherwise if current character equals to $$CONSTANT$$ or $$CONSTANT$$ then make var4 equal to false and stop iterating . 
given integer var5 and string var6 . find the first integer greater than var5 such that func0 called using this integer converted to string and var6 as arguments returns true , and return this integer . 
given integer var5 and string var6 . initialize var7 to var5 + 1 , while func0 called using var7 converted to string and var6 as arguments returns false increase var7 by 1 . 
you are given $$CONSTANT$$ number var0 . if var0 is divisible by 2 you have to set var1 to 2 , otherwise you have to set var1 to 3 . you have to store in var2 the greatest divisor of var0 less than or equal to the square root of var0 . if var2 is equal to 1 you have to set var1 to 1 . you have to store in var2 the greatest divisor of var0 - 2 less than or equal to the square root of var0 - 2 . if var2 is equal to 1 set var1 to the minimum between var1 and 2 . return var1 . 
given an array of integers var2 and an integer var1 , initialize var5 to empty array of integers , var3 to 0 , var4 to 0 . for each position var6 in var2 add 1 to var4 and add var2 [ var6 ] to var3 , append 2 to the end of var5 if var3 - var4 is even , append 1 to the end of var5 otherwise . 
you are given $$CONSTANT$$ number var0 . you have to set var1 to 1 , var2 to 1 and var3 to 2 . while var3 is less than var0 you have to set var4 to var2 + var3 , you have to set var2 to var3 , you have to set var3 to var4 and you have to add 1 to var1 . if var3 is equal to var0 you have to return var1 , otherwise you have to return var1 - 1 . 
given an array of integers var2 and an integer var1 , initialize var5 to empty array of integers , var3 to 0 , var4 to 0 . for each position var6 in var2 add 1 to var4 and add var2 [ var6 ] to var3 , append 2 to the end of var5 if var3 - var4 is even , append 1 to the end of var5 otherwise . return var5 . 
given arrays of integers var2 and var5 and integers var4 , var3 and var6 , add 1 to var4 and add var2 [ var6 ] to var3 , append 2 to the end of var5 if var3 - var4 is even , append 1 to the end of var5 otherwise . 
given an array var0 . initialize var7 to an empty array , var2 to 0 . for each var5 in var0 , perform the following operations . add var5 - 1 to var2 . if var2 is even , push 2 into var7 ; else push 1 into var7 . 
given arrays var0 , var7 and integers var4 , var3 , var2 , var6 . initialize var5 to var0 [ var6 ] . add var5 - 1 to var2 . if var2 is even , push 2 into var7 ; else push 1 into var7 . 
given an array var0 . initialize var7 to an empty array , var2 to 0 . for each var5 in var0 , perform the following operations . add var5 - 1 to var2 . if var2 is even , push 2 into var7 ; else push 1 into var7 . return var7 . 
given integers var0 , var1 , var2 , var3 , var4 . assign $$CONSTANT$$ * $$CONSTANT$$ to var5 . if var1 is not less than var0 then return d * $$CONSTANT$$ . assign the values ( var2 * var1 ) + var4 , b * $$CONSTANT$$ to var6 and var7 , respectively . if var6 does not exceed var7 then add ( ( var0 - var1 ) / var1 ) * var6 to var5 . otherwise , add ( ( var0 - var1 ) / var1 ) * var7 to var5 . assign the values ( var2 * ( var0 % var1 ) ) + var4 , var3 * ( var0 % var1 ) to var6 and var7 , respectively . if var6 does not exceed var7 then add var6 to var5 . otherwise , add var7 to var5 . return var5 . 
given integers var0 , var1 , var2 , var3 , var4 . assign $$CONSTANT$$ * $$CONSTANT$$ to var5 . if var1 is not less than var0 then return d * $$CONSTANT$$ . assign the values ( var2 * var1 ) + var4 , b * $$CONSTANT$$ to var6 and var7 , respectively . if var6 does not exceed var7 then add ( ( var0 - var1 ) / var1 ) * var6 to var5 . otherwise , add ( ( var0 - var1 ) / var1 ) * var7 to var5 . assign the values ( var2 * ( var0 % var1 ) ) + var4 , var3 * ( var0 % var1 ) to var6 and var7 , respectively . if var6 does not exceed var7 then add var6 to var5 . otherwise , add var7 to var5 . 
you are given $$CONSTANT$$ number var0 . you have to set var1 to 1 , var2 to 1 and var3 to 2 . while var3 is less than var0 you have to set var4 to var2 + var3 , you have to set var2 to var3 , you have to set var3 to var4 and you have to add 1 to var1 . 
given integer arrays var0 , var1 , var2 . create 0 - based integer matrix var6 at first $$CONSTANT$$ containing the array var1 and at second $$CONSTANT$$ containing var2 with all values being decreased by 1 . assign 0 to var8 . for each var13 from 0 to $$CONSTANT$$ - 1 , do following operations . assign 0 to var10 . for each var5 from var9 to $$CONSTANT$$ - 1 , initialize var12 to the sum of all values var0 [ var13 ] whre var13 is from var6 [ var11 ] [ 0 ] to var6 [ var11 ] [ 1 ] and assign the larger of sum + total and var10 to var10 . when var5 becomes equal to var4 , assign the larger of var10 and var8 to var8 . when var9 becomes equal to var4 , return var8 . 
given integers var0 , var1 , var2 . assign 0 to result . if var0 is not less than var1 and var2 then if var0 equals var1 then result is the larger of b - 1 - $$CONSTANT$$ and 0 . otherwise , if var0 equals var2 then result is the larger of b - d - 1 and 0 . otherwise , result is the sum of two values where first value is the larger of b - 1 - d and 0 , second value is the larger of b - 1 - $$CONSTANT$$ and 0 . if var0 was less than var1 or var2 then if var2 is not larger than var0 or var2 is less than var1 then result is the sum of two values where first value is the larger of d - b - 1 and 0 , second value is the larger of d - $$CONSTANT$$ - 1 and 0 . otherwise , if var2 equals var1 then result is the larger of $$CONSTANT$$ - 1 - b and 0 . otherwise , result is the sum of two values where first value is the larger of $$CONSTANT$$ - 1 - b and 0 , second value is the larger of $$CONSTANT$$ - 1 - d and 0 . return the result . 
given integers var0 , var1 , var2 . assign 0 to result . if var0 is not less than var1 and var2 then if var0 equals var1 then result is the larger of b - 1 - $$CONSTANT$$ and 0 . otherwise , if var0 equals var2 then result is the larger of b - d - 1 and 0 . otherwise , result is the sum of two values where first value is the larger of b - 1 - d and 0 , second value is the larger of b - 1 - $$CONSTANT$$ and 0 . if var0 was less than var1 or var2 then if var2 is not larger than var0 or var2 is less than var1 then result is the sum of two values where first value is the larger of d - b - 1 and 0 , second value is the larger of d - $$CONSTANT$$ - 1 and 0 . otherwise , if var2 equals var1 then result is the larger of $$CONSTANT$$ - 1 - b and 0 . otherwise , result is the sum of two values where first value is the larger of $$CONSTANT$$ - 1 - b and 0 , second value is the larger of $$CONSTANT$$ - 1 - d and 0 . 
given $$CONSTANT$$ 0 - based integer array var0 . if the first elemment of var0 is equals to 0 or the last 2 elements of var0 is in strictly increasing $$CONSTANT$$ , return $$CONSTANT$$ string array which contains only 1 element " UP " . if length of the array var0 is 1 , return $$CONSTANT$$ string array which contains only 1 element " - 1 " . otherwise , return $$CONSTANT$$ string array which contains only 1 element " DOWN " . 
given $$CONSTANT$$ 0 - based integer array var0 . if the last elemment of var0 is equals to 15 , return $$CONSTANT$$ string array which contains only 1 element " DOWN " . if the first elemment of var0 is equals to 0 or the last 2 elements of var0 is in strictly increasing $$CONSTANT$$ , return $$CONSTANT$$ string array which contains only 1 element " UP " . if length of the array var0 is 1 , return $$CONSTANT$$ string array which contains only 1 element " - 1 " . 
given $$CONSTANT$$ 0 - based integer array var0 . if the last elemment of var0 is equals to 15 , return $$CONSTANT$$ string array which contains only 1 element " DOWN " . if the first elemment of var0 is equals to 0 , return $$CONSTANT$$ string array which contains only 1 element " UP " . if length of the array var0 is 1 , return $$CONSTANT$$ string array which contains only 1 element " - 1 " . 
given $$CONSTANT$$ 0 - based integer array var0 . if the last elemment of var0 is equals to 15 , return $$CONSTANT$$ string array which contains only 1 element " DOWN " . if the first elemment of var0 is equals to 0 , return $$CONSTANT$$ string array which contains only 1 element " UP " . 
given $$CONSTANT$$ 0 - based integer array var0 . if the last elemment of var0 is equals to 15 , return $$CONSTANT$$ string array which contains only 1 element " DOWN " . 
you are given an array var0 of integer type . if at least one character from var0 is in the range from 0 to 15 , not inclusive then return - 1 . otherwise , let var3 be the last character in var0 and var1 be the length of var0 . if var1 is less than 2 and var3 does not equal 0 nor 15 then return - 1 . otherwise , if var3 equals 0 then return " UP " . otherwise , if the character standing before var3 in var0 is larger than var3 or var3 equals 15 then return " DOWN " . otherwise , return " UP " . 
you are given an array var0 of integer type . if at least one character from var0 is in the range from 0 to 15 , not inclusive then return - 1 . otherwise , let var3 be the last character in var0 and var1 be the length of var0 . if var1 is less than 2 and var3 does not equal 0 nor 15 then return - 1 . 
you are given an array var0 of integer type . if at least one character from var0 is in the range from 0 to 15 , not inclusive then return - 1 . otherwise , let var3 be the last character in var0 . 
you are given an array var0 of integer type . assign var3 to var2 . if var0 [ var4 ] is in the range from 0 to 15 , not inclusive then return - 1 . 
given integers var0 , var1 , var2 , var3 , var4 . assign $$CONSTANT$$ * $$CONSTANT$$ to var5 . if var1 is not less than var0 then return d * $$CONSTANT$$ . assign the values ( var2 * var1 ) + var4 , b * $$CONSTANT$$ to var6 and var7 , respectively . if var6 does not exceed var7 then add ( ( var0 - var1 ) / var1 ) * var6 to var5 . otherwise , add ( ( var0 - var1 ) / var1 ) * var7 to var5 . assign the values ( var2 * ( var0 % var1 ) ) + var4 , var3 * ( var0 % var1 ) to var6 and var7 , respectively . 
given integers var0 , var1 , var2 , var3 , var4 . assign $$CONSTANT$$ * $$CONSTANT$$ to var5 . if var1 is not less than var0 then return d * $$CONSTANT$$ . assign the values ( var2 * var1 ) + var4 , b * $$CONSTANT$$ to var6 and var7 , respectively . if var6 does not exceed var7 then add ( ( var0 - var1 ) / var1 ) * var6 to var5 . otherwise , add ( ( var0 - var1 ) / var1 ) * var7 to var5 . 
given integers var0 , var1 , var2 , var3 , var4 . assign $$CONSTANT$$ * $$CONSTANT$$ to var5 . if var1 is not less than var0 then return d * $$CONSTANT$$ . assign the values ( var2 * var1 ) + var4 , b * $$CONSTANT$$ to var6 and var7 , respectively . 
you are given an array var0 of integer type . if at least one character from var0 is in the range from 0 to 15 , not inclusive then return - 1 . otherwise , let var3 be the last character in var0 and var1 be the length of var0 . if var1 is less than 2 and var3 does not equal 0 nor 15 then return - 1 . otherwise , if var3 equals 0 then return " UP " . otherwise , if the character standing before var3 in var0 is larger than var3 or var3 equals 15 then return " DOWN " . otherwise , return " UP " . 
given integers var0 , var1 , var2 , var3 , var4 . assign $$CONSTANT$$ * $$CONSTANT$$ to var5 . if var1 is not less than var0 then return d * $$CONSTANT$$ . 
given 0 - based array var0 of integer type . assign the sorted version of var0 to var2 . let var5 be the number of elements in var2 with positions var3 which are not less than the sum of all elements in beginning subarray of var2 which ends at $$CONSTANT$$ - 1 . 
given 0 - based array var0 of integer type . assign the sorted version of var0 to var2 . 
given 0 - based array var0 of integer type . assign var0 to var2 . 
given an array var0 , iterate over its elements in sorted $$CONSTANT$$ and maintain two variables var5 and var4 initially set to zero . on each iteration if the current element is larger or equals to var4 , increment var5 and add the current element to var4 . 
given an array var0 , create $$CONSTANT$$ new array var2 that is $$CONSTANT$$ sorted $$CONSTANT$$ of var0 . 
given an array var0 , create $$CONSTANT$$ new array var2 that is $$CONSTANT$$ $$CONSTANT$$ of var0 . 
given 0 - based array var0 of integer type . assign the sorted version of var0 to var2 . return the number of elements in var2 with positions var3 which are not less than the sum of all elements in beginning subarray of var2 which ends at $$CONSTANT$$ - 1 . 
given an array var0 , iterate over its elements in sorted $$CONSTANT$$ and maintain two variables var5 and var4 initially set to zero . on each iteration if the current element is larger or equals to var4 , increment var5 and add the current element to var4 . return var5 . 
you are given an integer var1 , and an integer var2 . set the value of var6 to 0 . create an array var5 of size 3 , and $$CONSTANT$$ it with the value var2 . then , repeat the following as long as all the numbers in var5 are smaller than var1 : set the value of the $$CONSTANT$$ number in var5 to the sum of the other two numbers minus 1 , and increase the value of var6 by 1 . 
you are given an array of integers var5 and an integer var3 . return false if the there is $$CONSTANT$$ number in var5 which is smaller than var3 . 
you are given an array var0 of char type . let var1 be the number of characters $$CONSTANT$$ in var0 decremented by the number of characters r in var0 and var2 is the number of character u in var0 decremented by the number of characters d in var0 . 
you are given an integer var1 , and an integer var2 . set the value of var6 to 0 . create an array var5 of size 3 , and $$CONSTANT$$ it with the value var2 . then , repeat the following as long as all the numbers in var5 are smaller than var1 : set the value of the $$CONSTANT$$ number in var5 to the sum of the other two numbers minus 1 , and increase the value of var6 by 1 . return var6 . 
you are given an array var0 of char type . let var1 be the number of characters $$CONSTANT$$ in var0 decremented by the number of characters r in var0 and var2 is the number of character u in var0 decremented by the number of characters d in var0 . if the sum of var1 and var2 is even number then return their sum divided by 2 . otherwise , return - 1 . 
you are given an integer var0 and 0 - based array var1 of char type . let var4 be the number of positions in var1 containing the value $$CONSTANT$$ , decreased by the number of positions containing $$CONSTANT$$ , and var3 be the number of positions in var1 containing the value $$CONSTANT$$ , decreased by the number of positions containing 68 . 
you are given an integer var0 and 0 - based array var1 of char type . let var4 be the number of positions in var1 containing the value $$CONSTANT$$ , decreased by the number of positions containing $$CONSTANT$$ , and var3 be the number of positions in var1 containing the value $$CONSTANT$$ , decreased by the number of positions containing 68 . 
you are given an integer var0 and 0 - based array var1 of char type . let var4 be the number of positions in var1 containing the value $$CONSTANT$$ , decreased by the number of positions containing $$CONSTANT$$ , and var3 be the number of positions in var1 containing the value $$CONSTANT$$ , decreased by the number of positions containing 68 . return the half of sum of var4 and var3 , both taken by module . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 . you have to store in var4 the minimum among var0 , var1 and var2 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 . you have to return the minimum among var0 , var1 and var2 . 
given integers var0 , var1 , var2 , var3 , var4 , var5 , var6 , var7 . set var8 to product of var2 and var1 . set var9 to product of var3 and var4 . set var10 to product of var0 and var6 . set var11 to product of var0 and var7 . while var8 is not smaller than var10 and var9 is not smaller than var0 and var7 is not smaller than var11 , increment var12 , decrease var8 by var10 , decrease var9 by var0 and decrease var5 by var11 . 
given integers var0 , var1 , var2 , var3 , var4 , var5 , var6 , var7 . set var8 to product of var2 and var1 . set var9 to product of var3 and var4 . set var10 to product of var0 and var6 . set var11 to product of var0 and var7 . while var8 is not smaller than var10 and var9 is not smaller than var0 and var7 is not smaller than var11 , increment var12 , decrease var8 by var10 , decrease var9 by var0 and decrease var5 by var11 . after finishing iteration return var12 . 
you are given $$CONSTANT$$ string var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var3 , $$CONSTANT$$ number var4 . for each position var6 in var0 , if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var1 , otherwise if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var2 , otherwise if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var3 , otherwise if var0 [ var6 ] si equal to " $$CONSTANT$$ " add 1 to var4 . 
given $$CONSTANT$$ string var0 you need to find differences between apperances symbols with codes $$CONSTANT$$ and $$CONSTANT$$ and symbols with codes 86 and 68 
you are given an array var0 of char type . create an array var1 of size 4 ( 0 - based ) , where var1 [ 0 ] equals to the number of occurences of $$CONSTANT$$ in var0 , var1 [ 1 ] equal to the number of occurences of 68 in var0 , var1 [ 2 ] equals to the number of occurences of $$CONSTANT$$ in $$CONSTANT$$ and var1 [ 3 ] equals to the number of occurences of $$CONSTANT$$ in var0 . after the loop is ended , let var3 be the sum of module of var1 [ 0 ] - var1 [ 1 ] and the module of var1 [ 2 ] - var1 [ 3 ] . 
you are given an array var0 of char type . create an array var1 of size 4 ( 0 - based ) , where var1 [ 0 ] equals to the number of occurences of $$CONSTANT$$ in var0 , var1 [ 1 ] equal to the number of occurences of 68 in var0 , var1 [ 2 ] equals to the number of occurences of $$CONSTANT$$ in $$CONSTANT$$ and var1 [ 3 ] equals to the number of occurences of $$CONSTANT$$ in var0 . 
you are given an array var0 of char type . create an array var1 of size 4 ( 0 - based ) , where var1 [ 0 ] equals to the number of occurences of $$CONSTANT$$ in var0 , var1 [ 1 ] equal to the number of occurences of 68 in var0 , var1 [ 2 ] equals to the number of occurences of $$CONSTANT$$ in $$CONSTANT$$ and var1 [ 3 ] equals to the number of occurences of $$CONSTANT$$ in var0 . after the loop is ended , let var3 be the sum of module of var1 [ 0 ] - var1 [ 1 ] and the module of var1 [ 2 ] - var1 [ 3 ] . if var3 is even number then return x / 2 . otherwise , return - 1 . 
given integers var1 , var2 , var5 , var3 , var4 , var0 , var6 and var7 , initialize var8 as var1 * var2 , var9 as var5 , var11 as 0 and t1 as var3 * var4 . while var8 > = var6 and var10 > 0 and var9 > = var7 , add one to var11 , subtract one from var10 , var6 from var8 and var7 from var9 . then , while var11 is not divisible by var0 , subtract one from var11 . 
given integers var1 , var2 , var5 , var3 , var4 , var0 , var6 and var7 , initialize var8 as var1 * var2 , var9 as var5 , var11 as 0 and t1 as var3 * var4 . while var8 > = var6 and var10 > 0 and var9 > = var7 , add one to var11 , subtract one from var10 , var6 from var8 and var7 from var9 . then , while var11 is not divisible by var0 , subtract one from var11 . return the final value of var11 divided by var0 . 
given integers var1 , var2 , var5 , var3 , var4 . initialize var8 as var1 * var2 , var9 as var5 , var11 as 0 and t1 as var3 * var4 . while var8 > = var6 and var10 > 0 and var9 > = var7 , add one to var11 , subtract one from var10 , var6 from var8 and var7 from var9 . 
you are given $$CONSTANT$$ number var0 . you have to create an array of numbers var1 of length $$CONSTANT$$ . you have to set var1 [ 1 ] to 2 and var1 [ 2 ] to 3 . for each var2 between 3 and $$CONSTANT$$ you have to set var1 [ var2 ] to var1 [ var2 - 1 ] + var1 [ $$CONSTANT$$ - 2 ] . 
you are given $$CONSTANT$$ number var0 . you have to set var1 to zero , var2 to 1 , var3 to 1 , var4 to 1 and var5 to zero . while var4 is less than var0 you have to set var3 to var1 + var2 , set var1 to var2 , set var2 to var3 , add var2 to var4 , and add 1 to var5 . 
you are given the numbers var0 , var1 , var2 . you have to store in array of numbers var3 the numbers var0 , var1 , and var2 . you have to sort var3 . set var4 to var3 [ 2 ] - var3 [ 0 ] and var5 to var3 [ 2 ] - var3 [ 1 ] . if var4 is greater than zero subtract 1 to var4 . if var5 is greater than zero subtract 1 to var5 . 
you are given the numbers var0 , var1 , var2 . you have to store in array of numbers var3 the numbers var0 , var1 , and var2 . you have to sort var3 . set var4 to var3 [ 2 ] - var3 [ 0 ] and var5 to var3 [ 2 ] - var3 [ 1 ] . if var4 is greater than zero subtract 1 to var4 . if var5 is greater than zero subtract 1 to var5 . you have to return var4 + var5 . 
you are given the numbers var0 , var1 , var2 . you have to store in array of numbers var3 the numbers var0 , var1 , and var2 . you have to sort var3 . set var4 to var3 [ 2 ] - var3 [ 0 ] and var5 to var3 [ 2 ] - var3 [ 1 ] . if var4 is greater than zero subtract 1 to var4 . 
given $$CONSTANT$$ string var0 you need to find differences between apperances symbols with codes $$CONSTANT$$ and $$CONSTANT$$ and symbols with codes 86 and 68 you need to sum these differences if thus sum is even return this sum / 2 else return - 1 
given an array of non - negative integers var0 , replace each positive even element with the value 1 and each odd element with the value 0 if and only if the previous element is odd . also check for the existence of 0 value $$CONSTANT$$ after $$CONSTANT$$ odd integer . 
you are given $$CONSTANT$$ number var0 . you have to set var1 to zero , var2 to 1 , var3 to 1 , var4 to 1 and var5 to zero . while var4 is less than var0 you have to set var3 to var1 + var2 , set var1 to var2 , set var2 to var3 , add var2 to var4 , and add 1 to var5 . you have to return var5 . 
given an array of integers var0 . set the value of var4 to true . for every position var2 in $$CONSTANT$$ from 1 to ( | var0 | - 1 ) , subtract 1 from var0 [ var2 ] if var0 [ var2 - 1 ] is odd . set the value of var4 to false if there is $$CONSTANT$$ negative value in var0 . set the value of var4 to false if var0 [ | var0 | - 1 ] is odd . 
given an array of integers var0 . set the value of var4 to true . for every position var2 in $$CONSTANT$$ from 1 to ( | var0 | - 1 ) , subtract 1 from var0 [ var2 ] if var0 [ var2 - 1 ] is odd . set the value of var4 to false if there is $$CONSTANT$$ negative value in var0 . 
given an array of integers var0 , an integer var5 , an integer var3 , and $$CONSTANT$$ boolean var4 . subtract 1 from var0 [ var5 ] if var3 is not equal to 0 . set the value of var4 to false and break from the enclosing loop if var0 [ var5 ] is $$CONSTANT$$ negative value . set the value of var3 to ( var0 [ var5 ] modulo 2 ) . 
given an array of integers var0 , an integer var5 , an integer var3 , and $$CONSTANT$$ boolean var4 . subtract 1 from var0 [ var5 ] if var3 is not equal to 0 . set the value of var4 to false and break from the enclosing loop if var0 [ var5 ] is $$CONSTANT$$ negative value . 
given an array of non - negative integers var0 , replace each positive even element with the value 1 and each odd element with the value 0 if and only if the previous element is odd . also check for the existence of 0 value $$CONSTANT$$ after $$CONSTANT$$ odd integer and store it . if $$CONSTANT$$ position having 0 value is $$CONSTANT$$ after an odd integer or if the last element is odd return " NO " . otherwise , return " YES " . 
given an array of integers var0 . set the value of var4 to true . for every position var2 in $$CONSTANT$$ from 1 to ( | var0 | - 1 ) , subtract 1 from var0 [ var2 ] if var0 [ var2 - 1 ] is odd . set the value of var4 to false if there is $$CONSTANT$$ negative value in var0 . set the value of var4 to false if var0 [ | var0 | - 1 ] is odd . return " YES " if var4 is equal to true , return false otherwise . 
given arrays var1 , var2 , var3 of integer types . assign 0 to var16 , var15 . let var4 and var5 be the lengths of var1 and var2 , respectively . create an array var7 of size var5 and of integer type . for all var8 $$CONSTANT$$ from 0 to var8 < var5 do follwoing operations . let var9 and var10 be the next values in var2 and var3 , respectively , both decremented by 1 . let var11 [ var8 ] be the sum of values in var1 in the range from var9 to var10 , inclusive . after the loop is ended , sort the array var7 . let var13 be the sum of positive characters in var7 . 
given arrays var1 , var2 , var3 of integer types . assign 0 to var16 , var15 . let var4 and var5 be the lengths of var1 and var2 , respectively . create an array var7 of size var5 and of integer type . for all var8 $$CONSTANT$$ from 0 to var8 < var5 do follwoing operations . let var9 and var10 be the next values in var2 and var3 , respectively , both decremented by 1 . let var11 [ var8 ] be the sum of values in var1 in the range from var9 to var10 , inclusive . after the loop is ended , sort the array var7 . 
given strings var0 and var1 . initialize var3 to 0 and var4 to true . iterate over var0 from begin to end and for each character if var3 is less than the length of var1 and current character equals to var1 [ var3 ] increase var3 by one , otherwise if current character equals to $$CONSTANT$$ or $$CONSTANT$$ then make var4 equal to false and stop iterating . return true if flag equals to true and var3 is greater or equal to the length of var1 , and false otherwise . 
given arrays var1 , var2 , var3 of integer types . assign 0 to var16 , var15 . let var4 and var5 be the lengths of var1 and var2 , respectively . create an array var7 of size var5 and of integer type . for all var8 $$CONSTANT$$ from 0 to var8 < var5 do follwoing operations . let var9 and var10 be the next values in var2 and var3 , respectively , both decremented by 1 . let var11 [ var8 ] be the sum of values in var1 in the range from var9 to var10 , inclusive . 
given arrays var1 , var2 , var3 of integer types . let var9 and var10 be the next values in var2 and var3 , respectively , both decremented by 1 . let var11 [ var8 ] be the sum of values in var1 in the range from var9 to var10 , inclusive . 
given arrays var1 , var2 , var3 of integer types . let var9 and var10 be the next values in var2 and var3 , respectively , both decremented by 1 . let var11 be the sum of values in var1 in the range from var9 to var10 , inclusive . 
given the value of var0 , set the value of var1 to the $$CONSTANT$$ value such that var1 - th fibonacci number is smaller than or equal to var0 . 
you are given an array of numbers var0 . you have to set var1 to the length of var0 . if var1 is equal to 1 , if var0 [ 0 ] is equal to 15 you have to return " DOWN " , if var0 [ 0 ] is equal to zero you have to return " UP " otherwise you have to return " - 1 " , otherwise if var0 [ var1 - 1 ] is greater than var0 [ var1 - 2 ] , if var0 [ var1 - 1 ] is equal to 15 you have to return " DOWN " otherwise you have to return " UP " , otherwise if var0 [ var1 - 1 ] is equal to zero you have to return " UP " otherwise you have to return " DOWN " . 
given the value of var0 , set the value of var1 to the $$CONSTANT$$ value such that var1 - th fibonacci number is smaller than or equal to var0 . return var1 . 
given integers var0 and var1 , set var2 , var3 and var4 to var1 , set var5 and var6 to 0 . repeat the following actions until var2 = var3 and var3 = var4 and var2 = var0 : increase var5 by 1 and set var2 to the minimum of var3 + var4 - 1 and var0 if var6 % 3 = 0 and var2 ! = var0 , set var3 to minimum of var2 + var4 - 1 and var0 and increase var5 by 1 if var6 % 3 = 1 and var3 ! = var0 , set var4 to minimum of var2 + var3 - 1 and var0 and increase var5 by 1 if var6 % 3 = 2 and var4 ! = var0 , after this increase var6 by 1 . 
you are given an array of integers var0 . initialize var1 to the length of array var0 . if var1 is equal to 1 : ( if var0 [ 0 ] is equal to 15 return " DOWN " , if var0 [ 0 ] is equal to 0 return " UP " , otherwise return " - 1 " ) else if var0 [ var1 - 2 ] < var0 [ var1 - 1 ] < 15 return " UP " else if var0 [ var1 - 2 ] < var0 [ var1 - 1 ] and var0 [ var1 - 1 ] is equal to 15 , return " DOWN " else if var0 [ var1 - 2 ] > var0 [ var1 - 1 ] and var0 [ var1 - 1 ] is equal to zero return " UP " , else return " DOWN " . 
given integers var0 and var1 , set var2 , var3 and var4 to var1 , set var5 and var6 to 0 . repeat the following actions until var2 = var3 and var3 = var4 and var2 = var0 : increase var5 by 1 and set var2 to the minimum of var3 + var4 - 1 and var0 if var6 % 3 = 0 and var2 ! = var0 , set var3 to minimum of var2 + var4 - 1 and var0 and increase var5 by 1 if var6 % 3 = 1 and var3 ! = var0 , set var4 to minimum of var2 + var3 - 1 and var0 and increase var5 by 1 if var6 % 3 = 2 and var4 ! = var0 , after this increase var6 by 1 . return var5 . 
given arrays var1 , var2 , var3 of integer types . assign 0 to var16 , var15 . let var4 and var5 be the lengths of var1 and var2 , respectively . create an array var7 of size var5 and of integer type . for all var8 $$CONSTANT$$ from 0 to var8 < var5 do follwoing operations . let var9 and var10 be the next values in var2 and var3 , respectively , both decremented by 1 . let var11 [ var8 ] be the sum of values in var1 in the range from var9 to var10 , inclusive . after the loop is ended , sort the array var7 . return the sum of positive characters in var7 . 
given integer var0 and an array var1 of char type . initialize var3 to the number of occurences of $$CONSTANT$$ in var1 , var4 to the number of occurences of $$CONSTANT$$ in var1 , var5 - the number of occurences of $$CONSTANT$$ in var1 and var6 - the number of occurences of other characters in var1 . 
given char typed array var0 . let var2 be the number of appearances of value $$CONSTANT$$ in var0 minus the number of appearances of $$CONSTANT$$ in var0 and let var3 be the number of appearances of value $$CONSTANT$$ in var0 minus the number of appearances of 68 in var0 . 
given char typed array var0 . if var0 [ var4 ] equals $$CONSTANT$$ then add 1 to var3 or if it equals 68 then substract 1 from var3 . if var0 [ var4 ] equals $$CONSTANT$$ then add 1 to var2 or if it equals $$CONSTANT$$ then substract 1 from var2 . 
given char typed array var0 . if var0 [ var4 ] equals $$CONSTANT$$ then add 1 to var3 or if it equals 68 then substract 1 from var3 . if var0 [ var4 ] equals $$CONSTANT$$ then add 1 to var2 . 
given char typed array var0 . if var0 [ var4 ] equals $$CONSTANT$$ then add 1 to var3 or if it equals 68 then substract 1 from var3 . 
given char typed array var0 . let var2 be the number of appearances of value $$CONSTANT$$ in var0 minus the number of appearances of $$CONSTANT$$ in var0 and let var3 be the number of appearances of value $$CONSTANT$$ in var0 minus the number of appearances of 68 in var0 . return the half of sum of modules of var2 and var3 . 
given integers var2 , var3 , var4 , var0 , var5 and var6 , increase var5 by 1 and set var2 to the minimum of var3 + var4 - 1 and var0 if var6 % 3 = 0 and var2 ! = var0 , set var3 to minimum of var2 + var4 - 1 and var0 and increase var5 by 1 if var6 % 3 = 1 and var3 ! = var0 , set var4 to minimum of var2 + var3 - 1 and var0 and increase var5 by 1 if var6 % 3 = 2 and var4 ! = var0 , after this increase var6 by 1 . 
you are given $$CONSTANT$$ string var0 . set the value of var2 to the number of characters ' $$CONSTANT$$ ' is var0 . set the value of r to the number of characters ' r ' is var0 . set the value of var4 to the number of characters ' u ' is var0 . set the value of var5 to the number of characters ' d ' is var0 . subtract the minimum between var3 and var2 from both var2 and var3 . subtract the minimum between var4 and var5 from both var4 and var5 . 
you are given $$CONSTANT$$ string var0 . set the value of var2 to the number of characters ' $$CONSTANT$$ ' is var0 . set the value of r to the number of characters ' r ' is var0 . set the value of var4 to the number of characters ' u ' is var0 . set the value of var5 to the number of characters ' d ' is var0 . 
given integer var0 and an array var1 of char type . initialize var3 to the number of occurences of $$CONSTANT$$ in var1 , var4 to the number of occurences of $$CONSTANT$$ in var1 , var5 - the number of occurences of $$CONSTANT$$ in var1 and var6 - the number of occurences of other characters in var1 . if the values var4 - var3 and var5 - var6 are both even numbers then return the sum of values var4 - var3 and var5 - var6 taken by module and divided by 2 . otherwise , if the values var4 - var3 and var5 - var6 are both odd numbers then return the incremented value of sum by 1 , of values var4 - var3 and var5 - var6 taken by module and divided by 2 . otherwise , return - 1 . 
given an array var0 . initialize var6 to an empty array and var2 to 0 . for each var4 in var0 , add var4 - 1 to var2 and if var2 is odd , push 1 into var6 ; else push 2 into var6 . 
given arrays var0 , var6 and integers var5 , var2 . add var0 [ var5 ] - 1 to var2 . if var2 is odd , push 1 into var6 ; else push 2 into var6 . 
given an array var0 . initialize var6 to an empty array and var2 to 0 . for each var4 in var0 , add var4 - 1 to var2 and if var2 is odd , push 1 into var6 ; else push 2 into var6 . return var6 . 
given integer var0 and integer arrays var1 , var2 . let var5 be the sum of all elements of var1 . create integer array var4 of size var3 at var6 th position containing the value var2 [ var6 ] - $$CONSTANT$$ [ var6 ] . sort var4 . 
given integer var0 and integer arrays var1 , var2 . let var5 be the sum of all elements of var1 . create integer array var4 of size var3 at var6 th position containing the value var2 [ var6 ] - $$CONSTANT$$ [ var6 ] . 
given integer var0 and integer arrays var1 , var2 . create integer array var4 of size var3 . let var5 be the sum of all elements of var1 . 
given integer var0 and integer arrays var1 , var2 . create integer array var4 of size var3 . let var5 be the sum of all elements of var1 . 
given arrays var0 , var1 . initialize var2 to the length of var0 , var3 to the sum of elements of var0 , var4 to the sum of elements of var1 . 
given arrays var0 , var1 . initialize var2 to the length of var0 , var3 to the sum of elements of var0 , var4 to the sum of elements of var1 . return the sum of the minimum between var3 , var2 - var3 and the minimum between var4 , var2 - var4 . 
you are given an array of strings var2 and $$CONSTANT$$ string var1 . store in var6 the number of strings in var2 in such $$CONSTANT$$ way when you split it by " - > " at least one of the two resulting strings is equal to var1 . 
you are given an array of strings var2 , $$CONSTANT$$ string var5 , $$CONSTANT$$ number var6 and $$CONSTANT$$ number var3 . you have to set string var8 to var2 [ var3 ] and you have to add 1 to var3 . you have to store in array of strings var9 all strings in var8 separated by " - > " . if the first string in var9 is equal to var5 or the second string in var9 is equal to var5 you have to add 1 to var6 . 
given integer var0 and char array var1 . create integer arrays var2 , var3 . for each var4 from 0 to n - 1 , if var1 [ var4 ] equals 68 then add var4 to the end of var3 , or in othe case , add var4 to the end of var2 . while both var2 and var3 are not empty do following operations . let var5 and var6 be the first values in var2 , var3 and remove these first values from arrays . if var5 is less than var6 then add to the end of var2 the value r + n , or in other case add to the end of var3 the value d + n . 
you are given an array of strings var2 and $$CONSTANT$$ string var1 . store in var6 the number of strings in var2 in such $$CONSTANT$$ way when you split it by " - > " at least one of the two resulting strings is equal to var1 . you have to return " $$CONSTANT$$ " if var6 is divisible by 2 , and " $$CONSTANT$$ " otherwise . 
given an array of integers var0 . store last element of the var0 to var3 , and store one before the last element to var2 . 
given 0 - based array var0 of integer type . assign the length of var0 to var1 . if var1 is less than or equal to 2 and var0 [ n - 1 ] equals 15 or if var0 [ n - 1 ] equals 15 then return " DOWN " . otherwise , if var1 does not exceed 2 and var0 [ n - 1 ] equals 0 or if var0 [ n - 1 ] equals 0 then return " UP " . otherwise , if var0 consists of less than 2 elements then return " - 1 " . otherwise , if var0 [ n - 2 ] exceeds var0 [ n - 1 ] or var0 [ n - 1 ] equals 15 then return " DOWN " . otherwise , if var0 [ n - 1 ] exceeds var0 [ n - 2 ] or var0 [ n - 1 ] equals 0 then return " UP " . 
given 0 - based array var0 of integer type . assign the length of var0 to var1 . if var1 is less than or equal to 2 and var0 [ n - 1 ] equals 15 or if var0 [ n - 1 ] equals 15 then return " DOWN " . otherwise , if var1 does not exceed 2 and var0 [ n - 1 ] equals 0 or if var0 [ n - 1 ] equals 0 then return " UP " . otherwise , if var0 consists of less than 2 elements then return " - 1 " . otherwise , if var0 [ n - 2 ] exceeds var0 [ n - 1 ] or var0 [ n - 1 ] equals 15 then return " DOWN " . otherwise , if var0 [ n - 1 ] exceeds var0 [ n - 2 ] or var0 [ n - 1 ] equals 0 then return " UP " . 
given 0 - based array var0 of integer type . if var0 [ n - 2 ] exceeds var0 [ n - 1 ] or var0 [ n - 1 ] equals 15 then return " DOWN " . otherwise , if var0 [ n - 1 ] exceeds var0 [ n - 2 ] or var0 [ n - 1 ] equals 0 then return " UP " . 
given integer var0 and char array var1 . create integer arrays var2 , var3 . for each var4 from 0 to n - 1 , if var1 [ var4 ] equals 68 then add var4 to the end of var3 , or in othe case , add var4 to the end of var2 . while both var2 and var3 are not empty do following operations . let var5 and var6 be the first values in var2 , var3 and remove these first values from arrays . if var5 is less than var6 then add to the end of var2 the value r + n , or in other case add to the end of var3 the value d + n . when the loop is ended , if var2 is not empty then return " $$CONSTANT$$ " . otherwise , return " $$CONSTANT$$ " . 
given integers var0 and var1 , initialize var2 to array of integers of length 3 , set each element of var2 to var1 and initialize var3 to 0 . repeat the following cycle : set var2 [ 0 ] to var2 [ 1 ] + var2 [ 2 ] - 1 , sort the array var2 in non - decreasing $$CONSTANT$$ and increase var3 by 1 , break from the cycle if var2 [ 0 ] > = var0 . 
given an array of integers var2 and integers var0 and var3 , set var2 [ 0 ] to var2 [ 1 ] + var2 [ 2 ] - 1 , sort the array var2 in non - decreasing $$CONSTANT$$ and increase var3 by 1 , break from the enclosing loop if var2 [ 0 ] > = var0 . 
given an array of integers var0 . store last element of the var0 to var3 , and store one before the last element to var2 . if var3 is equal to zero return string " UP " . otherwise , if var3 is equal to 15 return " DOWN " . otherwise , if length of the array is equal to 1 , return " - 1 " . otherwise if ( var3 - var2 ) is greater than 0 return " DOWN " . otherwise , if ( var2 - var3 ) is equal to 0 , return " - 1 " . 
given integers var0 and var1 , initialize var2 to array of integers of length 3 , set each element of var2 to var1 and initialize var3 to 0 . repeat the following cycle : set var2 [ 0 ] to var2 [ 1 ] + var2 [ 2 ] - 1 , sort the array var2 in non - decreasing $$CONSTANT$$ and increase var3 by 1 , break from the cycle if var2 [ 0 ] > = var0 . return var3 . 
given integers var0 , var1 . add to var2 the value $$CONSTANT$$ - n . if var2 equals 1 then add it to var3 . otherwise , add to var3 the value last + 1 and add 2 to var4 . 
given integers var0 , var1 . create char typed matrix var6 . if var1 exceeds n / 2 then update it by n - $$CONSTANT$$ . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of numbers var4 of the length of var0 . you have to set var3 to zero . for each position var1 in var0 , set var5 to var0 [ var1 ] , add var5 - 1 to var3 , if var3 is divisible by 2 set var4 [ var1 ] to 2 and var3 to zero , otherwise set var4 [ var1 ] to 1 . you have to return var4 . 
given an integer var0 and $$CONSTANT$$ string var1 . initialize var2 to the indices of all entries of ' d ' in var1 , var3 to the indices of all entries of ' r ' in var1 . while the sizes of var2 and var3 are greater than 0 , if first of element of var2 is less than the first element of var3 , push var0 into var2 ; else push var0 into var3 . increase var0 by 1 . delete first elements from both var2 and var3 . 
given an integer var0 and $$CONSTANT$$ string var1 . initialize var2 to the indices of all entries of ' d ' in var1 , var3 to the indices of all entries of ' r ' in var1 . 
given an integer var0 and two arrays var2 , var3 . if first of element of var2 is less than the first element of var3 , push var0 into var2 ; else push var0 into var3 . increase var0 by 1 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of numbers var7 initially empty . you have to create an array of numbers var4 of the length of var0 . you have to set var3 to zero . for each position var1 in var0 , set var5 to var0 [ var1 ] , add var5 - 1 to var3 , if var3 is divisible by 2 set var4 [ var1 ] to 2 and var3 to zero , otherwise set var4 [ var1 ] to 1 . you have to store in var7 all elements in var4 . 
given an integer var0 and $$CONSTANT$$ string var1 . initialize var2 to the indices of all entries of ' d ' in var1 , var3 to the indices of all entries of ' r ' in var1 . while the sizes of var2 and var3 are greater than 0 , if first of element of var2 is less than the first element of var3 , push var0 into var2 ; else push var0 into var3 . increase var0 by 1 . delete first elements from both var2 and var3 . if length of var2 equals 0 , return " $$CONSTANT$$ " ; else return " $$CONSTANT$$ " . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of numbers var4 of the length of var0 . you have to set var3 to zero . for each position var1 in var0 , set var5 to var0 [ var1 ] , add var5 - 1 to var3 , if var3 is divisible by 2 set var4 [ var1 ] to 2 and var3 to zero , otherwise set var4 [ var1 ] to 1 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of numbers var4 of the length of var0 . you have to set var3 to zero . for each position var1 in var0 , set var5 to var0 [ var1 ] , add var5 - 1 to var3 , if var3 is divisible by 2 set var4 [ var1 ] to 2 and var3 to zero , otherwise set var4 [ var1 ] to 1 . 
you are given an array of numbers var0 , $$CONSTANT$$ number var6 , an index var1 , an array of numbers var4 , $$CONSTANT$$ number var3 . set var5 to var0 [ var6 ] and add 1 to var6 . add var5 - 1 to var3 . if var3 is divisible by 2 set var4 [ var1 ] to 2 and var3 to zero , otherwise set var4 [ var1 ] to 1 . 
given array var0 of integer type . create an array var5 of integer type . assign 0 to var4 , var2 . let var1 be the length of var0 . for all var3 $$CONSTANT$$ from 0 to var3 < var1 do following operations . increment var2 by the next value in var0 . if var2 % 2 equals 0 then insert 1 into var5 . otherwise , insert 2 into var5 . decrement var2 . update var2 by var2 % 2 . 
given array var0 of integer type . increment var2 by the next value in var0 . if var2 % 2 equals 0 then insert 1 into var5 . otherwise , insert 2 into var5 . decrement var2 . update var2 by var2 % 2 . 
given array var0 of integer type . increment var2 by the next value in var0 . if var2 % 2 equals 0 then insert 1 into var5 . otherwise , insert 2 into var5 . 
given array var0 of integer type . create an array var5 of integer type . assign 0 to var4 , var2 . let var1 be the length of var0 . for all var3 $$CONSTANT$$ from 0 to var3 < var1 do following operations . increment var2 by the next value in var0 . if var2 % 2 equals 0 then insert 1 into var5 . otherwise , insert 2 into var5 . decrement var2 . update var2 by var2 % 2 . after the loop is ended , return var5 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , an array of numbers var3 and an array of numbers var4 . you have to set var10 to var2 divided by var1 and var11 to var0 divided by var2 . you have to set var12 to zero , var13 to zero , and var14 to 1e - 07 . for each position var15 in var4 you have to set var16 to var4 [ var15 ] divided by var10 ; if var16 is less than or equal to var3 [ var15 ] + var14 you have to set var12 to the maximum between var3 [ var15 ] - var16 and var12 , add 1 to var13 . 
you are given an index var15 , $$CONSTANT$$ real var10 , $$CONSTANT$$ real var14 , $$CONSTANT$$ number var12 , an array of numbers var3 and an array of numbers var4 . you have to set var16 to var4 [ var15 ] divided by var10 . if var16 is less than or equal to var3 [ var15 ] + var14 you have to set var12 to the maximum between var3 [ var15 ] - var16 and var12 , add 1 to var13 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , an array of numbers var3 and an array of numbers var4 . you have to set var5 to the length of var3 , var6 to var0 , var7 to var1 , var8 to var2 . you have to set var10 to var8 divided by var7 and var11 to var6 divided by var8 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , an array of numbers var3 and an array of numbers var4 . you have to set var10 to var2 divided by var1 and var11 to var0 divided by var2 . you have to set var12 to zero , var13 to zero , and var14 to 1e - 07 . for each position var15 in var4 you have to set var16 to var4 [ var15 ] divided by var10 ; if var16 is less than or equal to var3 [ var15 ] + var14 you have to set var12 to the maximum between var3 [ var15 ] - var16 and var12 , add 1 to var13 . if var13 is equal to var5 you have to return var11 , otherwise you have to return ( var12 divided by var7 ) + var11 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , an array of numbers var3 and an array of numbers var4 . you have to set var5 to the length of var3 , var6 to var0 , var7 to var1 , var8 to var2 . 
given arrays var0 , var5 and integers var4 , var2 . subtract var2 from var0 [ var4 ] . if var0 [ var4 ] is less than 0 , return " NO " . set var2 to var0 [ var4 ] modulo 2 . 
given arrays var0 , var5 and integers var4 , var2 . subtract var2 from var0 [ var4 ] . if var0 [ var4 ] is less than 0 , return " NO " . 
given an array of integers var0 , initialize var1 to true . for each position var2 in var0 , if var0 [ var2 ] is odd , then decrease var0 [ var2 + 1 ] by 1 if var2 is not last position in var0 and var0 [ var2 + 1 ] > 0 , set var1 to false and break from the loop otherwise . 
given $$CONSTANT$$ string var0 . initialize var1 , var2 to 0 . for each var3 from 0 to the length of var0 exclusive , perform the following operations . if var4 [ var3 ] is $$CONSTANT$$ lowercase letter , set var2 to the minimum between var2 and var1 , increase var1 by 1 ; else increase var2 by 1 . 
given $$CONSTANT$$ string var0 and integers var2 , var1 , var3 . if var4 [ var3 ] is $$CONSTANT$$ lowercase letter , set var2 to the minimum between var2 and var1 , increase var1 by 1 ; else increase var2 by 1 . 
given integer typed array var0 . if var0 [ n - 2 ] - var0 [ n - 1 ] equals 1 then assign false to var1 . otherwise , assign true to var1 . 
given array var0 of integer type . let var1 be the length of var0 . if var1 equals 1 then if var0 [ 0 ] equals 15 then return " DOWN " . otherwise , if var0 [ 0 ] equals 0 then return " UP " . otherwise , return - 1 . if var1 was not equal 1 then if var0 [ n - 1 ] equals 15 then return " DOWN " . otherwise , if var0 [ n - 1 ] equals 0 then return " UP " . otherwise , if var0 [ n - 1 ] is less than var0 [ n - 2 ] then return " DOWN " . otherwise , return " UP " . 
given integers var0 , var1 . assign var1 to var2 , var3 , var4 . assign 1 to var5 . as long as at least one of values var2 , var3 , var4 is less than var0 do following operations . if sec % 3 equals 1 then assign b + $$CONSTANT$$ - 1 to var2 . otherwise , if sec % 3 equals 2 then assign $$CONSTANT$$ + $$CONSTANT$$ - 1 to var3 . otherwise , if var5 is divisible by 3 then assign $$CONSTANT$$ + b - 1 to var4 . after this , add 1 to var5 . 
given integers var0 , var1 . if each of values var2 , var3 , var4 is not less than var0 then return sec - 1 . if sec % 3 equals 1 then assign b + $$CONSTANT$$ - 1 to var2 . otherwise , if sec % 3 equals 2 then assign $$CONSTANT$$ + $$CONSTANT$$ - 1 to var3 . otherwise , if var5 is divisible by 3 then assign $$CONSTANT$$ + b - 1 to var4 . after this , add 1 to var5 . 
given integers var0 , var1 . assign var1 to var2 , var3 , var4 . assign 1 to var5 . as long as at least one of values var2 , var3 , var4 is less than var0 do following operations . if sec % 3 equals 1 then assign b + $$CONSTANT$$ - 1 to var2 . otherwise , if sec % 3 equals 2 then assign $$CONSTANT$$ + $$CONSTANT$$ - 1 to var3 . otherwise , if var5 is divisible by 3 then assign $$CONSTANT$$ + b - 1 to var4 . after this , add 1 to var5 . when the loop is ended , return sec - 1 . 
given an array of integers var0 , initialize var1 to true . for each position var2 in var0 , if var0 [ var2 ] is odd , then decrease var0 [ var2 + 1 ] by 1 if var2 is not last position in var0 and var0 [ var2 + 1 ] > 0 , set var1 to false and break from the loop otherwise . return " YES " if var1 is true , return " NO " otherwise . 
given integers var0 , var1 . if each of values var2 , var3 , var4 is not less than var0 then return sec - 1 . if sec % 3 equals 1 then assign b + $$CONSTANT$$ - 1 to var2 . otherwise , if sec % 3 equals 2 then assign $$CONSTANT$$ + $$CONSTANT$$ - 1 to var3 . otherwise , if var5 is divisible by 3 then assign $$CONSTANT$$ + b - 1 to var4 . 
given integer typed array var0 . if var0 [ n - 2 ] - var0 [ n - 1 ] equals 1 then return " DOWN " . otherwise , return " UP " . 
you are given integers var1 , var2 . assign var2 to var3 , var4 and var5 . assign 0 to result . while at least one of the values var3 , var4 and var5 is less than var1 , do following operations . if var6 is divisible by 3 then update var3 by the value b + $$CONSTANT$$ - 1 and increment result . otherwise , if var4 is less than var1 and var6 is not divisible by 3 then update var4 by the value $$CONSTANT$$ + $$CONSTANT$$ - 1 and increment result . otherwise , if var5 is less than var1 then update var5 by the value $$CONSTANT$$ + b - 1 and increment result . otherwise , do nothing . 
you are given integers var1 , var2 . assign var2 to var3 , var4 and var5 . assign 0 to result . while at least one of the values var3 , var4 and var5 is less than var1 , do following operations . if var6 is divisible by 3 then update var3 by the value b + $$CONSTANT$$ - 1 and increment result . otherwise , if var4 is less than var1 and var6 is not divisible by 3 then update var4 by the value $$CONSTANT$$ + $$CONSTANT$$ - 1 and increment result . otherwise , if var5 is less than var1 then update var5 by the value $$CONSTANT$$ + b - 1 and increment result . otherwise , do nothing . when the loop is ended , return the result . 
you are given integers var2 and var3 . assign 0 to result . create an array var5 of size 3 consisting of values var3 . while $$CONSTANT$$ of its elements does not equal var2 do this . sort var5 . set the minimum of var2 and ( var5 [ 1 ] + var5 [ 2 ] ) - 1 to var5 [ 0 ] . increment result . 
you are given integers var2 and var3 . assign 0 to result . create an array var5 of size 3 consisting of values var3 . while $$CONSTANT$$ of its elements does not equal var2 do this . sort var5 . set the minimum of var2 and ( var5 [ 1 ] + var5 [ 2 ] ) - 1 to var5 [ 0 ] . increment result . after the loop is ended , return the result . 
you are given $$CONSTANT$$ 0 - based array var0 of char type . update var1 [ 0 ] by the number of occurences of $$CONSTANT$$ in var0 . update var1 [ 1 ] by the number of occurences of $$CONSTANT$$ in var0 . update var1 [ 2 ] by the number of occurences of $$CONSTANT$$ in var0 . update var1 [ 3 ] by the number of occurences of other characters in var0 . 
given $$CONSTANT$$ string var0 . initialize var1 , var2 to 0 . for each var3 from 0 to the length of var0 exclusive , perform the following operations . if var4 [ var3 ] is $$CONSTANT$$ lowercase letter , set var2 to the minimum between var2 and var1 , increase var1 by 1 ; else increase var2 by 1 . return the minimum between var1 and var2 . 
you are given $$CONSTANT$$ 0 - based array var0 of char type . update var1 [ 0 ] by the number of occurences of $$CONSTANT$$ in var0 . update var1 [ 1 ] by the number of occurences of $$CONSTANT$$ in var0 . update var1 [ 2 ] by the number of occurences of $$CONSTANT$$ in var0 . update var1 [ 3 ] by the number of occurences of other characters in var0 . return the half of the sum of values var1 [ 0 ] - $$CONSTANT$$ [ 1 ] and var1 [ 2 ] - $$CONSTANT$$ [ 3 ] , each taken by module . 
given 0 - indexed array var1 and integer var3 . count the number of elements of var1 which is positive and larger than or equal to var1 [ ( var3 - 1 ) ] . store the result in var4 . 
given array var1 . set var4 : = 0 , var2 : = len ( var1 ) and var3 : = var0 . $$CONSTANT$$ var1 to another array var5 . 
you are given an integer var1 , $$CONSTANT$$ matrix var2 of type char . create an integer var3 with initial value equal to the length of var2 . create $$CONSTANT$$ sorted set var4 of size var1 . for all var5 $$CONSTANT$$ from var5 = 0 to var5 < var1 create $$CONSTANT$$ sorted set var4 [ var5 ] . after the loop is ended , assign the value 0 to var6 . for all var7 $$CONSTANT$$ from var7 = 0 to var7 < var1 do following loop . for all var8 $$CONSTANT$$ from var8 = 0 to var8 < var3 add the value var2 [ var8 ] [ var7 ] into current sorted set var4 [ var7 ] . after both loops are ended , assign the value 1 to var9 . for all var10 $$CONSTANT$$ from var10 = 0 to var10 < var1 assign the value ( var9 * len ( var4 [ var10 ] ) ) % $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . cf152c . mod to var9 . 
you are given integers var1 , var2 . if all values var3 , var4 and var5 are larger than or equal to var1 then exit from current loop . otherwise , do nothing . if var6 is divisible by 3 then update var3 by the value b + $$CONSTANT$$ - 1 and increment var6 . otherwise , if var4 is less than var1 and var6 is not divisible by 3 then update var4 by the value $$CONSTANT$$ + $$CONSTANT$$ - 1 and increment var6 . otherwise , if var5 is less than var1 then update var5 by the value $$CONSTANT$$ + b - 1 and increment var6 . otherwise , do nothing . 
you are given the string var0 . you have to store in var2 the number of characters in var0 with asci code $$CONSTANT$$ minus the number of characters in var0 with asci code 68 . you have to store in var1 the number of characters in var0 with asci code $$CONSTANT$$ minus the number of characters in var0 with asci code different to $$CONSTANT$$ , 68 , and $$CONSTANT$$ . 
you are given the string var0 . you have to store in var2 the number of characters in var0 with asci code $$CONSTANT$$ minus the number of characters in var0 with asci code 68 . you have to store in var1 the number of characters in var0 with asci code $$CONSTANT$$ minus the number of characters in var0 with asci code different to $$CONSTANT$$ , 68 , and $$CONSTANT$$ . you have to return the sum of the absolute values of var1 and var2 divided by 2 . 
given 0 - indexed array var1 and integer var3 . return the number of elements of var1 which is positive and larger than or equal to var1 [ ( var3 - 1 ) ] . 
given integers var0 , var1 , var2 , var3 , var4 . assign 1 < < $$CONSTANT$$ to var5 . if var1 is larger than or equal to var0 then assign var2 * var0 to var5 . otherwise , if var4 + ( var2 * var1 ) is larger than var3 * var1 then assign ( var2 * var1 ) + ( ( var0 - var1 ) * var3 ) to var5 . otherwise , do following operations . assign values var0 / var1 , var0 % var1 to variables var6 and var7 , respectively . assign ( ( ( var6 - 1 ) * var4 ) + ( ( var6 * var1 ) * var2 ) ) + var5 ( ( var4 + ( var7 * var2 ) ) , ( var7 * var3 ) ) to var8 . update var5 by the value of var8 . after this , return var5 . 
given integers var0 , var1 , var2 , var3 , var4 . assign 1 < < $$CONSTANT$$ to var5 . if var1 is larger than or equal to var0 then assign var2 * var0 to var5 . otherwise , if var4 + ( var2 * var1 ) is larger than var3 * var1 then assign ( var2 * var1 ) + ( ( var0 - var1 ) * var3 ) to var5 . otherwise , do following operations . assign values var0 / var1 , var0 % var1 to variables var6 and var7 , respectively . assign ( ( ( var6 - 1 ) * var4 ) + ( ( var6 * var1 ) * var2 ) ) + var5 ( ( var4 + ( var7 * var2 ) ) , ( var7 * var3 ) ) to var8 . update var5 by the value of var8 . 
you are given an integer var1 , $$CONSTANT$$ matrix var2 of type char . create an integer var3 with initial value equal to the length of var2 . create $$CONSTANT$$ sorted set var4 of size var1 . for all var5 $$CONSTANT$$ from var5 = 0 to var5 < var1 create $$CONSTANT$$ sorted set var4 [ var5 ] . after the loop is ended , assign the value 0 to var6 . for all var7 $$CONSTANT$$ from var7 = 0 to var7 < var1 do following loop . for all var8 $$CONSTANT$$ from var8 = 0 to var8 < var3 insert the value var2 [ var8 ] [ var7 ] into current sorted set var4 [ var7 ] . 
you are given an integer var1 , $$CONSTANT$$ matrix var2 of type char . create an integer var3 with initial value equal to the length of var2 . create $$CONSTANT$$ sorted set var4 with size var1 of type object . for all var5 $$CONSTANT$$ from var5 = 0 to var5 < var1 create $$CONSTANT$$ sorted set var4 [ var5 ] of type object . 
you are given the numbers var0 , var1 , var2 . if the minimum among var0 , var1 , and var2 is unique return this value , otherwise return var2 . 
you are given the numbers var0 , var1 , var2 . if the minimum among var0 , var1 , and var2 is unique store in var3 this value , otherwise set var3 to var2 . 
given variables of real values var0 , var1 , var2 and arrays var3 , var4 of real values . let var9 and var10 be the next elements in var3 and var4 , respectively . assign values x / v and y / u to variables var11 and var12 , respectively . set the larger of var7 and var11 - var12 to var7 . if var11 is less than var12 then assign true to var6 . 
you are given the numbers var0 , var1 , var2 , var4 , var3 . set var5 to zero . if var0 is less than or equal to var1 set var5 to var0 * var2 , otherwise if var4 + var2 * var1 is greater than var1 * var3 set var5 to var1 * var2 + ( var0 - var1 ) * var3 , otherwise you have to , set var6 to var0 divided by var1 ( rounded down ) , add var1 * var6 * var2 + ( var6 - 1 ) * var4 to var5 , set var7 to var0 - var6 * var1 , if var7 * var2 + var4 is less than var7 * var3 add var7 * var2 + var4 to var5 , otherwise add var7 * var3 to var5 . you have to return var5 . 
you are given the numbers var0 , var1 , var2 , var4 , var3 . set var5 to zero . if var0 is less than or equal to var1 set var5 to var0 * var2 , otherwise if var4 + var2 * var1 is greater than var1 * var3 set var5 to var1 * var2 + ( var0 - var1 ) * var3 , otherwise you have to , set var6 to var0 divided by var1 ( rounded down ) , add var1 * var6 * var2 + ( var6 - 1 ) * var4 to var5 , set var7 to var0 - var6 * var1 , if var7 * var2 + var4 is less than var7 * var3 add var7 * var2 + var4 to var5 , otherwise add var7 * var3 to var5 . 
given variables of real values var0 , var1 , var2 and arrays var3 , var4 of real values . assign 0 to var14 , var13 . let var5 be the length of var3 . assign false to var6 . assign 0 to var7 . for all var8 $$CONSTANT$$ from 0 to var8 < var5 do following operations . let var9 and var10 be the next elements in var3 and var4 , respectively . assign values x / v and y / u to variables var11 and var12 , respectively . set the larger of var7 and var11 - var12 to var7 . if var11 is less than var12 then assign true to var6 . 
you are given the numbers var0 , var1 , var5 , var2 , var4 , var3 . set var6 to var0 divided by var1 ( rounded down ) , add var1 * var6 * var2 + ( var6 - 1 ) * var4 to var5 , set var7 to var0 - var6 * var1 , if var7 * var2 + var4 is less than var7 * var3 add var7 * var2 + var4 to var5 , otherwise add var7 * var3 to var5 . 
given integer arrays var0 , var1 , var2 . assign 0 to var10 . for each var5 from var9 to $$CONSTANT$$ - 1 , initialize var12 to the sum of all values var0 [ var13 ] whre var13 is from var6 [ var11 ] [ 0 ] to var6 [ var11 ] [ 1 ] and assign the larger of sum + total and var10 to var10 . 
given integer arrays var0 , var1 , var2 . initialize var12 to the sum of all values var0 [ var13 ] whre var13 is from var6 [ var11 ] [ 0 ] to var6 [ var11 ] [ 1 ] . assign the larger of sum + total and var10 to var10 . 
given integer arrays var0 , var1 , var2 . create 0 - based integer matrix var6 at first $$CONSTANT$$ containing the array var1 and at second $$CONSTANT$$ containing var2 with all values being decreased by 1 . 
given integer arrays var0 , var1 , var2 . initialize var12 to the sum of all values var0 [ var13 ] whre var13 is from var6 [ var11 ] [ 0 ] to var6 [ var11 ] [ 1 ] . assign sum + total to var14 . 
given integer arrays var0 , var1 , var2 . initialize var12 to the sum of all values var0 [ var13 ] whre var13 is from var6 [ var11 ] [ 0 ] to var6 [ var11 ] [ 1 ] . 
given an integer var0 . return true if var0 is prime number . otherwise , return false . 
given an integer var0 . return true if var0 is prime number . otherwise , return false . 
you are given $$CONSTANT$$ number var0 . set var1 to var0 , var2 to 2 , var3 to 1 , var4 to 1 . while var2 is less than or equal to var1 set var5 to var2 , add var3 to var2 , set var3 to var5 , add 1 to var4 . 
given integers var0 , var1 and var2 , if var0 = var2 , then set var3 to 2 * ( var1 - var0 - 1 ) if var1 > var0 , set var3 to 0 if var1 = var0 , set var3 to var0 - 1 - var1 if var1 < var0 . otherwise if var0 > var2 , then set var3 to var0 - 2 - var2 + 2 * ( var1 - var0 ) if var1 > var0 , set var3 to var0 - 1 - var2 if var1 = var0 , set var3 to 2 * var0 - var2 - var1 - 2 if var1 < var0 . otherwise set var3 to 2 * ( var1 - var2 ) + var2 - var0 - 2 if var1 > var2 , set var3 to var2 - var0 - 1 if var1 = var0 , set var3 to 2 * var2 - var0 - var1 - 2 if var1 < var0 . return var3 . 
given integers var0 , var1 and var2 , if var0 = var2 , then set var3 to 2 * ( var1 - var0 - 1 ) if var1 > var0 , set var3 to 0 if var1 = var0 , set var3 to var0 - 1 - var1 if var1 < var0 . otherwise if var0 > var2 , then set var3 to var0 - 2 - var2 + 2 * ( var1 - var0 ) if var1 > var0 , set var3 to var0 - 1 - var2 if var1 = var0 , set var3 to 2 * var0 - var2 - var1 - 2 if var1 < var0 . otherwise set var3 to 2 * ( var1 - var2 ) + var2 - var0 - 2 if var1 > var2 , set var3 to var2 - var0 - 1 if var1 = var0 , set var3 to 2 * var2 - var0 - var1 - 2 if var1 < var0 . 
given three integers var0 , var1 and var2 . initialize empty 0 - based integer array var6 and push var0 , var1 and var2 . sort var6 . set var7 to zero . if last element of var6 - 1 is bigger than second element then increase var7 by difference between last element and second element minus one . if last element of var6 minus one is bigger than first element then increase var7 by difference between last element and first element minus one . 
given three integers var0 , var1 and var2 . initialize empty 0 - based integer array var6 and push var0 , var1 and var2 . sort var6 . set var7 to zero . if last element of var6 - 1 is bigger than second element then increase var7 by difference between last element and second element minus one . if last element of var6 minus one is bigger than first element then increase var7 by difference between last element and first element minus one . return var7 . 
you are given $$CONSTANT$$ number var0 . set var1 to var0 , var2 to 2 , var3 to 1 , var4 to 1 . while var2 is less than or equal to var1 set var5 to var2 , add var3 to var2 , set var3 to var5 , add 1 to var4 . return var4 - 1 . 
given an integer var0 . if var0 is $$CONSTANT$$ prime number then return 1 . otherwise , if var0 is even number or if n - 2 is prime number then return 2 . otherwise , if $$CONSTANT$$ of these cases is true then return 3 . 
given integer array var0 . assign var0 to var2 . sort var2 . assign 0 to var4 , var5 . for all var3 $$CONSTANT$$ from 0 to n - 1 , if var4 does not exceed var2 [ var3 ] then add 1 to var5 and add var2 [ var3 ] to var4 . 
given integer array var0 . assign var0 to var2 . sort var2 . 
given integer array var0 . assign var0 to var2 . sort var2 . assign 0 to var4 , var5 . for all var3 $$CONSTANT$$ from 0 to n - 1 , if var4 does not exceed var2 [ var3 ] then add 1 to var5 and add var2 [ var3 ] to var4 . return var5 . 
given array var4 of char type and an integer var2 . if var4 [ var9 ] does not equal 48 then update the result by the minimum of its current value and var7 . otherwise , do nothing . increase var7 by the value ( var7 * 10 ) + ( var4 [ var9 ] - 48 ) - func0 ( 10 , ( var5 - 1 ) , var2 ) * ( var4 [ var9 ] - 48 ) ) % var2 ) ) + var2 taken by modulo var2 . 
given array var4 of char type and an integer var2 . initialize the length of var4 to var5 . assign var2 to result . initialize 0 to var7 . for all var8 $$CONSTANT$$ from 0 to var8 < var5 , incremenet var7 by the result of function func0 ( 10 , var5 - $$CONSTANT$$ - 1 ) , var2 ) * ( var4 [ var8 ] - 48 ) ) % var2 ) ) modulo var2 . 
given array var4 of char type and an integer var2 . initialize the length of var4 to var5 . assign var2 to result . initialize 0 to var7 . for all var8 $$CONSTANT$$ from 0 to var8 < var5 , incremenet var7 by the result of function func0 ( 10 , var5 - $$CONSTANT$$ - 1 ) , var2 ) * ( var4 [ var8 ] - 48 ) ) % var2 ) ) modulo var2 . 
given integers var0 , var1 , var2 . assign 1 to var3 . while var1 is larger than 0 , do following operations . if var1 & 1 is larger than 0 then multiply the result by var0 , modulo var2 . otherwise , do nothing . erect var0 to the power of 2 , modulo var2 . update var1 by var1 > > 1 . when var1 becomes 0 , return var3 . 
given integers var0 , var1 , var2 . assign 1 to var3 . while var1 is larger than 0 , do following operations . if var1 & 1 is larger than 0 then multiply the result by var0 , modulo var2 . otherwise , do nothing . erect var0 to the power of 2 , modulo var2 . update var1 by var1 > > 1 . 
given integers var0 , var1 , var2 . if var1 & 1 is larger than 0 then multiply the result by var0 , modulo var2 . otherwise , do nothing . erect var0 to the power of 2 , modulo var2 . update var1 by var1 > > 1 . 
you are given an array of integers var0 . initialize var1 as length of array var0 . initialize var3 to 0 . initialize var4 to empty array of strings . for each var5 in range from length ( var0 ) - 1 to 0 in $$CONSTANT$$ of decreasing var5 : if var0 [ var5 ] > var3 : ( initialize var6 to empty string . for each var7 in range from var0 [ var5 ] to var3 + 1 in $$CONSTANT$$ of decreasing var7 , push var7 as string and " " to var6 . assign var3 to var0 [ var5 ] . push var6 to array var4 ) , else push empty string to array var4 . initialize var8 to empty string . for each var9 in range from length ( var4 ) - 1 to 0 in decreasing $$CONSTANT$$ of var9 push var4 [ var9 ] and endline to var8 . 
you are given an array of integers var0 . initialize var1 as length of array var0 . initialize var3 to 0 . initialize var4 to empty array of strings . for each var5 in range from length ( var0 ) - 1 to 0 in $$CONSTANT$$ of decreasing var5 : if var0 [ var5 ] > var3 : ( initialize var6 to empty string . for each var7 in range from var0 [ var5 ] to var3 + 1 in $$CONSTANT$$ of decreasing var7 , push var7 as string and " " to var6 . assign var3 to var0 [ var5 ] . push var6 to array var4 ) , else push empty string to array var4 . 
given integer arrays var0 , var1 . let var3 and var4 be the number of ones in var0 and in var1 , respectively . 
given integer arrays var0 , var1 . assign var0 [ var7 ] and var1 [ var7 ] to var5 and to var6 , respectively . if var5 equals 1 then add 1 to var3 . if var6 equals 1 then add 1 to var4 . 
given integer arrays var0 , var1 . assign var0 [ var7 ] and var1 [ var7 ] to var5 and to var6 , respectively . if var5 equals 1 then add 1 to var3 . 
given integer arrays var0 , var1 . let var3 and var4 be the number of ones in var0 and in var1 , respectively . assign to var5 the minimum between var3 , n - one . assign to var6 the minimum of var4 and n - two . return $$CONSTANT$$ + $$CONSTANT$$ . 
given 3 arrays of integers var1 , var2 and var0 . assign var14 and var15 to 0 . assign var3 to length of var0 . assign var4 to length of var1 . assign var5 to empty array of length var4 . assign var6 to 0 . for each var6 in range from 0 to var4 - 1 : ( assign var5 [ var7 ] to sum of array var0 in range from var1 [ var14 ] - 1 to var2 [ var15 ] - 1 . increment var14 and var15 ) . 
given 3 arrays of integers var1 , var2 and var0 . assign var5 [ var7 ] to sum of array var0 in range from var1 [ var14 ] - 1 to var2 [ var15 ] - 1 . increment var14 and var15 . 
you are given an array of integers var0 . initialize var1 as length of array var0 . initialize var3 to 0 . initialize var4 to empty array of strings . for each var5 in range from length ( var0 ) - 1 to 0 in $$CONSTANT$$ of decreasing var5 : if var0 [ var5 ] > var3 : ( initialize var6 to empty string . for each var7 in range from var0 [ var5 ] to var3 + 1 in $$CONSTANT$$ of decreasing var7 push var7 as string and " " to var6 . assign var3 to var0 [ var5 ] . push var6 to array var4 ) , else push empty string to array var4 . initialize var8 to empty string . for each var9 in range from length ( var4 ) - 1 to 0 in decreasing $$CONSTANT$$ of var9 push var4 [ var9 ] and endline to var8 . return var8 as answer . 
given 3 arrays of integers var1 , var2 and var0 . assign var10 to sum of array var0 in range from var1 [ var14 ] - 1 to var2 [ var15 ] - 1 . increment var14 and var15 . 
given an array var5 and integers var13 , var12 . if var5 [ var13 ] is negative , break from the enclosing loop , otherwise increase var12 by var5 [ var13 ] . 
given integer var2 . return false if var2 is not prime number . 
given integer var2 . return false if var2 is not prime number . otherwise , return true . 
given integers var0 , var1 , var2 , var3 , var4 , var5 and var6 , initialize var7 to var2 - var1 , divided by absolute value of var2 - var1 , var8 to absolute value of var2 - var1 , multiplied by var4 , var9 to 0 , var10 to false . repeat the following loop : set var10 to true if var5 = var1 ; break from the enclosing loop if var5 = var2 and var10 is true ; add var6 to var5 ; set var6 to - var6 if var5 = 0 or var5 = var0 ; increase var9 by 1 . 
given integers var0 , var1 , var2 , var5 , var6 and var9 and $$CONSTANT$$ boolean var10 , set var10 to true if var5 = var1 ; break from the enclosing loop if var5 = var2 and var10 is true ; add var6 to var5 ; set var6 to - var6 if var5 = 0 or var5 = var0 ; increase var9 by 1 . 
given integers var0 , var1 , var2 , var5 and var6 and $$CONSTANT$$ boolean var10 , set var10 to true if var5 = var1 ; break from the enclosing loop if var5 = var2 and var10 is true ; add var6 to var5 ; set var6 to - var6 if var5 = 0 or var5 = var0 . 
given integers var1 , var2 , var5 and var6 and $$CONSTANT$$ boolean var10 , set var10 to true if var5 = var1 ; break from the enclosing loop if var5 = var2 and var10 is true ; add var6 to var5 . 
given integers var5 , var1 and var2 and $$CONSTANT$$ boolean var10 , set var10 to true if var5 = var1 ; break from the enclosing loop if var5 = var2 and var10 is true . 
given an array of integers var0 , initialize var2 to false . for each position var3 in var0 initialize var4 to var0 [ var3 ] ; break from the enclosing loop if var2 is true and var4 = 0 ; add 1 to var4 and set var2 to false if var2 is true ; set var2 to true if var4 is odd . 
given an array of integers var0 , $$CONSTANT$$ boolean var2 and an integer var3 , initialize var4 to var0 [ var3 ] ; break from the enclosing loop if var2 is true and var4 = 0 ; add 1 to var4 and set var2 to false if var2 is true ; set var2 to true if var4 is odd . 
given an array of integers var0 , $$CONSTANT$$ boolean var2 and an integer var3 , initialize var4 to var0 [ var3 ] ; break from the enclosing loop if var2 is true and var4 = 0 ; add 1 to var4 and set var2 to false if var2 is true . 
given an array of integers var0 , initialize var2 to false . for each position var3 in var0 initialize var4 to var0 [ var3 ] ; break from the enclosing loop if var2 is true and var4 = 0 ; add 1 to var4 and set var2 to false if var2 is true ; set var2 to true if var4 is odd . return " NO " if var2 is true , return " YES " otherwise . 
you are given array var0 of integer type . assign the length of var0 to var1 . initialize the sorted array var0 to var2 . assign the values 1 , var2 [ 0 ] to var4 and var5 , respectively . let var4 be the number of elements in var2 with values larger than the sum of previous elements in var2 . 
you are given array var0 of integer type . assign the length of var0 to var1 . initialize the sorted array var0 to var2 . assign the values 1 , var2 [ 0 ] to var4 and var5 , respectively . 
you are given array var0 of integer type . assign the length of var0 to var1 . initialize the sorted array var0 to var2 . assign the values 1 , var2 [ 0 ] to var4 and var5 , respectively . 
you are given array var0 of integer type . assign the length of var0 to var1 . initialize the sorted array var0 to var2 . 
you are given array var0 of integer type . assign the length of var0 to var1 . initialize var0 to var2 . 
you are given array var0 of integer type . assign the length of var0 to var1 . initialize the sorted array var0 to var2 . assign the values 1 , var2 [ 0 ] to var4 and var5 , respectively . return the number of elements in var2 with values larger than the sum of previous elements in var2 . 
given an array of integers var0 , $$CONSTANT$$ boolean var2 and an integer var3 , break from the enclosing loop if var2 is true and var0 [ var3 ] = 0 . 
given an array of integers var0 , initialize var6 to empty array of strings , var1 to length of var0 , var3 to 0 . for each position var5 in var0 if var0 [ var5 ] is odd , then decrease var0 [ var5 + 1 ] by 1 if var5 + 1 < var1 and var0 [ var5 + 1 ] > 0 , append " NO " to the end of var6 , set var3 to 1 and break from the enclosing loop otherwise . append " YES " to the end of var6 if var5 = var1 and var3 = 0 . 
given an array of integers var0 , initialize var6 to empty array of strings , var1 to length of var0 , var3 to 0 . for each position var5 in var0 if var0 [ var5 ] is odd , then decrease var0 [ var5 + 1 ] by 1 if var5 + 1 < var1 and var0 [ var5 + 1 ] > 0 , append " NO " to the end of var6 , set var3 to 1 and break from the enclosing loop otherwise . 
given an array of integers var0 , an array of strings var6 and integers var5 , var1 and var3 , if var0 [ var5 ] is odd , then decrease var0 [ var5 + 1 ] by 1 if var5 + 1 < var1 and var0 [ var5 + 1 ] > 0 , append " NO " to the end of var6 , set var3 to 1 and break from the enclosing loop otherwise . 
given integer typed array var0 . assign true to var3 . iterating over var0 if current element is odd value and it is the last one in array or the next value in var0 is 0 then assign false to var3 , and for each even value in var0 , substract 1 from it and from the next value in var0 . 
given integer typed array var0 . if var4 + 1 equals var1 or var0 [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] equals 0 then assign false to var3 and exit from the loop . substract 1 from var0 [ var4 ] and from var0 [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] . 
given an array of integers var0 , initialize var6 to empty array of strings , var1 to length of var0 , var3 to 0 . for each position var5 in var0 if var0 [ var5 ] is odd , then decrease var0 [ var5 + 1 ] by 1 if var5 + 1 < var1 and var0 [ var5 + 1 ] > 0 , append " NO " to the end of var6 , set var3 to 1 and break from the enclosing loop otherwise . append " YES " to the end of var6 if var5 = var1 and var3 = 0 . return var6 . 
given integer typed array var0 . assign true to var3 . iterating over var0 if current element is odd value and it is the last one in array or the next value in var0 is 0 then assign false to var3 , and for each even value in var0 , substract 1 from it and from the next value in var0 . if var3 is true then return " YES " . otherwise , return " NO " . 
given integer var0 , array var1 of integer type . let var2 be the length of var1 . assign var1 [ n - 1 ] to var4 . 
given integer var0 , array var1 of integer type . let var2 be the length of var1 . 
given integer var0 , array var1 of integer type . let var2 be the length of var1 . if var1 [ n - 1 ] equals 15 then return " DOWN " . if var1 [ n - 1 ] equals 0 then return " UP " . if var2 is less than or equal to 1 then return " - 1 " . otherwise , if var1 [ n - 1 ] is less than var1 [ n - 2 ] then return " DOWN " . otherwise , if var1 [ n - 1 ] is larger than var1 [ n - 2 ] then return " UP " . 
given integers var0 , var1 , var2 , var3 , var4 , var5 and var6 , initialize var7 to var2 - var1 , divided by absolute value of var2 - var1 , var8 to absolute value of var2 - var1 , multiplied by var4 , var9 to 0 , var10 to false . repeat the following loop : set var10 to true if var5 = var1 ; break from the enclosing loop if var5 = var2 and var10 is true ; add var6 to var5 ; set var6 to - var6 if var5 = 0 or var5 = var0 ; increase var9 by 1 . return the minimum of var9 * var3 and var8 . 
you are given an array of numbers var0 ( indexing is 0 - based ) , an array of numbers var1 ( indexing is 0 - based ) , an array of numbers var2 ( indexing is 0 - based ) . you have to set var8 to zero . for each position var7 in var1 set var12 to the value of the function func0 at the arguments var0 , var1 [ var7 ] - 1 , and var2 [ var7 ] , if var12 is greater than zero add var12 to var8 . 
you are given an array of numbers var0 , an array of numbers var1 , an array of numbers var2 , $$CONSTANT$$ number var8 , an index var3 , an index var4 . you have to set var10 to var1 [ var3 ] - 1 and add 1 to var3 . you have to set var11 to var2 [ var4 ] and add 1 to var4 . you have to set var12 to the value of the function func0 at the arguments var0 , var10 , and var11 . if var12 is greater than zero add var12 to var8 . 
you are given an array of numbers var0 , an array of numbers var1 . you have to set var5 to the length of var0 and var6 to the length of var1 . 
you are given an array of numbers var0 , $$CONSTANT$$ number var10 and $$CONSTANT$$ number var11 . you have return the sum of the elements in var0 at positions between var10 and var11 - 1 ( both inclusive ) . 
you are given an array of numbers var0 , $$CONSTANT$$ number var10 and $$CONSTANT$$ number var11 . you have to store in var12 the sum of the elements in var0 at positions between var10 and var11 - 1 ( both inclusive ) . 
check whether $$CONSTANT$$ given number var0 is not prime number , or is equal to 2 . 
check whether $$CONSTANT$$ given number var0 is $$CONSTANT$$ prime number or not . 
given an integer var0 , initialize var3 to empty array of integers , var1 to array of integers of length $$CONSTANT$$ , set var1 [ 0 ] and var1 [ 1 ] to 1 . for each integer var2 from 2 to 999 ( both inclusive ) set var1 [ var2 ] to var1 [ var2 - 1 ] + var1 [ var2 - 2 ] ; append var2 - 1 to the end of var3 and break from the loop if var1 [ var2 ] = var0 ; append var2 - 2 to the end of var3 and break from the loop if var1 [ var2 ] > var0 . 
given an integer var0 , initialize var3 to empty array of integers , var1 to array of integers of length $$CONSTANT$$ , set var1 [ 0 ] and var1 [ 1 ] to 1 . for each integer var2 from 2 to 999 ( both inclusive ) set var1 [ var2 ] to var1 [ var2 - 1 ] + var1 [ var2 - 2 ] ; append var2 - 1 to the end of var3 and break from the loop if var1 [ var2 ] = var0 ; append var2 - 2 to the end of var3 and break from the loop if var1 [ var2 ] > var0 . return var3 . 
given an integer var0 and of arrays var1 , var2 of integer types . let var3 be the length of var1 . assign 0 to var6 , var7 . for all var8 $$CONSTANT$$ from 0 to var8 < var3 , do following operations . assign var2 [ var8 ] to var9 . increment var6 by the larger of 0 and var1 [ var8 ] - ( var7 + var9 ) * var0 . increment var7 by var9 . after the loop is ended , do the same loop but start iterating from last element and instead of var6 use var10 . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . initialize var4 to 0 and var5 to 0 . for each position var6 in var2 increase var5 by 1 and add var2 [ var6 ] to var4 if var4 < = var2 [ var6 ] . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . 
given an array of integers var2 and integers var6 , var4 and var5 , increase var5 by 1 and add var2 [ var6 ] to var4 if var4 < = var2 [ var6 ] . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . initialize var4 to 0 and var5 to 0 . for each position var6 in var2 increase var5 by 1 and add var2 [ var6 ] to var4 if var4 < = var2 [ var6 ] . return var5 . 
you are given an integer var0 . if var0 is even number then the result is strings " white " and " 1 2 " in separate lines . otherwise , the result is " black " . 
you are given an integer var0 . if var0 is even number then return strings " white " and " 1 2 " in separate lines . otherwise , return " black " . 
given an integer var0 and of arrays var1 , var2 of integer types . let var3 be the length of var1 . assign 0 to var6 , var7 . for all var8 $$CONSTANT$$ from 0 to var8 < var3 , do following operations . assign var2 [ var8 ] to var9 . increment var6 by the larger of 0 and var1 [ var8 ] - ( var7 + var9 ) * var0 . increment var7 by var9 . after the loop is ended , do the same loop but start iterating from last element and instead of var6 use var10 . if , eventually , var6 is larger than var10 then return " Limak " . otherwise , if var6 equals var10 then return " $$CONSTANT$$ " . otherwise , return " Radewoosh " . 
you are given an array of numbers var0 ( indexing is 0 - based ) , an array of numbers var1 ( indexing is 0 - based ) , an array of numbers var2 ( indexing is 0 - based ) . you have to set var8 to zero . for each position var7 in var1 set var12 to the value of the function func0 at the arguments var0 , var1 [ var7 ] - 1 , and var2 [ var7 ] , if var12 is greater than zero add var12 to var8 . you have to return var8 . 
given integers var0 , var1 , integer array var2 . assign 0 to var5 , var6 . for each var4 from 0 to n - 1 , do following operations . while var5 does not exceed var0 and var4 is less than var3 , add var2 [ var4 ] to var5 and increment var4 . if var5 exceeds var0 then decrement var4 , decrease var5 by var2 [ var4 ] , assign var2 [ var7 ] - ( var0 - var5 ) to var8 , assign ( ( var8 + var1 ) - 1 ) / var1 to var9 , add var9 to var6 , assign to var5 the larger of 0 and currh - times * var1 . 
given integers var0 , var1 , integer array var2 . assign 0 to var5 , var6 . for each var4 from 0 to n - 1 , do following operations . while var5 does not exceed var0 and var4 is less than var3 , add var2 [ var4 ] to var5 and increment var4 . if var5 exceeds var0 then decrement var4 , decrease var5 by var2 [ var4 ] , assign var2 [ var7 ] - ( var0 - var5 ) to var8 , assign ( ( var8 + var1 ) - 1 ) / var1 to var9 , add var9 to var6 , assign to var5 the larger of 0 and currh - times * var1 . when var4 becomes equal var3 , return res + ( ( var5 + var1 ) - 1 ) / var1 . 
given integers var0 , var1 , integer array var2 . while var5 does not exceed var0 and var4 is less than var3 , add var2 [ var4 ] to var5 and increment var4 . if var5 exceeds var0 then decrement var4 , decrease var5 by var2 [ var4 ] , assign var2 [ var7 ] - ( var0 - var5 ) to var8 , assign ( ( var8 + var1 ) - 1 ) / var1 to var9 , add var9 to var6 , assign to var5 the larger of 0 and currh - times * var1 . 
given arrays var1 , var2 and an integer var0 . initialize var4 to some big value , var5 to some small value . for each var7 in var1 and var8 in var2 , perform the following operations . if var7 is greater than var8 , swap the values of var7 and var8 . set var5 to the maximum between var5 and var7 , var4 to the minimum between var4 and var8 . if the length of var1 equals 0 , return var0 - 1 ; else return the maximum between 0 and var4 - var5 . 
given arrays var1 , var2 and an integer var0 . initialize var4 to some big value , var5 to some small value . for each var7 in var1 and var8 in var2 , perform the following operations . if var7 is greater than var8 , swap the values of var7 and var8 . set var5 to the maximum between var5 and var7 , var4 to the minimum between var4 and var8 . 
given arrays var1 , var2 and integers var9 , var10 , var5 , var4 . initialize var7 to var1 [ var9 ] , var8 to var2 [ var10 ] . if var7 is greater than var8 , swap the values of var7 and var8 . set var5 to the maximum between var5 and var7 , var4 to the minimum between var4 and var8 . 
given arrays var1 , var2 and integers var9 , var10 . initialize var7 to var1 [ var9 ] , var8 to var2 [ var10 ] . if var7 is greater than var8 , swap the values of var7 and var8 . 
given an array var0 of integer type . create matrices var9 , var3 both of integer types . let var1 be the length of var0 . create $$CONSTANT$$ sorted set var2 of integer type . assign 0 to var4 , var5 . for all var6 $$CONSTANT$$ from 0 to var6 < var1 do following operations . if var2 does not contain var0 [ var6 ] then insert var0 [ var6 ] into var2 . otherwise , do following operations . insert the array consisting of values start + 1 and start + len + 1 into var3 . increment var4 by len + 1 . assign 0 to var5 . clear var2 . 
given an array var0 of integer type . insert the string representation of length of var3 into var9 . update var7 by var3 [ length of var3 - 1 ] . assign var1 to var7 [ 1 ] . assign var7 to var3 [ length of var3 - 1 ] . for all var8 $$CONSTANT$$ from 0 to var8 < length of var3 , add the string consisting of string representations of var3 [ var8 ] [ 0 ] and str ( var3 [ var8 ] [ 1 ] ) splited py space , to the end of var9 . 
given an array var0 of integer type . create matrices var9 , var3 both of integer types . let var1 be the length of var0 . create $$CONSTANT$$ sorted set var2 of integer type . assign 0 to var4 , var5 . for all var6 $$CONSTANT$$ from 0 to var6 < var1 do following operations . if var2 does not contain var0 [ var6 ] then insert var0 [ var6 ] into var2 . otherwise , do following operations . insert the array consisting of values start + 1 and start + len + 1 into var3 . increment var4 by len + 1 . assign 0 to var5 . clear var2 . after the loop is ended , if length of var3 equals 0 then insert - 1 into var9 . otherwise , do following operations . insert the string representation of length of var3 into var9 . update var7 by var3 [ length of var3 - 1 ] . assign var1 to var7 [ 1 ] . assign var7 to var3 [ length of var3 - 1 ] . for all var8 $$CONSTANT$$ from 0 to var8 < length of var3 , add the string consisting of string representations of var3 [ var8 ] [ 0 ] and str ( var3 [ var8 ] [ 1 ] ) splited py space , to the end of var9 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var4 to 0 , var5 to 0 and var8 to 0 . for each position var9 in var2 add var2 [ var9 ] to var8 and add the greater of 0 and var1 [ var9 ] - var0 * var8 to var4 . set var8 to 0 . for each position var10 in var2 in decreasing $$CONSTANT$$ add var2 [ var10 ] to var8 and add the greater of 0 and var1 [ var10 ] - var0 * var8 to var5 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var4 to 0 and var8 to 0 . for each position var9 in var2 add var2 [ var9 ] to var8 and add the greater of 0 and var1 [ var9 ] - var0 * var8 to var4 . 
given integer arrays var1 , var2 and integer var0 . return the sum of ( var2 [ var6 ] - var1 [ var6 ] ) + ( ( var1 [ var6 ] - var5 ) % var0 ) + 1 for var6 in range 0 to the length of var1 ( exclusive ) and where var5 is equal to the 1 for var6 equal to 0 and var2 [ var6 - 1 ] + 1 for other values of var6 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var4 to 0 , var5 to 0 and var8 to 0 . for each position var9 in var2 add var2 [ var9 ] to var8 and add the greater of 0 and var1 [ var9 ] - var0 * var8 to var4 . set var8 to 0 . for each position var10 in var2 in decreasing $$CONSTANT$$ add var2 [ var10 ] to var8 and add the greater of 0 and var1 [ var10 ] - var0 * var8 to var5 . return " Radewoosh " if var5 > var4 , return " $$CONSTANT$$ " if var5 = var4 , return " Limak " if var5 < var4 . 
given integer arrays var1 , var2 and integer var0 . loop integer var6 in from 0 to length of var1 ( exclusive ) and set integer var4 to the sum of ( var2 [ var6 ] - var1 [ var6 ] ) + ( ( var1 [ var6 ] - var5 ) % var0 ) + 1 where var5 is equal to the 1 for var6 equal to 0 and var2 [ var6 - 1 ] + 1 for other values of var6 . 
you are given 0 - based array var0 of integer type . if last value in var0 equals 0 or 15 then return " UP " or " DOWN " , respectively . otherwise , if var0 consist of only one element then return - 1 . otherwise , if last character in var0 is larger than neighboring one then return " UP " . otherwise , return " DOWN " . 
you are given an array var0 of char type . let var6 be the number of occurences of $$CONSTANT$$ in var10 , var7 is the number of occurences of 68 in var10 , var8 - number of ' $$CONSTANT$$ ' $$CONSTANT$$ in var10 and var9 - number of occurences of other characters in var10 . 
you are given an array var0 of char type . let var6 be the number of occurences of $$CONSTANT$$ in var10 , var7 is the number of occurences of 68 in var10 , var8 - number of ' $$CONSTANT$$ ' $$CONSTANT$$ in var10 and var9 - number of occurences of other characters in var10 . assign the sum of the larger of var8 , var9 and of the maximum of var6 and var7 to var3 . assign the sum of the less of var8 , var9 and of the minimum of var6 , var7 to var4 . return ( var3 - var4 ) / 2 . 
given $$CONSTANT$$ string var2 and integers var0 and var1 , initialize var3 to var0 , var4 to var1 , var5 to var2 , var6 to var3 * ( var4 - 1 ) . add the number of pairs of consecutive different characters in var5 , multiplied by var3 * ( var4 - 1 ) , to var6 . initialize var8 to 0 and var9 to 0 . for as long as var8 < var3 - 1 , do the following actions : add 1 to var8 and continue the enclosing loop if var5 [ var8 ] = var5 [ var8 ] , set var9 to the greater of var9 and var8 + 1 , set var10 to var5 [ var8 ] and var11 to var5 [ var8 + 1 ] ; for as long as var9 < var3 and var5 [ var9 ] is equal to var10 if var9 - var8 is even , or var5 [ var9 ] is equal to var11 otherwise , add 1 to var9 ; substract var9 - var8 - 1 from var6 and add 1 to var8 . 
given $$CONSTANT$$ string var5 and integers var8 and var9 , add 1 to var8 and continue the enclosing loop if var5 [ var8 ] = var5 [ var8 ] , set var9 to the greater of var9 and var8 + 1 , set var10 to var5 [ var8 ] and var11 to var5 [ var8 + 1 ] ; for as long as var9 < var3 and var5 [ var9 ] is equal to var10 if var9 - var8 is even , or var5 [ var9 ] is equal to var11 otherwise , add 1 to var9 ; substract var9 - var8 - 1 from var6 and add 1 to var8 . 
given $$CONSTANT$$ string var5 and integers var8 and var9 , add 1 to var8 and continue the enclosing loop if var5 [ var8 ] = var5 [ var8 ] , set var9 to the greater of var9 and var8 + 1 , set var10 to var5 [ var8 ] and var11 to var5 [ var8 + 1 ] , for as long as var9 < var3 and var5 [ var9 ] is equal to var10 if var9 - var8 is even , or var5 [ var9 ] is equal to var11 otherwise , add 1 to var9 . 
given $$CONSTANT$$ string var2 and integers var0 and var1 , initialize var3 to var0 , var4 to var1 , var5 to var2 , var6 to var3 * ( var4 - 1 ) . add the number of pairs of consecutive different characters in var5 , multiplied by var3 * ( var4 - 1 ) , to var6 . 
given $$CONSTANT$$ string var5 and integers var8 and var9 , add 1 to var8 and continue the enclosing loop if var5 [ var8 ] = var5 [ var8 ] , set var9 to the greater of var9 and var8 + 1 and set var10 to var5 [ var8 ] . 
given integer var0 and integer array var1 . create char typed array var2 . assign 0 to var3 . for all var4 $$CONSTANT$$ from 0 to $$CONSTANT$$ - 1 do following operations . add var1 [ var4 ] - 1 to var3 . if moves & 1 equals 1 then add " 1 \ n " to the end of var2 . otherwise , add " 2 \ n " to the end of var2 . 
given integer var0 and integer array var1 . add var1 [ var4 ] - 1 to var3 . if moves & 1 equals 1 then add " 1 \ n " to the end of var2 . otherwise , add " 2 \ n " to the end of var2 . 
given integer var0 and integer array var1 . create char typed array var2 . assign 0 to var3 . for all var4 $$CONSTANT$$ from 0 to $$CONSTANT$$ - 1 do following operations . add var1 [ var4 ] - 1 to var3 . if moves & 1 equals 1 then add " 1 \ n " to the end of var2 . otherwise , add " 2 \ n " to the end of var2 . when the loop is ended , return var2 . 
given $$CONSTANT$$ string var2 and integers var0 and var1 , initialize var3 to var0 , var4 to var1 , var5 to var2 , var6 to var3 * ( var4 - 1 ) . add the number of pairs of consecutive different characters in var5 , multiplied by var3 * ( var4 - 1 ) , to var6 . initialize var8 to 0 and var9 to 0 . for as long as var8 < var3 - 1 , do the following actions : add 1 to var8 and continue the enclosing loop if var5 [ var8 ] = var5 [ var8 ] , set var9 to the greater of var9 and var8 + 1 , set var10 to var5 [ var8 ] and var11 to var5 [ var8 + 1 ] ; for as long as var9 < var3 and var5 [ var9 ] is equal to var10 if var9 - var8 is even , or var5 [ var9 ] is equal to var11 otherwise , add 1 to var9 ; substract var9 - var8 - 1 from var6 and add 1 to var8 . return var6 . 
given an array var0 . initialize var2 to 0 , var6 to an empty array . for each element var4 in var0 , add var4 - 1 to var2 and push the value of 2 - ( var2 modulo 2 ) into var6 . 
given an array var0 . initialize var2 to 0 , var6 to an empty array . for each element var4 in var0 , add var4 - 1 to var2 and push the value of 2 - ( var2 modulo 2 ) into var6 . return var6 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . you have to set var7 to var0 divided by var1 ( rounded down ) , var8 to ( var2 * var7 * var1 ) plus ( the maximum between var7 - 1 and zero ) multiplicated by var4 . you have to subtract var7 * var1 to var0 . if var0 * var3 is less than or equal to var0 * var2 + var4 you have to add var0 * var3 to var8 and return var8 ; otherwise you have to add var0 * var2 + var4 to var8 and return var8 . 
given integers var1 , var2 , var3 , var4 , var5 . initialize var6 to var1 , var7 to var2 , var8 to var3 , var9 to var4 , var10 to var5 , var11 to some big value . if var7 is not less than var6 , initialize var11 to var6 * var8 ; else initialize var11 to var7 * var8 . subtract var7 from var6 . initialize var12 to var8 * var7 + var10 , var13 to var9 * var7 , var14 to var6 / var7 . if var12 is not greater than var13 , perform the following operations . add var12 * var14 to var11 . subtract var14 * var7 from var6 . if var6 is less than 0 , set var12 to var6 * var8 + var10 , var13 to var6 * var9 and add the minimum between var13 , var12 to var11 ; else add var6 * var9 to var11 . return var11 . 
given integers var1 , var2 , var3 , var4 , var5 . initialize var6 to var1 , var7 to var2 , var8 to var3 , var9 to var4 , var10 to var5 , var11 to some big value . if var7 is not less than var6 , initialize var11 to var6 * var8 ; else initialize var11 to var7 * var8 . subtract var7 from var6 . initialize var12 to var8 * var7 + var10 , var13 to var9 * var7 , var14 to var6 / var7 . if var12 is not greater than var13 , perform the following operations . add var12 * var14 to var11 . subtract var14 * var7 from var6 . if var6 is less than 0 , set var12 to var6 * var8 + var10 , var13 to var6 * var9 and add the minimum between var13 , var12 to var11 ; else add var6 * var9 to var11 . 
given integers var7 , var8 , var6 . initialize var11 to var7 * var8 . subtract var7 from var6 . initialize var12 to var8 * var7 + var10 , var13 to var9 * var7 , var14 to var6 / var7 . if var12 is not greater than var13 , perform the following operations . add var12 * var14 to var11 . subtract var14 * var7 from var6 . if var6 is less than 0 , set var12 to var6 * var8 + var10 , var13 to var6 * var9 and add the minimum between var13 , var12 to var11 ; else add var6 * var9 to var11 . 
given integers var12 , var14 , var11 , var6 . add var12 * var14 to var11 . subtract var14 * var7 from var6 . if var6 is less than 0 , set var12 to var6 * var8 + var10 , var13 to var6 * var9 and add the minimum between var13 , var12 to var11 . 
you are given integers var0 , var1 , var2 , var3 , var4 . initialize integers var5 , var6 . decrease the value of var0 by var1 . assign the value $$CONSTANT$$ * $$CONSTANT$$ to var5 . if var0 is bigger than or equal to var1 then do following operations . if the value of ( var1 * var2 ) + var4 is less than the value $$CONSTANT$$ * b then do following operations . assign the value d / $$CONSTANT$$ to var6 . increase the value of var5 by var6 * ( ( var1 * var2 ) + var4 ) . assign the value d % $$CONSTANT$$ to $$CONSTANT$$ . if the value ( var0 * var2 ) + var4 is less than the value d * b and var0 does not equal to 0 then assign the value ( var5 + ( var0 * var2 ) ) + var4 to var5 . otherwise , increase the value of var5 by d * b . if the value of ( var1 * var2 ) + var4 was not less than $$CONSTANT$$ * b then increase the value of var5 by d * b . if the value of var0 was not bigger than or equal to var1 then if the value of d * $$CONSTANT$$ + t is less than d * b then assign the value ( var5 + ( var0 * var2 ) ) + var4 to var5 . otherwise , increase the value of var5 by d * b . afther this , return var5 . 
you are given integers var0 , var1 , var2 , var3 , var4 . initialize integers var5 , var6 . decrease the value of var0 by var1 . assign the value $$CONSTANT$$ * $$CONSTANT$$ to var5 . if var0 is bigger than or equal to var1 then do following operations . if the value of ( var1 * var2 ) + var4 is less than the value $$CONSTANT$$ * b then do following operations . assign the value d / $$CONSTANT$$ to var6 . increase the value of var5 by var6 * ( ( var1 * var2 ) + var4 ) . assign the value d % $$CONSTANT$$ to $$CONSTANT$$ . if the value ( var0 * var2 ) + var4 is less than the value d * b and var0 does not equal to 0 then assign the value ( var5 + ( var0 * var2 ) ) + var4 to var5 . otherwise , increase the value of var5 by d * b . if the value of ( var1 * var2 ) + var4 was not less than $$CONSTANT$$ * b then increase the value of var5 by d * b . if the value of var0 was not bigger than or equal to var1 then if the value of d * $$CONSTANT$$ + t is less than d * b then assign the value ( var5 + ( var0 * var2 ) ) + var4 to var5 . otherwise , increase the value of var5 by d * b . 
you are given integers var0 , var1 , var2 , var3 , var4 . initialize integers var5 , var6 . assign the value d / $$CONSTANT$$ to var6 . increase the value of var5 by var6 * ( ( var1 * var2 ) + var4 ) . assign the value d % $$CONSTANT$$ to $$CONSTANT$$ . if the value ( var0 * var2 ) + var4 is less than the value d * b and var0 does not equal to 0 then assign the value ( var5 + ( var0 * var2 ) ) + var4 to var5 . otherwise , increase the value of var5 by d * b . 
you are given integer var0 , var1 . create an array var2 consisting of values var1 , var1 , var1 . assign 0 to result . while at least one of elements var2 [ 0 ] , var2 [ 1 ] , var2 [ 2 ] does not equal var0 do following operations . sort the array var2 . assign the minimum of var2 [ 1 ] + var2 [ 2 ] - 1 and var0 to var0 . increment the result . 
you are given integer var0 , var1 . sort the array var2 . assign the minimum of var2 [ 1 ] + var2 [ 2 ] - 1 and var0 to var0 . increment the result . 
given array var0 of integer type . initialize var0 to new array var3 . sort the array var3 . let var2 be the length of var0 . assign 0 to var4 , var6 . for all var7 $$CONSTANT$$ from 0 to var7 < var2 do this . if var4 [ var7 ] is larger than or equal to var4 then increment var6 and increment var4 by var3 [ var7 ] . after the loop is ended , return var6 . 
you are given integer var0 , var1 . sort the array var2 . assign the minimum of var2 [ 1 ] + var2 [ 2 ] - 1 and var0 to var0 . 
you are given integer var0 , var1 . create an array var2 consisting of values var1 , var1 , var1 . assign 0 to result . while at least one of elements var2 [ 0 ] , var2 [ 1 ] , var2 [ 2 ] does not equal var0 do following operations . sort the array var2 . assign the minimum of var2 [ 1 ] + var2 [ 2 ] - 1 and var0 to var0 . increment the result . when all of the elements of var2 become equal var0 , exit from the loop . return the result . 
given array var2 . assign 0 to var0 and to var1 . assign the value $$CONSTANT$$ ( x , var1 ) to var3 . let $$CONSTANT$$ . x be the number of appearances of $$CONSTANT$$ in var2 minus the number of appearances of $$CONSTANT$$ , and $$CONSTANT$$ . y be the number of appearances of $$CONSTANT$$ in var2 minus the number of appearances of rest of values . 
given array var2 . assign 0 to var0 and to var1 . assign the value $$CONSTANT$$ ( x , var1 ) to var3 . let $$CONSTANT$$ . x be the number of appearances of $$CONSTANT$$ in var2 minus the number of appearances of $$CONSTANT$$ , and $$CONSTANT$$ . y be the number of appearances of $$CONSTANT$$ in var2 minus the number of appearances of rest of values . return the half of sum of modules $$CONSTANT$$ . x and $$CONSTANT$$ . y . 
given $$CONSTANT$$ string var0 , initialize var1 to length of var0 , var2 to array of integers of length 4 . for each position var3 in var0 increase var2 [ 0 ] by 1 if var0 [ var3 ] = " $$CONSTANT$$ " , increase var2 [ 1 ] by 1 if var0 [ var3 ] = " $$CONSTANT$$ " , increase var2 [ 2 ] by 1 if var0 [ var3 ] = " $$CONSTANT$$ " , increase var2 [ 3 ] by 1 if var0 [ var3 ] = " $$CONSTANT$$ " . 
given $$CONSTANT$$ string var0 , initialize var1 to length of var0 , var2 to array of integers of length 4 . for each position var3 in var0 increase var2 [ 0 ] by 1 if var0 [ var3 ] = " $$CONSTANT$$ " , increase var2 [ 1 ] by 1 if var0 [ var3 ] = " $$CONSTANT$$ " , increase var2 [ 2 ] by 1 if var0 [ var3 ] = " $$CONSTANT$$ " , increase var2 [ 3 ] by 1 if var0 [ var3 ] = " $$CONSTANT$$ " . return - 1 if var1 is odd . otherwise , set var4 to absolute value of var2 [ 0 ] - var2 [ 1 ] , var5 to absolute value of var2 [ 2 ] - var2 [ 3 ] , return var4 if var4 = var5 , set var6 to absolute value of var4 - var5 and return the minimum of var4 and var5 plus var6 / 2 ( rounded down ) otherwise . 
given an array var0 . initiailize var6 to an empty array , var2 to 2 . for each var4 in var0 , if var4 is even , set var2 to 3 - var2 , push var2 into var6 . 
given array var0 of integer type . initialize var0 to new array var3 . sort the array var3 . let var2 be the length of var0 . assign 0 to var4 , var6 . for all var7 $$CONSTANT$$ from 0 to var7 < var2 do this . if var4 [ var7 ] is larger than or equal to var4 then increment var6 and increment var4 by var3 [ var7 ] . 
given an array var0 . initiailize var6 to an empty array , var2 to 2 . for each var4 in var0 , if var4 is even , set var2 to 3 - var2 , push var2 into var6 . return var6 . 
given array var0 of integer type . let var2 be the length of var0 . assign 0 to var4 . initialize var0 to new array var3 . sort the array var3 . 
given array var0 of integer type . let var2 be the length of var0 . assign 0 to var4 . initialize var0 to new array var3 . 
given an integer var5 and $$CONSTANT$$ real var6 , initialize var7 to var5 , var1 to $$CONSTANT$$ 2 - dimensional array of reals of dimensions var7 + 1 and var7 + 1 , var0 to 0 . set var1 [ 0 ] [ 0 ] to var6 . for each integer var8 from 0 to var7 - 1 ( both inclusive ) iterate over all integers var9 from 0 to var7 - 1 ( both inclusive ) and if var1 [ var8 ] [ var9 ] > = 1 , then increase var0 by 1 , decrease var1 [ var8 ] [ var9 ] by 1 , increase var1 [ var8 + 1 ] [ var9 ] by var1 [ var8 ] [ var9 ] / 2 and increase var1 [ var8 + 1 ] [ var9 + 1 ] by var1 [ var8 ] [ var9 ] / 2 . 
given arrays of integers var1 and var3 and integers var2 and var0 , set var1 [ var2 ] to var1 [ var2 - 1 ] + var1 [ var2 - 2 ] . append var2 - 1 to the end of var3 and break from the enclosing loop if var1 [ var2 ] = var0 , append var2 - 2 to the end of var3 and break from the enclosing loop if var1 [ var2 ] > var0 . 
given integers var2 , var3 and var4 , set var4 to the maximum value of var2 and var3 . then decrement var2 if it is positive . then decrement var3 if it is positive . 
given integers var2 , var3 and var4 , set var4 to the maximum value of var2 and var3 . then decrement var2 if it is positive . 
given integers var2 , var3 and var4 , set var4 to the maximum value of var2 and var3 . 
given an array of integers var0 , initialize var1 to length of var0 . if var1 = 1 , then return " DOWN " if var0 [ 0 ] = 15 , return " UP " if var0 [ 0 ] = 0 , return " - 1 " otherwise . otherwise , if var0 [ var1 - 1 ] = 0 and var0 [ var1 - 2 ] = 1 , then return " UP " , otherwise , if var0 [ var1 - 1 ] = 15 and var0 [ var1 - 2 ] = $$CONSTANT$$ , then return " DOWN " , otherwise , if var0 [ var1 - 1 ] > var0 [ var1 - 2 ] , then return " UP " , otherwise return " DOWN " . 
given an integer var4 , and an integer var5 . let ' $$CONSTANT$$ consider an array of size 3 whose values are equal to var5 . in $$CONSTANT$$ single move , you can change any value in this array to any other one , as long as the the sum of any two numbers from this array is larger than than the other $$CONSTANT$$ number . return the minimum number of moves required to make all the numbers in this array larger than or equal to var4 . 
given 0 - based array of integers var6 . set var6 [ 0 ] to minimum of given var0 and ( var6 [ 1 ] + var6 [ 2 ] - 1 ) . 
given integers var2 , var3 , let var4 be the larger of the two integers . then decrement var2 if it is positive ; then decrement var3 if it is positive . return the concatenation of var4 and the value of 1 + var2 + var3 , separated by space . 
given 0 - based array of integers var6 . set var6 [ 0 ] to minimum of given var0 and ( var6 [ 1 ] + var6 [ 2 ] - 1 ) . then sort var6 and increment given var5 . 
given $$CONSTANT$$ 2 - dimensional array of reals var1 and integers var7 , var8 and var0 , for each integer var9 from 0 to var7 - 1 ( both inclusive ) if var1 [ var8 ] [ var9 ] > = 1 , then increase var0 by 1 , decrease var1 [ var8 ] [ var9 ] by 1 , increase var1 [ var8 + 1 ] [ var9 ] by var1 [ var8 ] [ var9 ] / 2 and increase var1 [ var8 + 1 ] [ var9 + 1 ] by var1 [ var8 ] [ var9 ] / 2 . 
given integers var0 , var1 . create real typed matrix var2 of sizes var0 , var0 . for all var3 $$CONSTANT$$ from 0 to t - 1 do following operations . add 1 to var2 [ 0 ] [ 0 ] . for all var4 $$CONSTANT$$ from 0 to n - 2 , for each element in var2 [ var4 ] with position var5 which is not less than 1 , do following operations . add to var2 [ ( var4 + 1 ) ] [ var5 ] and to var2 [ ( var4 + 1 ) ] [ ( var5 + 1 ) ] the value var2 [ var4 ] [ var5 ] - 1 / 2 and assign 1 to var2 [ var4 ] [ var5 ] . let var7 be the number of non - zero elements in var2 . 
given integers var0 , var1 . create real typed matrix var2 of sizes var0 , var0 . for all var3 $$CONSTANT$$ from 0 to t - 1 do following operations . add 1 to var2 [ 0 ] [ 0 ] . for all var4 $$CONSTANT$$ from 0 to n - 2 , for each element in var2 [ var4 ] with position var5 which is not less than 1 , do following operations . add to var2 [ ( var4 + 1 ) ] [ var5 ] and to var2 [ ( var4 + 1 ) ] [ ( var5 + 1 ) ] the value var2 [ var4 ] [ var5 ] - 1 / 2 and assign 1 to var2 [ var4 ] [ var5 ] . 
given integers var0 , var1 . add 1 to var2 [ 0 ] [ 0 ] . for all var4 $$CONSTANT$$ from 0 to n - 2 , for each element in var2 [ var4 ] with position var5 which is not less than 1 , do following operations . add to var2 [ ( var4 + 1 ) ] [ var5 ] and to var2 [ ( var4 + 1 ) ] [ ( var5 + 1 ) ] the value var2 [ var4 ] [ var5 ] - 1 / 2 and assign 1 to var2 [ var4 ] [ var5 ] . 
given integers var0 , var1 . for each element in var2 [ var4 ] with position var5 which is not less than 1 and var4 is not last row of var2 , do following operations . add to var2 [ ( var4 + 1 ) ] [ var5 ] and to var2 [ ( var4 + 1 ) ] [ ( var5 + 1 ) ] the value var2 [ var4 ] [ var5 ] - 1 / 2 and assign 1 to var2 [ var4 ] [ var5 ] . 
given integers var0 , var1 . let var7 be the number of non - zero elements in var2 . 
given an integer var5 and $$CONSTANT$$ real var6 , initialize var7 to var5 , var1 to $$CONSTANT$$ 2 - dimensional array of reals of dimensions var7 + 1 and var7 + 1 , var0 to 0 . set var1 [ 0 ] [ 0 ] to var6 . for each integer var8 from 0 to var7 - 1 ( both inclusive ) iterate over all integers var9 from 0 to var7 - 1 ( both inclusive ) and if var1 [ var8 ] [ var9 ] > = 1 , then increase var0 by 1 , decrease var1 [ var8 ] [ var9 ] by 1 , increase var1 [ var8 + 1 ] [ var9 ] by var1 [ var8 ] [ var9 ] / 2 and increase var1 [ var8 + 1 ] [ var9 + 1 ] by var1 [ var8 ] [ var9 ] / 2 . return var0 . 
given an array var0 . initialize var2 to var0 . sort elements of var2 in increasing $$CONSTANT$$ . initialize var4 , var5 to 0 . for each var6 from 0 to the length of var0 exclusive , if var4 is greater than var2 [ var6 ] , increase var5 by 1 ; else add var2 [ var6 ] to var4 . 
given an array var0 . initialize var2 to var0 . sort elements of var2 in increasing $$CONSTANT$$ . 
given an array var0 . initialize var2 to var0 . 
given 0 - based integer array var0 . set array var2 to var0 . sort var2 . initialize var4 to first element of var2 and var5 to zero . starting from second element check all elements whether it is smaller than var4 , if so increment var5 . otherwise , increase var4 by current element . 
given 0 - based integer array var0 . set array var2 to var0 . sort var2 . initialize var4 to first element of var2 . 
given 0 - based integer array var0 . set array var2 to var0 . 
given an array var0 . initialize var2 to var0 , var1 to the length of var0 . sort elements of var2 in increasing $$CONSTANT$$ . initialize var4 , var5 to 0 . for each var6 from 0 to the length of var0 exclusive , if var4 is greater than var2 [ var6 ] , increase var5 by 1 ; else add var2 [ var6 ] to var4 . return the value of var1 - var5 . 
given integer array var0 . assign var0 to var4 . sort var4 . assign var4 [ 0 ] to var2 . for each var5 from 1 to n - 1 , if var4 [ var5 ] is not less than var2 then increment var3 and add var4 [ var5 ] to var2 . 
given integer array var0 . assign var0 to var4 . sort var4 . assign var4 [ 0 ] to var2 . 
given 0 - based integer array var0 . set array var2 to var0 . sort var2 . initialize var4 to first element of var2 and var5 to zero . starting from second element check all elements whether it is smaller than var4 , if so increment var5 . otherwise , increase var4 by current element . after checking , return ( length of var2 - var5 ) . 
given integer array var0 . assign var0 to var4 . sort var4 . assign var4 [ 0 ] to var2 . for each var5 from 1 to n - 1 , if var4 [ var5 ] is not less than var2 then increment var3 and add var4 [ var5 ] to var2 . return var3 . 
given integer array var0 . assign var0 to var4 . sort var4 . assign var4 [ 0 ] to var2 . 
given integer array var0 . assign var0 to var4 . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var4 and sort var4 in non - decreasing $$CONSTANT$$ . initialize var6 to 1 and var7 to var4 [ 0 ] . for each position var8 in var4 , starting from 1 , add 1 to var6 and add var4 [ var8 ] to var7 if var4 [ var8 ] > = var7 , continue the loop otherwise . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var4 and sort var4 in non - decreasing $$CONSTANT$$ . initialize var6 to 1 and var7 to var4 [ 0 ] . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . initialize var3 to 0 and var4 to 0 . for each position var5 in var2 add var2 [ var5 ] to var3 and add 1 to var4 if var3 < = var2 [ var5 ] . return var4 . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var4 and sort var4 in non - decreasing $$CONSTANT$$ . initialize var6 to 1 and var7 to var4 [ 0 ] . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var4 and sort var4 in non - decreasing $$CONSTANT$$ . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var4 . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var4 and sort var4 in non - decreasing $$CONSTANT$$ . initialize var6 to 1 and var7 to var4 [ 0 ] . for each position var8 in var4 , starting from 1 , add 1 to var6 and add var4 [ var8 ] to var7 if var4 [ var8 ] > = var7 , continue the loop otherwise . return var6 . 
given an array of integers var1 , initialize var2 to length of var1 , var5 to 0 . $$CONSTANT$$ the array var1 into an array var3 and sort the array var3 . initialize var6 to 0 . for each position var7 in var3 increase var6 by 1 and add var3 [ var7 ] to var5 if var3 [ var7 ] > = var5 . 
given an array of integers var3 and integers var7 , var6 and var5 , increase var6 by 1 and add var3 [ var7 ] to var5 if var3 [ var7 ] > = var5 . 
given an array of integers var1 , initialize var2 to length of var1 , var5 to 0 . $$CONSTANT$$ the array var1 into an array var3 and sort the array var3 . 
given an array of integers var1 , initialize var2 to length of var1 . $$CONSTANT$$ the array var1 into an array var3 . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . initialize var3 to 0 and var4 to 0 . for each position var5 in var2 add var2 [ var5 ] to var3 and add 1 to var4 if var3 < = var2 [ var5 ] . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . initialize var3 to 0 . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var2 . 
given an array of integers var1 , initialize var2 to length of var1 , var5 to 0 . $$CONSTANT$$ the array var1 into an array var3 and sort the array var3 . initialize var6 to 0 . for each position var7 in var3 increase var6 by 1 and add var3 [ var7 ] to var5 if var3 [ var7 ] > = var5 . return var5 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var1 to the length of var0 . you have to create an array of numbers var2 with the elements of var0 sorted from less to greater . you have to set var4 to zero and var5 to zero . for each var6 in var2 if var4 is less than or equal to var2 [ var6 ] you have to add 1 to var5 and add var2 [ var6 ] to var4 . you have to return var5 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var1 to the length of var0 . you have to create an array of numbers var2 with the elements of var0 sorted from less to greater . you have to set var4 to zero and var5 to zero . for each var6 in var2 if var4 is less than or equal to var2 [ var6 ] you have to add 1 to var5 and add var2 [ var6 ] to var4 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var1 to the length of var0 . you have to create an array of numbers var2 with the elements of var0 sorted from less to greater . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var1 to the length of var0 . you have to create an array of numbers var2 with the elements of var0 . 
given integers var0 , var1 and an array var2 of integer type . for all var8 $$CONSTANT$$ from 0 to var8 < var5 , if var8 is divisible by 2 then exchange the values of var6 [ var7 ] [ 0 ] and var6 [ var7 ] [ 1 ] . otherwise , exchange the values of var6 [ var7 ] [ 1 ] and var6 [ var7 ] [ 2 ] . 
given integers var0 , var1 and an array var2 of integer type . assign var0 , var1 , n % 6 to var3 , var4 , var5 , respectively . create $$CONSTANT$$ matrix var6 consisting of values 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 . shift the columns in var6 to the $$CONSTANT$$ , consequently . 
given integers var0 and var1 . initialize var2 to boolean array and set var2 [ var1 ] to true . while var0 is not divisible by 6 , perform the following operatons . if var0 is even , swap var2 [ 1 ] and var2 [ 2 ] ; else swap var2 [ 1 ] and var2 [ 0 ] . decrease var0 by 1 . return the $$CONSTANT$$ var5 such that var2 [ var5 ] is true . 
given integers var0 and var1 . initialize var2 to boolean array and set var2 [ var1 ] to true . while var0 is not divisible by 6 , perform the following operatons . if var0 is even , swap var2 [ 1 ] and var2 [ 2 ] ; else swap var2 [ 1 ] and var2 [ 0 ] . decrease var0 by 1 . return the $$CONSTANT$$ var5 such that var2 [ var5 ] is true . 
given integers var0 and var1 . initialize var2 to boolean array and set var2 [ var1 ] to true . while var0 is not divisible by 6 , perform the following operatons . if var0 is even , swap var2 [ 1 ] and var2 [ 2 ] ; else swap var2 [ 1 ] and var2 [ 0 ] . decrease var0 by 1 . 
given integers var0 , var1 and an array var2 of integer type . assign var0 , var1 , n % 6 to var3 , var4 , var5 , respectively . create $$CONSTANT$$ matrix var6 consisting of values 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 . shift the columns in var6 to the $$CONSTANT$$ , consequently . 
given integers var0 and var1 . initialize var2 to boolean array and set var2 [ var1 ] to true . while var0 is not divisible by 6 , perform the following operatons . if var0 is even , swap var2 [ 1 ] and var2 [ 2 ] ; else swap var2 [ 1 ] and var2 [ 0 ] . decrease var0 by 1 . 
given an integer var0 and an array var2 . if var0 is even , swap var2 [ 1 ] and var2 [ 2 ] ; else swap var2 [ 1 ] and var2 [ 0 ] . decrease var0 by 1 . 
you are given an integer var0 . create an array var1 of char type . if var0 is even number then assign var0 / 2 to var2 . otherwise , assign ( n - 3 ) / 2 to var2 and add 7 to the end of var1 . add 1 to the end of var1 var2 number of times . 
you are given an integer var0 . create an array var1 of char type . if var0 is even number then assign var0 / 2 to var2 . otherwise , assign ( n - 3 ) / 2 to var2 and add 7 to the end of var1 . 
you are given an integer var0 . create an array var1 of char type . if var0 is even number then assign var0 / 2 to var2 . otherwise , assign ( n - 3 ) / 2 to var2 and add 7 to the end of var1 . 
you are given an integer var0 . create an array var1 of char type . if var0 is even number then assign var0 / 2 to var2 . otherwise , assign ( n - 3 ) / 2 to var2 and add 7 to the end of var1 . add 1 to the end of var1 var2 number of times . return var1 . 
given $$CONSTANT$$ string var4 and integers var0 , var1 , var2 and var3 , initialize var12 to empty array of integers . split var4 by " : " and store the results in var5 , set var6 to var5 [ 0 ] , converted to integer , set var7 to var5 [ 1 ] , converted to integer , set var8 to var6 * $$CONSTANT$$ + var7 , set var9 to var8 + var1 , set var10 to 0 , set var11 to $$CONSTANT$$ . for as long as var11 < 1440 , add var2 to var11 and continue the loop if var11 < = var8 - var3 , add 1 to var10 and add var2 to var11 if var11 < var9 , append var10 to the end of var12 and return var12 otherwise . 
given an array of integers var12 and integers var11 , var8 , var3 , var9 and var10 , continue the enclosing loop if var11 < = var8 - var3 , add 1 to var10 if var11 < var9 , append var10 to the end of var12 and return var12 otherwise . 
given 0 - based , integer typed arrays var0 , var1 , var2 . create 0 - based , integer typed array var6 at var5 th position containing the sum of elements of var0 at positions from var1 [ var5 ] to var2 [ var5 ] . assign to var11 the sum of positive values in var6 . 
given 0 - based , integer typed arrays var0 , var1 , var2 . create 0 - based , integer typed array var6 at var5 th position containing the sum of elements of var0 at positions from var1 [ var5 ] to var2 [ var5 ] . 
given 0 - based , integer typed arrays var0 , var1 , var2 . increase var6 [ var5 ] by the sum of elements of var0 at positions from var8 to var9 . 
given integer var0 . for each var1 from 2 to the square root of var0 rounded down inclusive if var0 % var1 equals 0 then return false . 
given an integer var0 . return the maximum index of fibonacci number which is not greater than var0 . 
given an integer var0 . initialize var1 to an array consisting of first fibonacci numbers less than $$CONSTANT$$ . 
given integer var0 . return true if var0 is prime and false otherwise . 
given an integer var0 . initialize var1 to an array consisting of first fibonacci numbers less than $$CONSTANT$$ . 
given an array var1 and an integer var2 . initialize var1 [ var2 ] to var1 [ $$CONSTANT$$ - 1 ] + var1 [ $$CONSTANT$$ - 2 ] . 
you are given an integer var0 . initialize integers var3 , var4 , var1 , var2 , an array var5 of type integer . starting from var4 = 0 do following operations . assign the value ( var1 + var2 ) + 1 to var3 . if var0 is less than var3 then add var4 to var5 and exit the current function . assign the value of var2 to var1 . assign the value of var3 to var2 . increase var4 by 1 . 
you are given an integer var0 . initialize integers var3 , var4 , var1 , var2 , an array var5 of type integer . assign the value ( var1 + var2 ) + 1 to var3 . if var0 is less than var3 then add var4 to var5 and exit the current function . assign the value of var2 to var1 . assign the value of var3 to var2 . increase var4 by 1 . 
you are given an integer var0 . initialize integers var3 , var4 , var1 , var2 , an array var5 of type integer . assign the value ( var1 + var2 ) + 1 to var3 . if var0 is less than var3 then add var4 to var5 and exit the current function . 
given an integer var0 , initialize var6 to empty array of integers . append 1 to the end of var6 and return var6 if var0 = 2 . initialize var1 to 2 , var2 to 2 , var3 to 1 , var4 to 1 . for as long as var1 < = var0 - 1 , set var5 to var3 + var4 , add var5 to var1 , set var4 to var3 , set var3 to var5 , break from the enclosing loop if var1 > = var0 , add 1 to var2 . 
given integers var0 , var1 , var2 , var3 , var4 and var5 , set var5 to var3 + var4 , add var5 to var1 , set var4 to var3 , set var3 to var5 , break from the enclosing loop if var1 > = var0 , add 1 to var2 . 
you are given an integer var0 . initialize integers var3 , var4 , var1 , var2 , an array var5 of type integer . starting from var4 = 0 do following operations . assign the value ( var1 + var2 ) + 1 to var3 . if var0 is less than var3 then add var4 to var5 and exit the current function . assign the value of var2 to var1 . assign the value of var3 to var2 . increase var4 by 1 . after the loop is ended , return var5 . 
you are given an array of strings var1 , an array of $$CONSTANT$$ var4 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var5 , an index var6 . you have to set var7 to true . for each var8 between 0 and var2 - 2 , if var4 [ var8 ] is equal to false and var1 [ var8 ] [ var6 ] is greater than var1 [ var8 + 1 ] [ var6 ] , set var7 to false . if var7 is equal to false add 1 to var5 , otherwise for each var9 between 0 and var2 - 2 , if var1 [ var9 ] [ var6 ] is less than var1 [ var9 + 1 ] [ var6 ] set var4 [ var9 ] to true . 
you are given an array of strings var1 , an array of $$CONSTANT$$ var4 , $$CONSTANT$$ number var2 , an index var6 . you have to set var7 to true . for each var8 between 0 and var2 - 2 , if var4 [ var8 ] is equal to false and var1 [ var8 ] [ var6 ] is greater than var1 [ var8 + 1 ] [ var6 ] , set var7 to false . 
given an integer var0 , initialize var6 to empty array of integers . append 1 to the end of var6 and return var6 if var0 = 2 . initialize var1 to 2 , var2 to 2 , var3 to 1 , var4 to 1 . for as long as var1 < = var0 - 1 , set var5 to var3 + var4 , add var5 to var1 , set var4 to var3 , set var3 to var5 , break from the enclosing loop if var1 > = var0 , add 1 to var2 . append var2 to the end of var6 and return var6 . 
you are given $$CONSTANT$$ number var2 , an array of strings var1 , an array of $$CONSTANT$$ var4 , an index var6 . for each var9 between 0 and var2 - 2 , if var1 [ var9 ] [ var6 ] is less than var1 [ var9 + 1 ] [ var6 ] set var4 [ var9 ] to true . 
given integer var0 . if var0 is odd value then return " black " . otherwise , return strings " white " , " 1 2 " in separate lines . 
given integer var0 . if var0 is odd value then return " black " . otherwise , return strings " white " , " 1 2 " in separate lines . 
given an array of strings var1 and an integer var0 , initialize var2 to length of var1 , var3 to var0 , var5 to var3 / 2 ( rounded down ) and var6 to 1 . for each position var7 in var1 in decreasing $$CONSTANT$$ , except for var2 - 1 , add var6 * var3 to var5 ; multiply var6 by 2 ; add var3 / 2 ( rounded down ) to var5 and increase var6 by 1 if var1 [ var7 ] = " halfplus " . 
given an array of strings var1 and integers var5 , var6 , var3 , var7 , add var6 * var3 to var5 ; multiply var6 by 2 ; add var3 / 2 ( rounded down ) to var5 and increase var6 by 1 if var1 [ var7 ] = " halfplus " . 
given an array of strings var1 and an integer var0 , initialize var2 to length of var1 , var3 to var0 and var5 to var3 / 2 ( rounded down ) . 
given an array of strings var1 and an integer var0 , initialize var2 to length of var1 and var3 to var0 . 
given $$CONSTANT$$ string var4 and integers var0 , var1 , var2 and var3 , initialize var12 to empty array of integers . split var4 by " : " and store the results in var5 , set var6 to var5 [ 0 ] , converted to integer , set var7 to var5 [ 1 ] , converted to integer , set var8 to var6 * $$CONSTANT$$ + var7 , set var9 to var8 + var1 , set var10 to 0 , set var11 to $$CONSTANT$$ . for as long as var11 < 1440 , add var2 to var11 and continue the loop if var11 < = var8 - var3 , add 1 to var10 and add var2 to var11 if var11 < var9 , append var10 to the end of var12 and return var12 otherwise . if the loop above ended successfully , append var10 to the end of var12 and return var12 . 
given an array of strings var1 and an integer var0 , initialize var2 to length of var1 , var3 to var0 , var5 to var3 / 2 ( rounded down ) and var6 to 1 . for each position var7 in var1 in decreasing $$CONSTANT$$ , except for var2 - 1 , add var6 * var3 to var5 ; multiply var6 by 2 ; add var3 / 2 ( rounded down ) to var5 and increase var6 by 1 if var1 [ var7 ] = " halfplus " . return var5 . 
given 0 - based , integer typed arrays var0 , var1 , var2 . create 0 - based , integer typed array var6 at var5 th position containing the sum of elements of var0 at positions from var1 [ var5 ] to var2 [ var5 ] . return the sum of positive values in var6 . 
given an integer var0 . return the index of the $$CONSTANT$$ fibonacci number which is not greater than var0 . 
given an integer var0 . return the index of the $$CONSTANT$$ fibonacci number which is not greater than var0 . 
you are given $$CONSTANT$$ number var0 and an array of strings var1 . set var2 to the length of var1 . you have to create an array of $$CONSTANT$$ var4 of length var2 initializated with false . set var5 to zero . for each var6 between 0 and var0 - 1 you have to , set var7 to true , for each var8 between 0 and var2 - 2 , if var4 [ var8 ] is equal to false and var1 [ var8 ] [ var6 ] is greater than var1 [ var8 + 1 ] [ var6 ] , set var7 to false ; if var7 is equal to false add 1 to var5 , otherwise for each var9 between 0 and var2 - 2 , if var1 [ var9 ] [ var6 ] is less than var1 [ var9 + 1 ] [ var6 ] set var4 [ var9 ] to true . return var5 . 
given an integer var0 . return the maximum index of fibonacci number which is not greater than var0 . 
given an array var0 . initialize var4 to an empty array , var1 to the length of var0 . for each var3 from 0 to var1 - 1 exclusive , perform the following operations . if var0 [ var3 ] is less than 0 , return " NO " . if var0 [ var3 ] is odd , subtract 1 from var0 [ var3 + 1 ] . 
given arrays var0 , var4 and an integer var3 . if var0 [ var3 ] is less than 0 , return " NO " . if var0 [ var3 ] is odd , subtract 1 from var0 [ var3 + 1 ] . 
given $$CONSTANT$$ boolean var2 , an array of integers var0 which uses 0 - based indexing . set var2 to zero . iterate var0 with index var3 from the beginning to end , if var2 is true , set var0 [ var3 ] to var0 [ var3 ] - 1 . if var0 [ var3 ] is smaller than zero stop iterating . if var0 [ var3 ] is even , set var2 to false , or true otherwise . 
given $$CONSTANT$$ boolean var2 , an array of integers var0 , and an index var3 into var0 . if var2 is true , set var0 [ var3 ] to var0 [ var3 ] - 1 . if var0 [ var3 ] is smaller than zero break from the enclosing loop . if var0 [ var3 ] is even , set var2 to false , or true otherwise . 
given arrays var0 , var6 and integers var5 , var2 . initialize var4 to var0 [ var5 ] . if var4 is even , set var2 to 3 - var2 . push var2 into var6 . 
given an array var0 . initialize var4 to an empty array , var1 to the length of var0 . for each var3 from 0 to var1 - 1 exclusive , perform the following operations . if var0 [ var3 ] is less than 0 , return " NO " . if var0 [ var3 ] is odd , subtract 1 from var0 [ var3 + 1 ] . return " YES " . 
given an array var0 and integers var5 , var2 . initialize var4 to var0 [ var5 ] . if var4 is even , set var2 to 3 - var2 . 
given $$CONSTANT$$ boolean var2 , an array of integers var0 which uses 0 - based indexing . set var2 to zero . iterate var0 with index var3 from the beginning to end , if var2 is true , set var0 [ var3 ] to var0 [ var3 ] - 1 . if var0 [ var3 ] is smaller than zero stop iterating . if var0 [ var3 ] is even , set var2 to false , or true otherwise . after finishing iterating , return " NO " if var2 is true or return " YES " otherwise . 
given an array var0 . initialize var6 to an empty array , var3 to 1 . for each var5 from 0 to the length of var0 exclusive , perform the following operations . if var0 [ var5 ] is even , set var4 to var3 and push var3 into var6 ; else if var3 equals 1 , set var4 to 2 , push 2 into var6 ; else set var4 to 1 , push 1 into var6 . if var0 [ var5 ] not equals 1 , if var4 equals 1 , set var3 to 2 ; else set var3 to 1 . 
given arrays var0 , var6 and integers var4 , var5 , var3 . if var0 [ var5 ] is even , set var4 to var3 and push var3 into var6 ; else if var3 equals 1 , set var4 to 2 , push 2 into var6 ; else set var4 to 1 , push 1 into var6 . if var0 [ var5 ] not equals 1 , if var4 equals 1 , set var3 to 2 ; else set var3 to 1 . 
given an array var0 . initialize var6 to an empty array , var3 to 1 . for each var5 from 0 to the length of var0 exclusive , perform the following operations . if var0 [ var5 ] is even , set var4 to var3 and push var3 into var6 ; else if var3 equals 1 , set var4 to 2 , push 2 into var6 ; else set var4 to 1 , push 1 into var6 . if var0 [ var5 ] not equals 1 , if var4 equals 1 , set var3 to 2 ; else set var3 to 1 . return var6 . 
you are given an integer array var1 . initialize $$CONSTANT$$ string array var7 , and an integer var3 to 0 . iterate over all elements in var1 with index var4 , in each iteration , add var1 [ var4 ] - 1 to var3 . if var3 is divisible by 2 , append " 2 " to var7 , otherwise append " 1 " . 
you are given an integer array var1 , $$CONSTANT$$ string array var7 , and integers var6 , var3 . add var1 [ var6 ] - 1 to var3 and increment var6 . if var3 is divisible by 2 , append " 2 " to var7 , otherwise append " 1 " . 
you are given an integer array var1 . initialize $$CONSTANT$$ string array var7 , and an integer var3 to 0 . iterate over all elements in var1 with index var4 , in each iteration , add var1 [ var4 ] - 1 to var3 . if var3 is divisible by 2 , append " 2 " to var7 , otherwise append " 1 " . return var7 . 
given an integer var0 . return the index of the $$CONSTANT$$ fibonacci number which is not greater than var0 . 
given $$CONSTANT$$ string var0 and variables var1 , var2 , var3 and var4 , add the total count of " $$CONSTANT$$ " characters to var1 , total count of " $$CONSTANT$$ " characters to var2 , total count of " $$CONSTANT$$ " characters to var3 and the total count of " $$CONSTANT$$ " characters to var4 . 
given char typed array var0 . if the length of var0 is odd value then return - 1 . let var3 be the number of appearances of $$CONSTANT$$ in var0 decreased by the number of appearances of 68 in var0 and var1 be the number of appearances of $$CONSTANT$$ in var0 decreased by the number of appearances of $$CONSTANT$$ in var0 . 
given char typed array var0 . if the length of var0 is odd value then return - 1 . let var3 be the number of appearances of $$CONSTANT$$ in var0 decreased by the number of appearances of 68 in var0 and var1 be the number of appearances of $$CONSTANT$$ in var0 decreased by the number of appearances of $$CONSTANT$$ in var0 . return the half of sum of modules var1 and var2 . 
given char typed array var0 . if var3 equals $$CONSTANT$$ then add 1 to var2 . if var3 equals 68 then substract 1 from var2 . if var3 equals $$CONSTANT$$ then substract 1 from var1 . if var3 equals $$CONSTANT$$ then add 1 to var1 . 
given char typed array var0 . if var3 equals $$CONSTANT$$ then add 1 to var2 . if var3 equals 68 then substract 1 from var2 . if var3 equals $$CONSTANT$$ then substract 1 from var1 . 
given char typed array var0 . if the length of var0 is odd value then return - 1 . 
given char typed array var0 . if var3 equals $$CONSTANT$$ then add 1 to var2 . if var3 equals 68 then substract 1 from var2 . 
given integer var0 and char typed matrix var1 . create char typed array var2 . create an array var4 of size var0 at var5 th position containing the sorted set of type object . for all var5 $$CONSTANT$$ from 0 to length of var1 minus 1 , insert each separate element of var1 [ var5 ] into separate set var4 [ var8 ] . let var9 be the result of multiplication of lengths of all sorted sets var4 [ var5 ] modulo 10 ^ 9 + 7 . 
given integer var0 and char typed matrix var1 . create char typed array var2 . create an array var4 of size var0 at var5 th position containing the sorted set of type object . for all var5 $$CONSTANT$$ from 0 to length of var1 minus 1 , insert each separate element of var1 [ var5 ] into separate set var4 [ var8 ] . 
given an integer var2 and arrays var3 , var4 both of integer type . assign 0 to integers var6 , var7 , var8 , var9 , var10 , var11 . let var5 be the length of var3 . for all var12 $$CONSTANT$$ from 0 to var12 < var5 do following operations . increment var10 by var4 [ var12 ] . increment var11 by var4 [ var5 - var12 - 1 ] . increment var6 by the larger of 0 and var3 [ var12 ] - var2 * var10 . increment var7 by the larger of 0 and var3 [ var5 - $$CONSTANT$$ $$CONSTANT$$ 2 - 1 ] - var2 * var11 . 
given integer var0 and char typed matrix var1 . create char typed array var2 . create an array var4 of size var0 at var5 th position containing the sorted set of type object . 
given integer var0 and char typed matrix var1 . create char typed array var2 . create an array var4 of size var0 at var5 th position containing the sorted set of type object . 
given integers var1 , var0 . if ( var0 equals 2 ) or ( var1 equals 1 ) or ( var1 equals var0 ) or ( var0 equals var1 + 1 ) , return " YES " . if var0 is greater than var1 , return " NO " . while var1 is greater than 0 , perfrom the following operations . initialize var2 to var1 modulo var0 . if var2 is greater than 1 and var2 not equals var0 - 1 , return " NO " . divide var1 by var0 . if var2 equals var0 - 1 , increase var1 by 1 . return " YES " . 
given integers var1 , var0 . if ( var0 equals 2 ) or ( var1 equals 1 ) or ( var1 equals var0 ) or ( var0 equals var1 + 1 ) , return " YES " . if var0 is greater than var1 , return " NO " . while var1 is greater than 0 , perfrom the following operations . initialize var2 to var1 modulo var0 . if var2 is greater than 1 and var2 not equals var0 - 1 , return " NO " . divide var1 by var0 . if var2 equals var0 - 1 , increase var1 by 1 . return " YES " . 
given integer var0 . while var1 is greater than 0 , perfrom the following operations . initialize var2 to var1 modulo var0 . if var2 is greater than 1 and var2 not equals var0 - 1 , return " NO " . divide var1 by var0 . if var2 equals var0 - 1 , increase var1 by 1 . return " YES " . 
given integers var1 , var0 . initialize var2 to var1 modulo var0 . if var2 is greater than 1 and var2 not equals var0 - 1 , return " NO " . divide var1 by var0 . if var2 equals var0 - 1 , increase var1 by 1 . 
given integers var1 , var0 . initialize var2 to var1 modulo var0 . if var2 is greater than 1 and var2 not equals var0 - 1 , return " NO " . divide var1 by var0 . 
given an integer var2 and arrays var3 , var4 both of integer type . assign 0 to integers var6 , var7 , var8 , var9 , var10 , var11 . let var5 be the length of var3 . for all var12 $$CONSTANT$$ from 0 to var12 < var5 do following operations . increment var10 by var4 [ var12 ] . increment var11 by var4 [ var5 - var12 - 1 ] . increment var6 by the larger of 0 and var3 [ var12 ] - var2 * var10 . increment var7 by the larger of 0 and var3 [ var5 - $$CONSTANT$$ $$CONSTANT$$ 2 - 1 ] - var2 * var11 . after the loop is ended , if var6 equals var7 then return " $$CONSTANT$$ " . if var6 is larger than var7 then return " Limak " . otherwise , return " Radewoosh " . 
given integers var1 , var0 . initialize var2 to var1 modulo var0 . if var2 is greater than 1 and var2 not equals var0 - 1 , return " NO " . 
given integers var1 , var0 . if ( var0 equals 2 ) or ( var1 equals 1 ) or ( var1 equals var0 ) or ( var0 equals var1 + 1 ) , return " YES " . 
given integer array var0 . create char matrix var6 . assign 0 to var2 . for each var3 from 0 to last position of var0 , do following operations . assign var0 [ var3 ] to var4 . add x - 1 to var2 modulo 2 . if var2 equals 0 then add 2 to the end of var6 , otherwise , add 1 to the end of var6 . 
given integer array var0 . assign var0 [ var3 ] to var4 . add x - 1 to var2 modulo 2 . if var2 equals 0 then add 2 to the end of var6 , otherwise , add 1 to the end of var6 . 
given integer array var0 . create char matrix var6 . assign 0 to var2 . for each var3 from 0 to last position of var0 , do following operations . assign var0 [ var3 ] to var4 . add x - 1 to var2 modulo 2 . if var2 equals 0 then add 2 to the end of var6 , otherwise , add 1 to the end of var6 . when the loop is ended , return var6 . 
given integers var0 , var1 . create array var2 containing three var1 $$CONSTANT$$ . assign 0 to var3 . while var2 [ 0 ] is less than var0 , assign to var2 [ 0 ] the minimum of ( var2 [ 1 ] + var2 [ 2 ] ) - 1 and var0 , sort var2 and increment var3 . 
given integers var0 , var1 . create array var2 containing three var1 $$CONSTANT$$ . assign 0 to var3 . while var2 [ 0 ] is less than var0 , assign to var2 [ 0 ] the minimum of ( var2 [ 1 ] + var2 [ 2 ] ) - 1 and var0 , sort var2 and increment var3 . when the loop is ended , return var3 . 
given $$CONSTANT$$ string var0 , initialize var1 to array of integers of length 4 . for each position var2 in var0 increase var1 [ 0 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " , increase var1 [ 1 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " , increase var1 [ 2 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " , increase var1 [ 3 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " . 
given $$CONSTANT$$ string var0 , initialize var1 to array of integers of length 4 . for each position var2 in var0 increase var1 [ 0 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " , increase var1 [ 1 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " , increase var1 [ 2 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " , increase var1 [ 3 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " . return the divided by 2 ( rounded down ) sum of absolute value of var1 [ 0 ] - var1 [ 2 ] and absolute value of var1 [ 1 ] - var1 [ 3 ] . 
given $$CONSTANT$$ string var0 , an array of integers var1 and an integer var2 , increase var1 [ 0 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " , increase var1 [ 1 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " , increase var1 [ 2 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " , increase var1 [ 3 ] by 1 if var0 [ var2 ] = " $$CONSTANT$$ " . 
given $$CONSTANT$$ string var0 . initialize var1 to the number of occurences of ' $$CONSTANT$$ ' , var2 to the number of occurences of ' r ' , var3 to the number of occurences of ' u ' , var4 to the number of occurences of ' d ' in var0 . initialize var6 to | var1 - var2 | + | var3 - var4 | . 
given $$CONSTANT$$ string var0 . initialize var1 to the number of occurences of ' $$CONSTANT$$ ' , var2 to the number of occurences of ' r ' , var3 to the number of occurences of ' u ' , var4 to the number of occurences of ' d ' in var0 . 
given three integers var0 , var1 and var2 . initialize empty 0 - based integer array var6 and push var0 , var1 and var2 . sort var6 . set var7 to zero . if last element of var6 - 1 is bigger than second element then increase var7 by difference between last element and second element minus one . 
given integers var0 and var1 , initialize var2 to 0 , var3 to array of integers of length 3 , filled with var1 , var4 to 0 . for as long as at least one element of var3 is not equal to var0 , if var4 = 0 , then set var3 [ 0 ] to var0 if var3 [ 1 ] + var3 [ 2 ] > var0 , set var3 [ 0 ] to var3 [ 1 ] + var3 [ 2 ] - 1 otherwise , if var4 = 1 , then set var3 [ 1 ] to var0 if var3 [ 0 ] + var3 [ 2 ] > var0 , set var3 [ 1 ] to var3 [ 0 ] + var3 [ 2 ] - 1 otherwise , if var4 = 2 , then set var3 [ 2 ] to var0 if var3 [ 0 ] + var3 [ 1 ] > var0 , set var3 [ 2 ] to var3 [ 0 ] + var3 [ 1 ] - 1 , set var4 to ( var4 + 1 ) % 3 and increase var2 by 1 . 
given an array of integers var3 and integers var2 , var0 and var4 , if var4 = 0 , then set var3 [ 0 ] to var0 if var3 [ 1 ] + var3 [ 2 ] > var0 , set var3 [ 0 ] to var3 [ 1 ] + var3 [ 2 ] - 1 otherwise , if var4 = 1 , then set var3 [ 1 ] to var0 if var3 [ 0 ] + var3 [ 2 ] > var0 , set var3 [ 1 ] to var3 [ 0 ] + var3 [ 2 ] - 1 otherwise , if var4 = 2 , then set var3 [ 2 ] to var0 if var3 [ 0 ] + var3 [ 1 ] > var0 , set var3 [ 2 ] to var3 [ 0 ] + var3 [ 1 ] - 1 , set var4 to ( var4 + 1 ) % 3 and increase var2 by 1 . 
given integers var0 and var1 , initialize var2 to 0 , var3 to array of integers of length 3 , filled with var1 , var4 to 0 . for as long as at least one element of var3 is not equal to var0 , if var4 = 0 , then set var3 [ 0 ] to var0 if var3 [ 1 ] + var3 [ 2 ] > var0 , set var3 [ 0 ] to var3 [ 1 ] + var3 [ 2 ] - 1 otherwise , if var4 = 1 , then set var3 [ 1 ] to var0 if var3 [ 0 ] + var3 [ 2 ] > var0 , set var3 [ 1 ] to var3 [ 0 ] + var3 [ 2 ] - 1 otherwise , if var4 = 2 , then set var3 [ 2 ] to var0 if var3 [ 0 ] + var3 [ 1 ] > var0 , set var3 [ 2 ] to var3 [ 0 ] + var3 [ 1 ] - 1 , set var4 to ( var4 + 1 ) % 3 and increase var2 by 1 . return var2 . 
you are given $$CONSTANT$$ string var0 . you have to store in var1 the number of characters " $$CONSTANT$$ " in var0 minus the number of characters " $$CONSTANT$$ " in var0 . you have to store in var2 the number of characters " $$CONSTANT$$ " in var0 minus the number of characters " $$CONSTANT$$ " in var0 . 
you are given $$CONSTANT$$ string var0 . you have to store in var1 the number of characters " $$CONSTANT$$ " in var0 minus the number of characters " $$CONSTANT$$ " in var0 . you have to store in var2 the number of characters " $$CONSTANT$$ " in var0 minus the number of characters " $$CONSTANT$$ " in var0 . you have to return the sum of the absolute value of var1 and the absolute value of var2 divided by 2 ( rounded down ) . 
given an array of integers var0 , initialize var6 to empty array of strings and var2 to 0 . for each position var4 in var0 set var2 to ( var2 + var0 [ var4 ] - 1 ) % 2 , append " 1 " to the end of var6 if var2 = 1 , append " 2 " to the end of var6 otherwise . 
given an array of integers var0 , an array of strings var6 and integers var4 and var2 , set var2 to ( var2 + var0 [ var4 ] - 1 ) % 2 . append " 1 " to the end of var6 if var2 = 1 , append " 2 " to the end of var6 otherwise . 
given an array of integers var0 , initialize var6 to empty array of strings and var2 to 0 . for each position var4 in var0 set var2 to ( var2 + var0 [ var4 ] - 1 ) % 2 , append " 1 " to the end of var6 if var2 = 1 , append " 2 " to the end of var6 otherwise . return var6 . 
given integer array var0 . create integer array var5 . assign 2 to var2 . for all var3 $$CONSTANT$$ from 0 to last position of var0 , if var0 [ var3 ] is odd value then insert var2 into var5 , otherwise , update var2 by 1 or 2 if it equals 2 or 1 , respectively , and insert var2 into var5 . 
given integer array var0 . update var2 by 1 or 2 if it equals 2 or 1 , respectively . insert var2 into var5 . 
given integer array var0 . create integer array var5 . assign 2 to var2 . for all var3 $$CONSTANT$$ from 0 to last position of var0 , if var0 [ var3 ] is odd value then insert var2 into var5 , otherwise , update var2 by 1 or 2 if it equals 2 or 1 , respectively , and insert var2 into var5 . return the resultant var5 . 
you are given $$CONSTANT$$ string var0 and $$CONSTANT$$ number var1 . you have to set var2 to the length of var0 divided by var1 ( rounded down ) . you have to set var3 to zero and var4 to var0 . for each var5 greater than or equal to zero and less than length of var0 and divisible by var2 , you have to iterate var6 between 0 and var2 - 1 , and if var4 [ var5 + var6 ] is different from var4 [ var5 + var2 - var6 - 1 ] you have to set var3 to 1 and break from the enclosing loop . after the loop in var6 ends , if var3 is equal to 1 you have to break from the enclosing loop . 
given $$CONSTANT$$ string var0 . initialize var1 to the number of occurences of ' $$CONSTANT$$ ' , var2 to the number of occurences of ' r ' , var3 to the number of occurences of ' u ' , var4 to the number of occurences of ' d ' in var0 . initialize var6 to | var1 - var2 | + | var3 - var4 | . if var6 is odd , return - 1 ; else return var6 / 2 . 
you are given $$CONSTANT$$ string var0 and $$CONSTANT$$ number var1 . you have to split var0 in var1 strings of the same length and if all of the var1 strings are palindromes you have to return " YES " , otherwise you have to return " NO " . 
you are given $$CONSTANT$$ string var4 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var3 and $$CONSTANT$$ number var5 . you have to iterate var6 between 0 and var2 - 1 , and if var4 [ var5 + var6 ] is different from var4 [ var5 + var2 - var6 - 1 ] you have to set var3 to 1 and break from the enclosing loop . after the loop in var6 ends , if var3 is equal to 1 you have to break from the enclosing loop . 
you are given $$CONSTANT$$ string var4 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var3 and $$CONSTANT$$ number var5 . you have to iterate var6 between 0 and var2 - 1 , and if var4 [ var5 + var6 ] is different from var4 [ var5 + var2 - var6 - 1 ] you have to set var3 to 1 and break from the enclosing loop . 
given integer array var0 . assign var0 to var2 . sort var2 . assign 0 to var4 , var5 . iterating over var2 where var6 is current element , if var6 is not less than var4 then add var6 to var4 , otheriwse , increment var5 . 
given integer array var0 . assign var0 to var2 . sort var2 . 
given integer array var0 . assign var0 to var2 . 
given integer array var0 . assign var0 to var2 . sort var2 . assign 0 to var4 , var5 . iterating over var2 where var6 is current element , if var6 is not less than var4 then add var6 to var4 , otheriwse , increment var5 . return length of var0 minus var5 . 
given three integers var0 , var1 and var2 . set integer var3 to var0 , var4 to var1 and var5 to var2 . set integer var6 to the division of ( var5 - var3 ) and var4 ( rounded down ) . set var7 to ( ( var5 - var3 ) % var4 ) . if var6 is greater than or equal to 1 then if var7 is equal to 0 or 1 then return " YES " else return " NO " else if var3 is equal to var5 return " YES " , return " NO " otherwise . 
given an array of integers var1 , initialize var3 to length of var1 , var4 to array of integers of length var3 + 1 . for each integer var5 from 1 to var3 ( both inclusive ) set var4 [ var5 ] to var1 [ var5 - 1 ] . sort var4 in non - decreasing $$CONSTANT$$ . initialize var6 and var7 to 0 . for each position var8 from 1 to var3 ( both inclusive ) add var4 [ var8 ] to var6 and add 1 to var7 if var6 < = var4 [ var8 ] . return var7 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and an array of numbers var2 ( indexing is 0 - based ) . you have to set var3 to the length of var2 , var5 to zero , var6 to zero and var7 to zero . while var7 is less than var3 , you have to iterate while var7 is less than var3 and var2 [ var7 ] + var6 is less than or equal to var0 , and you have to add var2 [ var7 ] to var6 and add 1 to var7 . after the inside loop ends , you have to add var6 divided by var1 ( rounded down ) to var5 , you have to store in var6 the value of var6 modulo var1 . if var7 is less than var3 and var2 [ var7 ] + var6 is greater than var0 you have to add 1 to var5 and set var6 to zero . after the loop ends , if var6 is different to zero you have to add 1 to var5 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and an array of numbers var2 ( indexing is 0 - based ) . you have to set var3 to the length of var2 , var5 to zero , var6 to zero and var7 to zero . while var7 is less than var3 , you have to iterate while var7 is less than var3 and var2 [ var7 ] + var6 is less than or equal to var0 , and you have to add var2 [ var7 ] to var6 and add 1 to var7 . after the inside loop ends , you have to add var6 divided by var1 ( rounded down ) to var5 , you have to store in var6 the value of var6 modulo var1 . if var7 is less than var3 and var2 [ var7 ] + var6 is greater than var0 you have to add 1 to var5 and set var6 to zero . 
you are given $$CONSTANT$$ number var3 , $$CONSTANT$$ number var6 , an index var7 , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var5 , $$CONSTANT$$ number var1 and an array of numbers var2 . while var7 is less than var3 and var2 [ var7 ] + var6 is less than or equal to var0 you have to add var2 [ var7 ] to var6 and add 1 to var7 . you have to add var6 divided by var1 ( rounded down ) to var5 , you have to store in var6 the value of var6 modulo var1 . if var7 is less than var3 and var2 [ var7 ] + var6 is greater than var0 you have to add 1 to var5 and set var6 to zero . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and an array of numbers var2 ( indexing is 0 - based ) . you have to set var3 to the length of var2 , var5 to zero , var6 to zero and var7 to zero . while var7 is less than var3 , you have to iterate while var7 is less than var3 and var2 [ var7 ] + var6 is less than or equal to var0 , and you have to add var2 [ var7 ] to var6 and add 1 to var7 . after the inside loop ends , you have to add var6 divided by var1 ( rounded down ) to var5 , you have to store in var6 the value of var6 modulo var1 . if var7 is less than var3 and var2 [ var7 ] + var6 is greater than var0 you have to add 1 to var5 and set var6 to zero . after the loop ends , if var6 is different to zero you have to add 1 to var5 . you have to return var5 . 
you are given $$CONSTANT$$ number var3 , $$CONSTANT$$ number var6 , an index var7 , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var5 , $$CONSTANT$$ number var1 and an array of numbers var2 . while var7 is less than var3 and var2 [ var7 ] + var6 is less than or equal to var0 you have to add var2 [ var7 ] to var6 and add 1 to var7 . you have to add var6 divided by var1 ( rounded down ) to var5 , you have to store in var6 the value of var6 modulo var1 . 
you are given integers var0 and var1 . assign var0 and var1 to var2 and var3 , respectively . create $$CONSTANT$$ three - dimensional array var4 of sizes var2 , n + 1 , 2 and of type real . assign the minimum of 1 and var3 to var4 [ 0 ] [ 1 ] [ 0 ] . assign the larger of 0 and t - 1 to var4 [ 0 ] [ 1 ] [ 1 ] . for all var5 $$CONSTANT$$ from 1 to var5 < var2 do following loop . for all var6 $$CONSTANT$$ from 1 to var6 < = var2 do following operations . assign the value ( var4 [ ( var5 - 1 ) ] [ var6 ] [ 1 ] / 2 ) + ( var4 [ ( var5 - 1 ) ] [ ( var6 - 1 ) ] [ 1 ] / 2 ) to var4 [ var5 ] [ var6 ] [ 0 ] . set the larger of 0 and var4 [ var5 ] [ var6 ] [ 0 ] - 1 to var4 [ var5 ] [ var6 ] [ 1 ] . set the minimum of 1 and var4 [ var5 ] [ var6 ] [ 0 ] to var4 [ var5 ] [ var6 ] [ 0 ] . after both loops are ended , return the number of cells in var4 such that var4 [ var8 ] [ var9 ] [ 0 ] equals 1 where var8 is the number of row and var9 is the number of $$CONSTANT$$ . 
you are given integers var0 and var1 . assign var0 and var1 to var2 and var3 , respectively . create $$CONSTANT$$ three - dimensional array var4 of sizes var2 , n + 1 , 2 and of type real . assign the minimum of 1 and var3 to var4 [ 0 ] [ 1 ] [ 0 ] . assign the larger of 0 and t - 1 to var4 [ 0 ] [ 1 ] [ 1 ] . for all var5 $$CONSTANT$$ from 1 to var5 < var2 do following loop . for all var6 $$CONSTANT$$ from 1 to var6 < = var2 do following operations . assign the value ( var4 [ ( var5 - 1 ) ] [ var6 ] [ 1 ] / 2 ) + ( var4 [ ( var5 - 1 ) ] [ ( var6 - 1 ) ] [ 1 ] / 2 ) to var4 [ var5 ] [ var6 ] [ 0 ] . set the larger of 0 and var4 [ var5 ] [ var6 ] [ 0 ] - 1 to var4 [ var5 ] [ var6 ] [ 1 ] . set the minimum of 1 and var4 [ var5 ] [ var6 ] [ 0 ] to var4 [ var5 ] [ var6 ] [ 0 ] . 
you are given integers var0 and var1 . for all var6 $$CONSTANT$$ from 1 to var6 < = var2 do following operations . assign the value ( var4 [ ( var5 - 1 ) ] [ var6 ] [ 1 ] / 2 ) + ( var4 [ ( var5 - 1 ) ] [ ( var6 - 1 ) ] [ 1 ] / 2 ) to var4 [ var5 ] [ var6 ] [ 0 ] . set the larger of 0 and var4 [ var5 ] [ var6 ] [ 0 ] - 1 to var4 [ var5 ] [ var6 ] [ 1 ] . set the minimum of 1 and var4 [ var5 ] [ var6 ] [ 0 ] to var4 [ var5 ] [ var6 ] [ 0 ] . 
given an integer var4 , perform the binary search to find the $$CONSTANT$$ value of var6 such that the sum of var6 / ( var3 * var3 * var3 ) ( each summand is rounded down ) over all integers var3 such that var3 > = 2 and var6 > = var3 * var3 * var3 is greater than or equal to var4 . initialize var8 to - 1 . set var8 to var6 - 1 if the sum of ( var6 - 1 ) / ( var3 * var3 * var3 ) ( each summand is rounded down ) over all integers var3 such that var3 > = 2 and var6 - 1 > = var3 * var3 * var3 is equal to var4 , otherwise set var8 to var6 if the sum of var6 / ( var3 * var3 * var3 ) ( each summand is rounded down ) over all integers var3 such that var3 > = 2 and var6 > = var3 * var3 * var3 is equal to var4 . 
given an integer var4 , perform the binary search to find the $$CONSTANT$$ value of var6 such that the sum of var6 / ( var3 * var3 * var3 ) ( each summand is rounded down ) over all integers var3 such that var3 > = 2 and var6 > = var3 * var3 * var3 is greater than or equal to var4 . initialize var8 to - 1 . 
given an integer var4 , perform the binary search to find the $$CONSTANT$$ value of var6 such that the sum of var6 / ( var3 * var3 * var3 ) ( each summand is rounded down ) over all integers var3 such that var3 > = 2 and var6 > = var3 * var3 * var3 is greater than or equal to var4 . store var6 - 1 in var5 . 
given an integer var1 , initialize var2 to 0 and var3 to 2 . for as long as var3 * var3 * var3 < = var1 and var2 < = $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ , add the result of division of var1 by var3 * var3 * var3 , rounded down , to var2 and increase var3 by 1 . return var2 . 
given an integer var1 , initialize var2 to 0 and var3 to 2 . for as long as var3 * var3 * var3 < = var1 and var2 < = $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ , add the result of division of var1 by var3 * var3 * var3 , rounded down , to var2 and increase var3 by 1 . 
given integers var4 , var5 and var6 , initialize var7 to ( var5 + var6 ) / 2 , rounded down . set var6 to var7 if the sum of var7 / ( var3 * var3 * var3 ) over all var3 such that var3 > = 2 and var7 > = var3 * var3 * var3 is greater than or equal to var4 , set var5 to var7 otherwise . 
given an integer var1 and 0 - based arrays var2 , var3 of integer types . create arrays var5 and var6 where var7 th elements equal to the maximum and minimum of var2 [ var7 ] and var3 [ var7 ] , respectively . sort arrays var5 and var6 . 
you are given integers var0 and var1 . for all var9 $$CONSTANT$$ from 0 to var9 < = var2 , if var4 [ var8 ] [ var9 ] [ 0 ] equals 1 then increase the result by 1 . 
given an integer var1 and 0 - based arrays var2 , var3 of integer types . create arrays var5 and var6 where var7 th elements equal to the maximum and minimum of var2 [ var7 ] and var3 [ var7 ] , respectively . sort arrays var5 and var6 . if var2 is empty then return n - 1 . if var6 [ $$CONSTANT$$ - 1 ] is not less than var5 [ 0 ] then return 0 . otherwise , return the value var5 [ 0 ] - small [ $$CONSTANT$$ - 1 ] . 
given integers var0 , var1 , var3 , var4 and var5 , set var5 to var3 + var4 , add var5 to var1 , set var4 to var3 , set var3 to var5 , break from the enclosing loop if var1 > = var0 . 
given an integer var0 , initialize var6 to empty array of integers . append 1 to the end of var6 and return var6 if var0 = 2 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and $$CONSTANT$$ number var2 . you have to set var3 to $$CONSTANT$$ . if var0 is greater than or equal to var1 and var0 is greater than or equal to var2 , if var0 is equal to var2 you have to set var3 to var0 - var1 , otherwise you have to set var3 to var0 - 1 - var2 and if var0 is different to var1 you have to add var0 - 1 - var1 to var3 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and $$CONSTANT$$ number var2 . you have to set var3 to $$CONSTANT$$ . if var0 is greater than or equal to var1 and var0 is greater than or equal to var2 , if var0 is equal to var2 you have to set var3 to var0 - var1 , otherwise you have to set var3 to var0 - 1 - var2 and if var0 is different to var1 you have to add var0 - 1 - var1 to var3 . you have to return var3 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and $$CONSTANT$$ number var2 . you have to set var3 to var0 - 1 - var2 . if var0 is different to var1 you have to add var0 - 1 - var1 to var3 . 
you are given an array var0 of integer type . assign the values false and true to variables var2 and var3 , respectively . for all var4 $$CONSTANT$$ from 0 to var4 < length of var0 do following operations . if var2 is true and var0 [ var4 ] equals 0 then assign false to var3 . if var0 [ var4 ] is odd number then update var2 by its opposite value . when var4 becomes equal to the length of var0 , exit from the loop . after the loop is ended , if var2 is true then assign false to var3 . if var3 is true then return " YES " . otheriwse , return " NO " . 
you are given an array var0 of integer type . assign the values false and true to variables var2 and var3 , respectively . for all var4 $$CONSTANT$$ from 0 to var4 < length of var0 do following operations . if var2 is true and var0 [ var4 ] equals 0 then assign false to var3 . if var0 [ var4 ] is odd number then update var2 by its opposite value . when var4 becomes equal to the length of var0 , exit from the loop . 
you are given an array var0 of integer type . if var2 is true and var0 [ var4 ] equals 0 then assign false to var3 . if var0 [ var4 ] is odd number then update var2 by its opposite value . 
you are given an array var0 of integer type . if var2 is true and var0 [ var4 ] equals 0 then assign false to var3 . 
given $$CONSTANT$$ string var1 . initialize var2 to var1 , var3 to the length of var2 , var4 and var5 to empty arrays . for each var6 from 1 to var3 , perform the following operations . set var4 [ var6 ] to var4 [ var6 - 1 ] . if var2 [ var6 - 1 ] is the lowercase letter , increase var4 [ var6 ] by 1 . for each var7 from var3 - 1 to 0 , perform the following operations . set var5 [ var7 ] to var5 [ var7 + 1 ] . if var2 [ var7 ] is the uppercase letter , increase var5 [ var7 ] by 1 . initialize var8 to the minimum value among var4 [ var9 ] + var5 [ var9 ] for each var9 from 0 to var3 . 
you are given an array var0 of integer type . assign the values false and true to variables var2 and var3 , respectively . for all var4 $$CONSTANT$$ from 0 to var4 < length of var0 do following operations . if var2 is true and var0 [ var4 ] equals 0 then assign false to var3 . if var0 [ var4 ] is odd number then update var2 by its opposite value . when var4 becomes equal to the length of var0 , exit from the loop . after the loop is ended , if var2 is true then assign false to var3 . if var3 is true then return " YES " . otheriwse , return " NO " . 
given $$CONSTANT$$ string var1 . initialize var2 to var1 , var3 to the length of var2 , var4 and var5 to empty arrays . for each var6 from 1 to var3 , perform the following operations . set var4 [ var6 ] to var4 [ var6 - 1 ] . if var2 [ var6 - 1 ] is the lowercase letter , increase var4 [ var6 ] by 1 . for each var7 from var3 - 1 to 0 , perform the following operations . set var5 [ var7 ] to var5 [ var7 + 1 ] . if var2 [ var7 ] is the uppercase letter , increase var5 [ var7 ] by 1 . 
given $$CONSTANT$$ string var1 . initialize var2 to var1 , var3 to the length of var2 , var4 and var5 to empty arrays . for each var6 from 1 to var3 , perform the following operations . set var4 [ var6 ] to var4 [ var6 - 1 ] . if var2 [ var6 - 1 ] is the lowercase letter , increase var4 [ var6 ] by 1 . 
given $$CONSTANT$$ string var1 . initialize var2 to var1 , var3 to the length of var2 , var4 and var5 to empty arrays . for each var6 from 1 to var3 , perform the following operations . set var4 [ var6 ] to var4 [ var6 - 1 ] . if var2 [ var6 - 1 ] is the lowercase letter , increase var4 [ var6 ] by 1 . 
you are given integers var0 and var1 . assign var0 and var1 to var2 and var3 , respectively . create $$CONSTANT$$ three - dimensional array var4 of sizes var2 , n + 1 , 2 and of type real . assign the minimum of 1 and var3 to var4 [ 0 ] [ 1 ] [ 0 ] . assign the larger of 0 and t - 1 to var4 [ 0 ] [ 1 ] [ 1 ] . for all var5 $$CONSTANT$$ from 1 to var5 < var2 do following loop . for all var6 $$CONSTANT$$ from 1 to var6 < = var2 do following operations . assign the value ( var4 [ ( var5 - 1 ) ] [ var6 ] [ 1 ] / 2 ) + ( var4 [ ( var5 - 1 ) ] [ ( var6 - 1 ) ] [ 1 ] / 2 ) to var4 [ var5 ] [ var6 ] [ 0 ] . set the larger of 0 and var4 [ var5 ] [ var6 ] [ 0 ] - 1 to var4 [ var5 ] [ var6 ] [ 1 ] . set the minimum of 1 and var4 [ var5 ] [ var6 ] [ 0 ] to var4 [ var5 ] [ var6 ] [ 0 ] . after both loops are ended , return the number of cells in var4 such that var4 [ var8 ] [ var9 ] [ 0 ] equals 1 where var8 is the number of row and var9 is the number of $$CONSTANT$$ . 
given integers var0 , var1 . create real typed matrix var2 of sizes var0 , var0 . for all var3 $$CONSTANT$$ from 0 to t - 1 do following operations . add 1 to var2 [ 0 ] [ 0 ] . for all var4 $$CONSTANT$$ from 0 to n - 2 , for each element in var2 [ var4 ] with position var5 which is not less than 1 , do following operations . add to var2 [ ( var4 + 1 ) ] [ var5 ] and to var2 [ ( var4 + 1 ) ] [ ( var5 + 1 ) ] the value var2 [ var4 ] [ var5 ] - 1 / 2 and assign 1 to var2 [ var4 ] [ var5 ] . return the number of non - zero elements in var2 . 
you are given an array of numbers var2 , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 . set var3 to zero and var4 to zero . for each number var5 in var2 if var4 + var5 is greater than var0 set var4 to zero and add 1 to var3 , add var5 to var4 , add var4 divided by var1 ( rounded down ) to var3 , store in var4 the value of var4 modulo var1 . if var4 is greater than zero add 1 to var3 . 
you are given an array of numbers var2 , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 . set var3 to zero and var4 to zero . for each number var5 in var2 if var4 + var5 is greater than var0 set var4 to zero and add 1 to var3 , add var5 to var4 , add var4 divided by var1 ( rounded down ) to var3 , store in var4 the value of var4 modulo var1 . 
you are given an array of numbers var2 , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 . set var3 to zero and var4 to zero . for each number var5 in var2 if var4 + var5 is greater than var0 set var4 to zero and add 1 to var3 , add var5 to var4 , add var4 divided by var1 ( rounded down ) to var3 , store in var4 the value of var4 modulo var1 . if var4 is greater than zero add 1 to var3 . you have to return var3 . 
you are given $$CONSTANT$$ number var4 , $$CONSTANT$$ number var5 , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var3 , $$CONSTANT$$ number var1 . if var4 + var5 is greater than var0 set var4 to zero and add 1 to var3 . add var5 to var4 , add var4 divided by var1 ( rounded down ) to var3 , store in var4 the value of var4 modulo var1 . 
given $$CONSTANT$$ string var1 . initialize var2 to var1 , var3 to the length of var2 , var4 and var5 to empty arrays . for each var6 from 1 to var3 , perform the following operations . set var4 [ var6 ] to var4 [ var6 - 1 ] . if var2 [ var6 - 1 ] is the lowercase letter , increase var4 [ var6 ] by 1 . for each var7 from var3 - 1 to 0 , perform the following operations . set var5 [ var7 ] to var5 [ var7 + 1 ] . if var2 [ var7 ] is the uppercase letter , increase var5 [ var7 ] by 1 . return the minimum value among var4 [ var9 ] + var5 [ var9 ] for each var9 from 0 to var3 . 
you are given an integer array var3 and integers var1 , var2 . set var4 to the length of var3 , var5 to var1 and var6 to var2 . set var8 and var9 to 0 . iterate from 0 to var4 - 1 inclusive with index var10 . in each iteration , while var10 is less than var4 and var9 + var3 [ var10 ] is less than or equal to var5 , add var3 [ var10 ] to var9 and increment var10 . ( end of latest loop ) if var9 is more than var6 , let var11 be var9 divided by var6 ( rounded down ) , add var11 to var8 , and substract var11 * var6 from var9 , otherwise increment var8 and set var9 to 0 . after the end of iterations , if var9 is more than 0 , increment var8 . 
you are given an integer array var3 and integers var1 , var2 . set var4 to the length of var3 , var5 to var1 and var6 to var2 . set var8 and var9 to 0 . iterate from 0 to var4 - 1 inclusive with index var10 . in each iteration , while var10 is less than var4 and var9 + var3 [ var10 ] is less than or equal to var5 , add var3 [ var10 ] to var9 and increment var10 . ( end of latest loop ) if var9 is more than var6 , let var11 be var9 divided by var6 ( rounded down ) , add var11 to var8 , and substract var11 * var6 from var9 , otherwise increment var8 and set var9 to 0 . 
you are given an integer array var3 and integers var1 , var2 . set var4 to the length of var3 , var5 to var1 and var6 to var2 . set var8 and var9 to 0 . iterate from 0 to var4 - 1 inclusive with index var10 . in each iteration , while var10 is less than var4 and var9 + var3 [ var10 ] is less than or equal to var5 , add var3 [ var10 ] to var9 and increment var10 . ( end of latest loop ) if var9 is more than var6 , let var11 be var9 divided by var6 ( rounded down ) , add var11 to var8 , and substract var11 * var6 from var9 , otherwise increment var8 and set var9 to 0 . after the end of iterations , if var9 is more than 0 , increment var8 . return var8 . 
you are given integers var10 , var4 , var9 , var8 , var6 and an integer array var3 . while var10 is less than var4 and var9 + var3 [ var10 ] is less than or equal to var5 , add var3 [ var10 ] to var9 and increment var10 . if var9 is more than var6 , let var11 be var9 divided by var6 ( rounded down ) , add var11 to var8 , and substract var11 * var6 from var9 , otherwise increment var8 and set var9 to 0 . 
you are given an integer array var3 and integers var1 , var2 . set var4 to the length of var3 , var5 to var1 and var6 to var2 . 
given $$CONSTANT$$ boolean var2 , an array of integers var0 , and an index var3 into var0 . if var2 is true , set var0 [ var3 ] to var0 [ var3 ] - 1 . if var0 [ var3 ] is smaller than zero break from the enclosing loop . 
given integers var0 , var1 , var2 . initialize var3 to var0 * var2 , var4 to 0 . while var3 is greater than 0 , decrease var3 by var1 and increase var4 by 1 . set var3 to var0 * var2 . initialize var5 to 0 , var6 to 0 . while var5 + var2 * var1 is not less than var3 , increase var6 by 1 and add var1 to var5 . 
given integers var0 , var1 , var2 . initialize var3 to var0 * var2 , var4 to 0 . while var3 is greater than 0 , decrease var3 by var1 and increase var4 by 1 . set var3 to var0 * var2 . 
given integers var0 , var1 , var2 . initialize var3 to var0 * var2 , var4 to 0 . while var3 is greater than 0 , decrease var3 by var1 and increase var4 by 1 . 
given an array var0 . initialize var1 to the length of var0 , var3 to the sum of elements of var0 . for each var5 from 3 to var1 , if var1 modulo var5 equal 0 , perform the following operations . for each var6 from 0 to var1 / var5 , perform the following operations . initialize var2 to 0 , var7 to var6 . while var7 is less than var1 , add var0 [ var7 ] to var2 and add var1 / var5 to var7 . set var3 to the maximum between var3 and var2 . 
given an array var0 and integers var5 , var1 , var3 . for each var6 from 0 to var1 / var5 , perform the following operations . initialize var2 to 0 , var7 to var6 . while var7 is less than var1 , add var0 [ var7 ] to var2 and add var1 / var5 to var7 . set var3 to the maximum between var3 and var2 . 
given an array var0 and integers var6 , var5 , var1 , var3 . initialize var2 to 0 , var7 to var6 . while var7 is less than var1 , add var0 [ var7 ] to var2 and add var1 / var5 to var7 . set var3 to the maximum between var3 and var2 . 
given an array var0 and integers var6 , var5 , var1 . initialize var2 to 0 , var7 to var6 . while var7 is less than var1 , add var0 [ var7 ] to var2 and add var1 / var5 to var7 . 
given an array var0 . initialize var3 to the sum of elements of var0 . 
given an array var0 . initialize var3 to the sum of elements of var0 . 
given integer typed array var0 . if the last value in var0 equals 15 then return " DOWN " . if it equals 0 then return " UP " . assign the length of var0 to var1 . if var1 equals 1 then return " - 1 " . if var0 [ n - 2 ] is less than var0 [ n - 1 ] then return " UP " . otherwise , return " DOWN " . 
given an array var0 . initialize var1 to the length of var0 , var3 to the sum of elements of var0 . for each var5 from 3 to var1 , if var1 modulo var5 equal 0 , perform the following operations . for each var6 from 0 to var1 / var5 , perform the following operations . initialize var2 to 0 , var7 to var6 . while var7 is less than var1 , add var0 [ var7 ] to var2 and add var1 / var5 to var7 . set var3 to the maximum between var3 and var2 . return var3 . 
given an array var0 of integer type ( 0 - based ) . initialize var0 to var2 . sort the array var2 . assign 0 to var4 , var5 . for all var3 $$CONSTANT$$ from 0 to var3 < length of var0 , do this . if var2 [ var6 ] is larger than or equal to var4 then increment var5 and increase var4 be var2 [ var6 ] . 
given an array var0 of integer type ( 0 - based ) . initialize var0 to var2 . sort the array var2 . 
given an array var0 of integer type ( 0 - based ) . initialize var0 to var2 . 
given integer array var0 . assign var0 to var2 . sort var2 . create integer array var3 of size equal to length of var0 plus 1 . for each var6 from 1 to var1 , if var2 [ $$CONSTANT$$ - 1 ] + vector [ $$CONSTANT$$ - 1 ] does not exceed var2 [ var6 ] then add 1 to var4 and assign to var3 [ var6 ] the value var2 [ $$CONSTANT$$ - 1 ] + vector [ $$CONSTANT$$ - 1 ] , or in other case , assign to var3 [ var6 ] the value var3 [ $$CONSTANT$$ - 1 ] + nums [ $$CONSTANT$$ - 1 ] and assign 0 to var2 [ var6 ] . 
given integer array var0 . assign var0 to var2 . sort var2 . 
given an array var0 of integer type ( 0 - based ) . initialize var0 to var2 . sort the array var2 . assign 0 to var4 , var5 . for all var3 $$CONSTANT$$ from 0 to var3 < length of var0 , do this . if var2 [ var6 ] is larger than or equal to var4 then increment var5 and increase var4 be var2 [ var6 ] . when var3 becomes equal to the length of var0 , exit from the loop and return var5 . 
given integer array var0 . assign var0 to var2 . sort var2 . 
given integer array var0 . assign var0 to var2 . 
given integers var0 , var1 , var2 . initialize var3 to var0 * var2 , var4 to 0 . while var3 is greater than 0 , decrease var3 by var1 and increase var4 by 1 . set var3 to var0 * var2 . initialize var5 to 0 , var6 to 0 . while var5 + var2 * var1 is not less than var3 , increase var6 by 1 and add var1 to var5 . return var6 . 
given integer typed array var0 . if the last value in var0 equals 15 then return " DOWN " . if it equals 0 then return " UP " . assign the length of var0 to var1 . if var1 equals 1 then return " - 1 " . if var0 [ n - 2 ] is less than var0 [ n - 1 ] then return " UP " . otherwise , return " DOWN " . 
given integer typed array var0 . if the last value in var0 equals 15 then return " DOWN " . if it equals 0 then return " UP " . 
given integer typed array var0 . if var0 [ n - 2 ] is less than var0 [ n - 1 ] then return " UP " . otherwise , return " DOWN " . 
given integer typed array var0 . if the last value in var0 equals 15 then return " DOWN " . 
given integers var0 , var1 . return the sum of all values ( var5 * var1 ) + 1 * ( ( var1 * ( var1 - 1 ) ) / 2 modulo 10 ^ 9 + 7 where var4 obtains values from 1 to var0 . 
given integer array var0 . assign var0 to var2 . sort var2 . create integer array var3 of size equal to length of var0 plus 1 . for each var6 from 1 to var1 , if var2 [ $$CONSTANT$$ - 1 ] + vector [ $$CONSTANT$$ - 1 ] does not exceed var2 [ var6 ] then add 1 to var4 and assign to var3 [ var6 ] the value var2 [ $$CONSTANT$$ - 1 ] + vector [ $$CONSTANT$$ - 1 ] , or in other case , assign to var3 [ var6 ] the value var3 [ $$CONSTANT$$ - 1 ] + nums [ $$CONSTANT$$ - 1 ] and assign 0 to var2 [ var6 ] . when the loop is ended , return var4 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . set var3 to the maximum between var0 and var1 . store in var4 , var5 and var6 , the minimum between var0 and var1 . set var7 to zero . while var4 is different to var3 or var5 is different to var3 or var6 is different to var3 you have to , if var4 is less than or equal to var5 and var4 is less than or equal to var6 , store in var4 the minimum between var3 and var5 + var6 - 1 , otherwise if var5 is less than or equal to var4 and var5 is less than or equal to var6 , store in var5 the minimum between var3 and var4 + var6 - 1 , otherwise store in var6 the minimum between var3 and var4 + var5 - 1 ; add 1 to var7 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . set var3 to the maximum between var0 and var1 . store in var4 , var5 and var6 , the minimum between var0 and var1 . set var7 to zero . while var4 is different to var3 or var5 is different to var3 or var6 is different to var3 you have to , if var4 is less than or equal to var5 and var4 is less than or equal to var6 , store in var4 the minimum between var3 and var5 + var6 - 1 , otherwise if var5 is less than or equal to var4 and var5 is less than or equal to var6 , store in var5 the minimum between var3 and var4 + var6 - 1 , otherwise store in var6 the minimum between var3 and var4 + var5 - 1 ; add 1 to var7 . you have to return var7 . 
you are given the numbers var4 , var5 , var6 , var3 , var7 . if var4 is less than or equal to var5 and var4 is less than or equal to var6 , store in var4 the minimum between var3 and var5 + var6 - 1 , otherwise if var5 is less than or equal to var4 and var5 is less than or equal to var6 , store in var5 the minimum between var3 and var4 + var6 - 1 , otherwise store in var6 the minimum between var3 and var4 + var5 - 1 . add 1 to var7 . 
given integers var2 , var3 , var4 , $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . total and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . x , return $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . total if var2 , var3 and var4 are equal to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . x . increase $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . total . if var2 < = var3 and var2 < = var4 , call function memoryanddeevolutionc . recur ( min ( $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . x , var3 + var4 - 1 ) , var3 , var4 ) . otherwise , if var3 < = var2 and var3 < = var4 , call function memoryanddeevolutionc . recur ( var2 , min ( $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . x , var2 + var4 - 1 ) , var4 ) . otherwise , if var4 < = var2 and var4 < = var3 , call function memoryanddeevolutionc . recur ( var2 , var3 , min ( $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . x , var2 + var3 - 1 ) ) . 
given 0 - based , integer typed array var0 . assign the sorted version of var0 to var2 . assign 0 to var4 , var5 . for all var6 $$CONSTANT$$ from 0 to n - 1 do following operations . if var5 does not exceed var2 [ var6 ] then increase var5 by var2 [ var6 ] and add 1 to var4 . otherwise , for all var7 $$CONSTANT$$ from $$CONSTANT$$ $$CONSTANT$$ 1 + 1 to n - 1 do following operations . add 1 to var6 . if var5 does not exceed var2 [ var7 ] then increase var5 by var2 [ var7 ] , add 1 to var4 and exit from the current loop . 
given integers var2 , var3 , var4 , $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . total and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . x , return $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . total if var2 , var3 and var4 are equal to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . x . increase $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . total . if var2 < = var3 and var2 < = var4 , call function memoryanddeevolutionc . recur ( min ( $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . x , var3 + var4 - 1 ) , var3 , var4 ) . otherwise , if var3 < = var2 and var3 < = var4 , call function memoryanddeevolutionc . recur ( var2 , min ( $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . x , var2 + var4 - 1 ) , var4 ) . otherwise , if var4 < = var2 and var4 < = var3 , call function memoryanddeevolutionc . recur ( var2 , var3 , min ( $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . x , var2 + var3 - 1 ) ) . return $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . memoryanddeevolutionc . total . 
given 0 - based , integer typed array var0 . for all var7 $$CONSTANT$$ from $$CONSTANT$$ $$CONSTANT$$ 1 + 1 to n - 1 do following operations . add 1 to var6 . if var5 does not exceed var2 [ var7 ] then increase var5 by var2 [ var7 ] , add 1 to var4 and exit from the current loop . 
given 0 - based , integer typed array var0 . add 1 to var6 . if var5 does not exceed var2 [ var7 ] then increase var5 by var2 [ var7 ] , add 1 to var4 and exit from the current loop . 
given 0 - based , integer typed array var0 . assign the sorted version of var0 to var2 . 
given 0 - based , integer typed array var0 . assign var0 to var2 . 
given 0 - based , integer typed array var0 . assign the sorted version of var0 to var2 . assign 0 to var4 , var5 . for all var6 $$CONSTANT$$ from 0 to n - 1 do following operations . if var5 does not exceed var2 [ var6 ] then increase var5 by var2 [ var6 ] and add 1 to var4 . otherwise , for all var7 $$CONSTANT$$ from $$CONSTANT$$ $$CONSTANT$$ 1 + 1 to n - 1 do following operations . add 1 to var6 . if var5 does not exceed var2 [ var7 ] then increase var5 by var2 [ var7 ] , add 1 to var4 and exit from the current loop . when var6 becomes equal to var1 , return var4 . 
given integer typed array var0 . assign the sorted var0 to var2 . assign 1 and var2 [ 1 ] to var4 and var3 , respectively . for all var5 $$CONSTANT$$ from 2 to var1 , if var3 does not exceed var2 [ var5 ] then add var2 [ var5 ] to var3 and add 1 to var4 . 
given integer typed array var0 . assign the sorted var0 to var2 . assign 1 and var2 [ 1 ] to var4 and var3 , respectively . 
given integer typed array var0 . assign the sorted var0 to var2 . 
given integer typed array var0 . assign var0 to var2 . 
you are given an array of numbers var1 . you have to create an array of numbers var4 with the same elements as var1 . you have to set var6 to zero and var7 to zero . for each element var8 in var4 if var6 is less than or equal to var8 you have to add 1 to var7 and add var8 to var6 . 
you are given an array of numbers var1 . you have to create an array of numbers var4 with the same elements as var1 . you have to sort var4 . 
given integer typed array var0 . assign the sorted var0 to var2 . assign 1 and var2 [ 1 ] to var4 and var3 , respectively . for all var5 $$CONSTANT$$ from 2 to var1 , if var3 does not exceed var2 [ var5 ] then add var2 [ var5 ] to var3 and add 1 to var4 . return var4 . 
given integers var0 , var1 , var2 , var3 , var4 , var5 , var6 , var7 . initialize var8 to ( var1 * var2 / var6 ) , var9 to var3 * var4 , var10 to ( var5 / var7 ) . set var8 to the minimum between var8 , var9 and var10 . return var8 / var0 . 
given integers var0 , var1 , var2 , var3 , var4 , var5 , var6 , var7 . initialize var8 to ( var1 * var2 / var6 ) , var9 to var3 * var4 , var10 to ( var5 / var7 ) . set var8 to the minimum between var8 , var9 and var10 . 
given integers var0 , var1 , var2 , var3 , var4 , var5 , var6 , var7 . initialize var8 to ( var1 * var2 / var6 ) , var9 to var3 * var4 , var10 to ( var5 / var7 ) . set var8 to the minimum between var8 and var9 . 
you are given an array of numbers var1 . you have to create an array of numbers var4 with the same elements as var1 . you have to set var6 to zero and var7 to zero . for each element var8 in var4 if var6 is less than or equal to var8 you have to add 1 to var7 and add var8 to var6 . you have to return var7 . 
given integer var0 and var1 , initialise var3 equal to var0 to the power $$CONSTANT$$ ( 0 < = $$CONSTANT$$ ) such that var0 ^ $$CONSTANT$$ < var1 , initialise var2 equal to $$CONSTANT$$ . 
given integer var0 and var1 , initialise var3 equal to var0 to the power var2 ( 0 < = var2 ) such that var0 ^ var2 < var1 and var0 ^ ( var2 + 1 ) > = $$CONSTANT$$ . if var2 is more than $$CONSTANT$$ return " NO " otherwise return $$CONSTANT$$ . calc ( var0 , var1 , var2 ) 
given an array of integers var0 , initialize var6 to empty array of strings , var2 to true . for each position var3 in var0 invert the value of var2 if var0 [ var3 ] is even , append " 2 " to the end of var6 if var2 = true , append " 1 " to the end of var6 otherwise . 
given an array of integers var0 , an array of strings var6 , an integer var3 and $$CONSTANT$$ boolean var2 , invert the value of var2 if var0 [ var3 ] is even , append " 2 " to the end of var6 if var2 = true , append " 1 " to the end of var6 otherwise . 
given an array of integers var0 , initialize var6 to empty array of strings , var2 to true . for each position var3 in var0 invert the value of var2 if var0 [ var3 ] is even , append " 2 " to the end of var6 if var2 = true , append " 1 " to the end of var6 otherwise . return var6 . 
given an array of integers var0 , an integer var3 and $$CONSTANT$$ boolean var2 , invert the value of var2 if var0 [ var3 ] is even . 
given an array var0 . initialize var5 to an empty array , var1 to the length of var0 , var2 to 2 . for each var4 from 0 to var1 exclusive , perform the following operations . if var0 [ var4 ] is even , set var2 to 3 - var2 . push var2 into var5 . 
you are given an array of numbers var1 . you have to create an array of numbers var4 with the same elements as var1 . 
given an array var0 . initialize var5 to an empty array , var1 to the length of var0 , var2 to 2 . for each var4 from 0 to var1 exclusive , perform the following operations . if var0 [ var4 ] is even , set var2 to 3 - var2 . push var2 into var5 . return var5 . 
given $$CONSTANT$$ string var0 . initialize var1 to the number of occurences of ' $$CONSTANT$$ ' , var2 to the number of occurences of ' r ' , var3 to the number of occurences of ' u ' , var4 to the number of occurences of ' d ' in var0 . 
given $$CONSTANT$$ string var0 . initialize var1 to the number of occurences of ' $$CONSTANT$$ ' , var2 to the number of occurences of ' r ' , var3 to the number of occurences of ' u ' in var0 . 
given $$CONSTANT$$ string var0 . initialize var1 to the number of occurences of ' $$CONSTANT$$ ' , var2 to the number of occurences of ' r ' in var0 . 
given integers var0 and var1 , initialize var2 to empty array of strings . for as long as var1 ! = 0 , if ( var1 - 1 ) % var0 = 0 , then substract 1 from var1 , otherwise if ( var1 + 1 ) % var0 = 0 , then add 1 to var1 , otherwise if var1 % var0 ! = 0 , then append " NO " to the end of var2 and return var2 , set var1 to var1 / var0 ( rounded down ) . 
given integers var0 and var1 and an array of strings var2 , if ( var1 - 1 ) % var0 = 0 , then substract 1 from var1 , otherwise if ( var1 + 1 ) % var0 = 0 , then add 1 to var1 , otherwise if var1 % var0 ! = 0 , then append " NO " to the end of var2 and return var2 , set var1 to var1 / var0 ( rounded down ) . 
given integers var0 and var1 , initialize var2 to empty array of strings . for as long as var1 ! = 0 , if ( var1 - 1 ) % var0 = 0 , then substract 1 from var1 , otherwise if ( var1 + 1 ) % var0 = 0 , then add 1 to var1 , otherwise if var1 % var0 ! = 0 , then append " NO " to the end of var2 and return var2 , set var1 to var1 / var0 ( rounded down ) . if the cycle above ended successfully , append " YES " to the end of var2 and return var2 . 
given an integer var4 , perform the binary search to find the $$CONSTANT$$ value of var6 such that the sum of var6 / ( var3 * var3 * var3 ) ( each summand is rounded down ) over all integers var3 such that var3 > = 2 and var6 > = var3 * var3 * var3 is greater than or equal to var4 . initialize var8 to - 1 . set var8 to var6 - 1 if the sum of ( var6 - 1 ) / ( var3 * var3 * var3 ) ( each summand is rounded down ) over all integers var3 such that var3 > = 2 and var6 - 1 > = var3 * var3 * var3 is equal to var4 , otherwise set var8 to var6 if the sum of var6 / ( var3 * var3 * var3 ) ( each summand is rounded down ) over all integers var3 such that var3 > = 2 and var6 > = var3 * var3 * var3 is equal to var4 . return var8 . 
given an array of integers var0 , find the sum of all elements of var0 and store the result in var2 . count the number of elements of var0 , which are equal to 0 , such that both the previous and the next elements of var0 exist and equal to 1 . add the result to var2 . 
given an array of integers var0 , find the sum of all elements of var0 and store the result in var2 . 
given an array of integers var0 , find the sum of all elements of var0 and store the result in var2 . 
given an array var1 and an integer var0 , initialize var5 to - 1 . if there is at least one pair of 0 - based indices ( $$CONSTANT$$ ; var7 ) such that $$CONSTANT$$ < var7 and var1 [ $$CONSTANT$$ ] % var0 = var1 [ var7 ] % var0 , find the $$CONSTANT$$ var7 over all such pairs and store the result , increased by 1 , in var5 . 
given an array var1 and an integer var0 , initialize var5 to - 1 . if there is at least one pair of 0 - based indices ( $$CONSTANT$$ ; var7 ) such that $$CONSTANT$$ < var7 and var1 [ $$CONSTANT$$ ] % var0 = var1 [ var7 ] % var0 , find the $$CONSTANT$$ var7 over all such pairs and store the result , increased by 1 , in var5 . return var5 . 
given strings var0 , initialize var1 to empty string . split var0 into several disjoint substrings such that each $$CONSTANT$$ is equal to either " . " ot " - . " or " - - " . iterate over all substrings . append " 0 " to the end of var1 if current $$CONSTANT$$ is " . " , append " 1 " to the end of var1 if current $$CONSTANT$$ is " - . " , append " 2 " to the end of var1 if current $$CONSTANT$$ is " - - " . 
given strings var0 and var1 , split var0 into several disjoint substrings such that each $$CONSTANT$$ is equal to either " . " ot " - . " or " - - " . iterate over all substrings . append " 0 " to the end of var1 if current $$CONSTANT$$ is " . " , append " 1 " to the end of var1 if current $$CONSTANT$$ is " - . " , append " 2 " to the end of var1 if current $$CONSTANT$$ is " - - " . 
given strings var0 and var1 and an integer var2 , append " 0 " to the end of var1 if var0 [ var2 ] = " . " , append " 1 " to the end of var1 if var0 [ var2 ] = " - " and var2 + 1 is less than length of var0 and var0 [ var2 + 1 ] = " . " , append " 2 " to the end of var1 if var0 [ var2 ] = " - " and var2 + 1 is less than length of var0 and var0 [ var2 + 1 ] = " - " . increase var2 by 1 if var0 [ var2 ] = " - " . 
given strings var0 and var1 and an integer var2 , append " 1 " to the end of var1 if var2 + 1 is less than length of var0 and var0 [ var2 + 1 ] = " . " , append " 2 " to the end of var1 if var2 + 1 is less than length of var0 and var0 [ var2 + 1 ] = " - " . increase var2 by 1 . 
given arrays var1 and var4 , integers var2 and var7 and boolean var6 , determine if var4 [ var1 [ var7 ] % var2 ] is equal to true . set var7 + 1 in var5 and set true in var6 , if it ' $$CONSTANT$$ the case and var6 is equal to false . set var4 [ var1 [ var7 ] % var2 ] to true , if it ' $$CONSTANT$$ not the case . 
given an array of integers var0 , find the sum of all elements of var0 and store the result in var2 . count the number of elements of var0 , which are equal to 0 , such that both the previous and the next elements of var0 exist and equal to 1 . add the result to var2 and return var2 . 
given integers var8 , var9 , var11 , var12 and an array var10 . initialize var13 to the length of var10 , var14 to some big value , var15 to var13 , var16 to 0 . for each var17 from 1 to var13 exclusive , perform the following operations . initialize $$CONSTANT$$ to the distance between ( 0 , 0 ) and ( var10 [ var17 ] , 0 ) / var8 , var19 to the distance between ( var10 [ var17 ] , 0 ) and ( var11 , var12 ) / var9 . if $$CONSTANT$$ + var19 is not greater than var14 , set var14 to $$CONSTANT$$ + var19 and set var15 to var17 + 1 . 
given integers var8 , var9 , var11 , var12 and an array var10 . initialize $$CONSTANT$$ to the distance between ( 0 , 0 ) and ( var10 [ var17 ] , 0 ) / var8 , var19 to the distance between ( var10 [ var17 ] , 0 ) and ( var11 , var12 ) / var9 . if $$CONSTANT$$ + var19 is not greater than var14 , set var14 to $$CONSTANT$$ + var19 and set var15 to var17 + 1 . 
you are given an array of strings var0 . you have to create an array of strings var7 initially empty . for each position var3 in var0 if string var0 [ var3 ] does not exist at some position less than var3 in var0 you have to add string " OK " to var7 , otherwise you have to add string var0 [ $$CONSTANT$$ ] plus the decimal representation of the number of positions less than var3 with the string var0 [ var3 ] in it to var7 . 
you are given an array of strings var0 , an array of strings var7 , an index var6 and an associative container var2 . you have to set var4 to var0 [ var6 ] and add 1 to var6 . if var2 does not contains to var4 as key you have to add the pair var4 and 1 to var2 and the string " OK " to var7 , otherwise you have to set var5 to the value of the key var4 in var2 , insert string var4 plus the decimal representation of var5 in var7 , insert the pair var4 and var5 + 1 in var2 . 
given strings var0 , initialize var1 to empty string . split var0 into several disjoint substrings such that each $$CONSTANT$$ is equal to either " . " ot " - . " or " - - " . iterate over all substrings . append " 0 " to the end of var1 if current $$CONSTANT$$ is " . " , append " 1 " to the end of var1 if current $$CONSTANT$$ is " - . " , append " 2 " to the end of var1 if current $$CONSTANT$$ is " - - " . return var1 . 
you are given an array of strings var0 . you have to create an array of strings var7 initially empty . for each position var3 in var0 if string var0 [ var3 ] does not exist at some position less than var3 in var0 you have to add string " OK " to var7 , otherwise you have to add string var0 [ $$CONSTANT$$ ] plus the decimal representation of the number of positions less than var3 with the string var0 [ var3 ] in it to var7 . you have to return all strings in var7 . 
given an integer var1 and 0 - based arrays var2 , var3 of integer types . create arrays var5 and var6 where var7 th elements equal to the maximum and minimum of var2 [ var7 ] and var3 [ var7 ] , respectively . 
given integer var0 . if var0 is even number then result is strings " white " and " 1 2 " . otherwise , result is " black " . 
given integer var0 . if var0 is even number then return strings " white " and " 1 2 " in separate lines . otherwise , return " black " . 
given integers var8 , var9 , var11 , var12 and an array var10 . initialize var13 to the length of var10 , var14 to some big value , var15 to var13 , var16 to 0 . for each var17 from 1 to var13 exclusive , perform the following operations . initialize $$CONSTANT$$ to the distance between ( 0 , 0 ) and ( var10 [ var17 ] , 0 ) / var8 , var19 to the distance between ( var10 [ var17 ] , 0 ) and ( var11 , var12 ) / var9 . if $$CONSTANT$$ + var19 is not greater than var14 , set var14 to $$CONSTANT$$ + var19 and set var15 to var17 + 1 . return var15 . 
given $$CONSTANT$$ string var9 which is in the format " $$CONSTANT$$ : cd " , convert it into an integer by multiplying " $$CONSTANT$$ " by $$CONSTANT$$ and summing it with " cd " and store it in var10 . for each var12 such that var12 > = 5 * $$CONSTANT$$ and var12 < $$CONSTANT$$ * $$CONSTANT$$ , count the number of instances when var12 lies in the range var10 - var8 to var10 + t exclusive and store it in var11 . 
you are given $$CONSTANT$$ number var1 . you have to store in var3 the number of digits 1 in the representation of var1 in base 8 . 
you are given $$CONSTANT$$ number var4 and $$CONSTANT$$ number var3 . if var2 modulo 8 is equal to 1 you have to add 1 to var3 . you have to set var2 to var2 divided by 8 ( rounded down ) . 
you are given $$CONSTANT$$ number var4 and $$CONSTANT$$ number var3 . if var2 modulo 8 is equal to 1 you have to add 1 to var3 . 
you are given $$CONSTANT$$ number var1 . you have to return the number of digits 1 in the representation of var1 in base 8 . 
you are given $$CONSTANT$$ string var1 , an array of numbers var0 ( indexing is 0 - based ) . you have to store in var4 the sum of each element at position var5 in var0 with var1 [ var5 ] equal to 65 . you have to set var6 to var4 and var7 to var4 . for each position var8 in var1 if var1 [ var8 ] is equal to 65 add var0 [ var8 ] to var7 , otherwise subtract var0 [ var8 ] to var7 ; store in var6 the maximum between var6 and var7 . you have to set var7 to var4 . for each index var9 in var1 in $$CONSTANT$$ $$CONSTANT$$ if var1 [ var9 ] is equal to 65 add var0 [ var9 ] to var7 , otherwise subtract var0 [ var9 ] to var7 ; store in var6 the maximum between var6 and var7 . you have to return var6 . 
given an array var5 , string var2 and an integer var7 . set var5 [ var7 ] to var5 [ var7 + 1 ] . if var2 [ var7 ] is the uppercase letter , increase var5 [ var7 ] by 1 . 
given an array var4 , string var2 and an integer var6 . set var4 [ var6 ] to var4 [ var6 - 1 ] . if var2 [ var6 - 1 ] is the lowercase letter , increase var4 [ var6 ] by 1 . 
given integer typed array var0 . if var0 consists of only one element then if it is 15 then return " DOWN " , or if it equals 0 then reutrn " UP " , otherwise , return - 1 . if var0 consists of several elements then assign the length of var0 to var1 . if var0 [ n - 1 ] equals 0 and var0 [ n - 2 ] equals 1 then return " UP " . if var0 [ n - 1 ] equals 15 and var0 [ n - 2 ] equals $$CONSTANT$$ then return " DOWN " . otherwise , if var0 [ n - 1 ] equals var0 [ n - 2 ] then return " UP " . otherwise , return " DOWN " . 
given integers var0 , var1 . initialize var2 , var3 , var4 to var1 , var5 to 0 . while var2 or var3 or var4 is less than var0 , perform the following operations . if var2 is not greater than var3 and var2 is not greater than var4 , set var2 to the minimum between var3 + var4 - 1 and var0 ; else if var3 is not greater than var4 , set var3 to the minimum between var2 + var4 - 1 and var0 ; else set var4 to the minimum between var3 + var2 - 1 and var0 . add 1 to var5 . 
given integers var2 , var3 , var4 , var0 , var5 . if var2 is not greater than var3 and var2 is not greater than var4 , set var2 to the minimum between var3 + var4 - 1 and var0 ; else if var3 is not greater than var4 , set var3 to the minimum between var2 + var4 - 1 and var0 ; else set var4 to the minimum between var3 + var2 - 1 and var0 . add 1 to var5 . 
given integers var0 , var1 . initialize var2 , var3 , var4 to var1 , var5 to 0 . while var2 or var3 or var4 is less than var0 , perform the following operations . if var2 is not greater than var3 and var2 is not greater than var4 , set var2 to the minimum between var3 + var4 - 1 and var0 ; else if var3 is not greater than var4 , set var3 to the minimum between var2 + var4 - 1 and var0 ; else set var4 to the minimum between var3 + var2 - 1 and var0 . add 1 to var5 . return var5 . 
given $$CONSTANT$$ string var0 . if length of var0 is an odd number , return - 1 . initialize var1 to the difference between the number of characters ' r ' and the number of characters ' $$CONSTANT$$ ' in the given string . initialize var2 to the difference between the number of characters ' u ' and the number of characters ' d ' in the given string . 
given $$CONSTANT$$ string var0 . if length of var0 is an odd number , return - 1 . 
given $$CONSTANT$$ string var0 . if length of var0 is an odd number , return - 1 . initialize var1 to the difference between the number of characters ' r ' and the number of characters ' $$CONSTANT$$ ' in the given string . initialize var2 to the difference between the number of characters ' u ' and the number of characters ' d ' in the given string . push the value of ( | var1 | + | var2 | ) / 2 to var4 . 
given integers var0 , var1 . let var3 be the sum of all values ( var5 * var1 ) + 1 * ( ( var1 * ( var1 - 1 ) ) / 2 modulo 10 ^ 9 + 7 where var4 obtains values from 1 to var0 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to set var3 to zero . for each var4 between 1 and var0 set var5 to var4 * var1 + 1 modulo $$CONSTANT$$ , set var6 to ( ( var1 * ( var1 - 1 ) ) divided by 2 ) modulo $$CONSTANT$$ , set var3 to ( var3 + var5 * var6 ) modulo $$CONSTANT$$ . 
you are given $$CONSTANT$$ string var2 . if the length of var2 is odd you have to retrurn - 1 . you have to store in var4 the number of characters " $$CONSTANT$$ " in var2 minus the number or characters " $$CONSTANT$$ " in var2 . you have to store in var5 the number of characters " $$CONSTANT$$ " in var2 minus the number of characters " $$CONSTANT$$ " in var2 . you have to return the sum of the absolute values of var5 and var4 divided by 2 ( rounded down ) . 
you are given $$CONSTANT$$ string var3 , $$CONSTANT$$ string var4 . set var5 , var6 and var7 to zero . for each position var2 in var3 you have to , if var3 [ var2 ] is equal to $$CONSTANT$$ add 1 to var5 , otherwise add 1 to var6 , if var4 [ var2 ] is equal to $$CONSTANT$$ subtract 1 to var5 , otherwise if var4 [ var2 ] is equal to $$CONSTANT$$ subtract 1 to var6 , otherwise add 1 to var7 . 
you are given $$CONSTANT$$ string var3 , $$CONSTANT$$ string var4 , $$CONSTANT$$ number var5 , $$CONSTANT$$ number var6 , $$CONSTANT$$ number var7 , an index var2 . if var3 [ var2 ] is equal to $$CONSTANT$$ add 1 to var5 , otherwise add 1 to var6 . if var4 [ var2 ] is equal to $$CONSTANT$$ subtract 1 to var5 , otherwise if var4 [ var2 ] is equal to $$CONSTANT$$ subtract 1 to var6 , otherwise add 1 to var7 . 
you are given $$CONSTANT$$ number var0 . return the factorial of var0 . 
you are given $$CONSTANT$$ string var3 , $$CONSTANT$$ string var4 . set var5 , var6 and var7 to zero . for each position var2 in var3 you have to , if var3 [ var2 ] is equal to $$CONSTANT$$ add 1 to var5 , otherwise add 1 to var6 , if var4 [ var2 ] is equal to $$CONSTANT$$ subtract 1 to var5 , otherwise if var4 [ var2 ] is equal to $$CONSTANT$$ subtract 1 to var6 , otherwise add 1 to var7 . if var5 is less than zero , or var6 is less than zero , return " 0 " . return , ( the var7 power of 0 . 5 multiplicated by the value of the function func0 at var7 ) divided by ( the value of the function func0 at var5 , multiplicated by the value of the function func0 at var6 ) . 
you are given $$CONSTANT$$ number var0 . store in var1 the factorial of var0 . 
given an array var0 . initialize var1 to the length of var0 , var2 to var0 , var4 to the sum of elements of var2 , var5 to 0 . sort var2 in increasing $$CONSTANT$$ . initialize var7 to var4 / var1 . for each var8 from 0 to var1 - ( var4 modulo var1 ) exclusive , set var3 [ var8 ] to var7 . for each var9 from var1 - ( var4 modulo var1 ) to var1 exclusive , set var3 [ var9 ] to var7 + 1 . for each var10 from 0 to var1 exclusive , add | var2 [ var10 ] - var3 [ var10 ] | to var5 . 
given an array var0 . initialize var1 to the length of var0 , var2 to var0 , var4 to the sum of elements of var2 . sort var2 in increasing $$CONSTANT$$ . initialize var7 to var4 / var1 . for each var8 from 0 to var1 - ( var4 modulo var1 ) exclusive , set var3 [ var8 ] to var7 . for each var9 from var1 - ( var4 modulo var1 ) to var1 exclusive , set var3 [ var9 ] to var7 + 1 . 
given an array var0 . initialize var1 to the length of var0 , var2 to var0 , var4 to the sum of elements of var2 . sort var2 in increasing $$CONSTANT$$ . initialize var7 to var4 / var1 . for each var8 from 0 to var1 - ( var4 modulo var1 ) exclusive , set var3 [ var8 ] to var7 . for each var9 from var1 - ( var4 modulo var1 ) to var1 exclusive , set var3 [ var9 ] to var7 + 1 . 
given an array var0 . initialize var1 to the length of var0 , var2 to var0 , var4 to the sum of elements of var2 , var5 to 0 . sort var2 in increasing $$CONSTANT$$ . initialize var7 to var4 / var1 . for each var8 from 0 to var1 - ( var4 modulo var1 ) exclusive , set var3 [ var8 ] to var7 . for each var9 from var1 - ( var4 modulo var1 ) to var1 exclusive , set var3 [ var9 ] to var7 + 1 . for each var10 from 0 to var1 exclusive , add | var2 [ var10 ] - var3 [ var10 ] | to var5 . return var5 / 2 . 
given an array var0 . initialize var1 to the length of var0 , var2 to var0 , var4 to the sum of elements of var2 . sort var2 in increasing $$CONSTANT$$ . initialize var7 to var4 / var1 . for each var8 from 0 to var1 - ( var4 modulo var1 ) exclusive , set var3 [ var8 ] to var7 . 
you are given an array of numbers var1 ( indexing is 0 - based ) and an array of numbers var2 ( indexing is 0 - based ) . you have to store in var6 the minimum among each maximum between var1 [ var5 ] and var2 [ var5 ] , for each position var5 in var1 . you have to store in var7 the maximum among each minimum between var1 [ var5 ] and var2 [ var5 ] , for each position var5 in var1 . 
you are given an array of numbers var1 and an array of numbers var2 . you have to set var3 to the length of var1 . you have to create $$CONSTANT$$ var3 * 2 matrix of numbers var4 . you have to store at $$CONSTANT$$ 0 of var4 all elements of var1 . you have to store at $$CONSTANT$$ 1 of var4 all elements of var2 . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) and an array of numbers var2 ( indexing is 0 - based ) . you have to store in var6 the minimum among each maximum between var1 [ var5 ] and var2 [ var5 ] , for each position var5 in var1 . you have to store in var7 the maximum among each minimum between var1 [ var5 ] and var2 [ var5 ] , for each position var5 in var1 . if the length of var1 is equal to zero you have to return var0 - 1 , otherwise you have to return the maximum between 0 and var6 - var7 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to set var3 to zero . for each var4 between 1 and var0 set var5 to var4 * var1 + 1 modulo $$CONSTANT$$ , set var6 to ( ( var1 * ( var1 - 1 ) ) divided by 2 ) modulo $$CONSTANT$$ , set var3 to ( var3 + var5 * var6 ) modulo $$CONSTANT$$ . you have to return var3 . 
given integers var0 and var1 , initialize var3 to true and var2 to false . for as long as either var2 is true and var1 > 0 or var3 is true , set var3 to false and var2 to false ; set var2 to true and var1 to ( var1 + 1 ) / var0 if ( var1 + 1 ) % var0 = 0 ; set var2 to true and var1 to ( var1 - 1 ) / var0 if ( var1 - 1 ) % var0 = 0 ; set var2 to true and var1 to var1 / var0 if var1 % var0 = 0 . 
given integers var0 and var1 and $$CONSTANT$$ var3 and var2 , set var3 to false and var2 to false . set var2 to true and var1 to ( var1 + 1 ) / var0 if ( var1 + 1 ) % var0 = 0 . set var2 to true and var1 to ( var1 - 1 ) / var0 if ( var1 - 1 ) % var0 = 0 . set var2 to true and var1 to var1 / var0 if var1 % var0 = 0 . 
given integers var0 and var1 and $$CONSTANT$$ var3 and var2 , set var3 to false and var2 to false . set var2 to true and var1 to ( var1 + 1 ) / var0 if ( var1 + 1 ) % var0 = 0 . set var2 to true and var1 to ( var1 - 1 ) / var0 if ( var1 - 1 ) % var0 = 0 . 
given integers var0 and var1 , initialize var3 to true and var2 to false . for as long as either var2 is true and var1 > 0 or var3 is true , set var3 to false and var2 to false ; set var2 to true and var1 to ( var1 + 1 ) / var0 if ( var1 + 1 ) % var0 = 0 ; set var2 to true and var1 to ( var1 - 1 ) / var0 if ( var1 - 1 ) % var0 = 0 ; set var2 to true and var1 to var1 / var0 if var1 % var0 = 0 . return whether var1 = 0 . 
given integers var0 and var1 and $$CONSTANT$$ var3 and var2 , set var3 to false and var2 to false . set var2 to true and var1 to ( var1 + 1 ) / var0 if ( var1 + 1 ) % var0 = 0 . 
given array of integers var0 . assign var6 to empty array of integers . assign var5 and var2 to zero . assign var1 to the length of array var0 . do such operation n times : ( if var0 [ var5 ] is odd number , update var2 to 1 - var2 . increment var5 . push 2 - var2 to var6 ) . 
given arrays of integers var0 , var6 and integers var2 , var5 . if var0 [ var5 ] is odd number , update var2 to 1 - var2 . increment var5 . push 2 - var2 to var6 . 
given array of integers var0 . assign var6 to empty array of integers . assign var5 and var2 to zero . assign var1 to the length of array var0 . do such operation n times : ( if var0 [ var5 ] is odd number , update var2 to 1 - var2 . increment var5 . push 2 - var2 to var6 ) . return var6 as result . 
given array of integers var0 and integers var2 , var5 . if var0 [ var5 ] is odd number , update var2 to 1 - var2 . increment var5 . 
you are given integers var1 , var2 , var3 . let var7 be the sum of multiplications var1 * var8 where var8 obtains values from 1 to var3 , inclusive . 
given $$CONSTANT$$ string var9 which is in the format " $$CONSTANT$$ : cd " , convert it into an integer by multiplying " $$CONSTANT$$ " by $$CONSTANT$$ and summing it with " cd " and store it in var10 . for each var12 such that var12 > = 5 * $$CONSTANT$$ and var12 < $$CONSTANT$$ * $$CONSTANT$$ , count the number of instances when var12 lies in the range var10 - var8 to var10 + t exclusive and store it in var11 . return the final value store in var11 . 
given integers var0 , var1 , var2 , var3 and var4 , initialize var5 to 0 . if var0 > = var1 , then substract var1 from var0 , add var1 * var2 to var5 , initialize var6 to var3 * var1 and var7 to var2 * var1 + var4 , set var8 to the smaller of var6 and var7 ; add var8 * ( var0 / var1 ) ( the result of division is rounded down ) to var5 and set var0 to var0 % var1 if var0 > var1 ; add to var5 the smaller of var0 * var3 and var0 * var2 + var4 and return var5 , otherwise return var0 * var2 . 
given integers var0 , var1 , var2 , var3 , var4 and var5 , substract var1 from var0 , add var1 * var2 to var5 , initialize var6 to var3 * var1 and var7 to var2 * var1 + var4 , set var8 to the smaller of var6 and var7 ; add var8 * ( var0 / var1 ) ( the result of division is rounded down ) to var5 and set var0 to var0 % var1 if var0 > var1 ; add to var5 the smaller of var0 * var3 and var0 * var2 + var4 and return var5 . 
given an integer array var0 , initialize var4 and var5 to zero . initialize var6 to $$CONSTANT$$ new integer array , and push every element of var0 into var6 . sort the array var6 . for every number var6 [ var7 ] if var4 < = var6 [ var7 ] then add var6 [ var7 ] to var4 and add one to var5 . 
given an integer array var0 , initialize var6 to $$CONSTANT$$ new integer array , and push every element of var0 into var6 . sort the array var6 . 
given an integer array var0 , initialize var6 to $$CONSTANT$$ new integer array , and push every element of var0 into var6 . 
given an integer array var0 , initialize var4 and var5 to zero . initialize var6 to $$CONSTANT$$ new integer array , and push every element of var0 into var6 . sort the array var6 . for every number var6 [ var7 ] , if var4 < = var6 [ var7 ] then add var6 [ var7 ] to var4 and add one to var5 . return var5 . 
given integers var1 , var2 , var3 . initialize var4 to var1 , var5 to var2 , var6 to var3 . compute the sum of var4 * var8 over all var8 from 1 inclusive to var6 inclusive and put this value into variable var7 . return maximal number among 0 and var7 minus var5 . 
you are given integers var1 , var2 , var3 . let var7 be the sum of multiplications var1 * var8 where var8 obtains values from 1 to var3 , inclusive . if var2 is larger than or equal to var7 then return 0 . otherwise , return var7 - var2 . 
given integers var0 , var1 . initialize var2 to an array . set var2 [ 1 ] [ 1 ] to var1 . for each var3 from 1 to var0 excluisve and for each var4 from 1 to var3 , if var2 [ var3 ] [ var4 ] is greater than 1 , add ( var2 [ var3 ] [ var4 ] - 1 ) / 2 . 0 to var2 [ $$CONSTANT$$ + 1 ] [ var4 ] and to var2 [ $$CONSTANT$$ + 1 ] [ $$CONSTANT$$ + 1 ] . initialize var5 to 0 . for each var6 from 1 to var0 and for each var7 from 1 to var0 , if var2 [ var6 ] [ var7 ] is not less than 1 . 0 , increase var5 by 1 . 
given integers var0 , var1 . initialize var2 to an array . set var2 [ 1 ] [ 1 ] to var1 . for each var3 from 1 to var0 excluisve and for each var4 from 1 to var3 , if var2 [ var3 ] [ var4 ] is greater than 1 , add ( var2 [ var3 ] [ var4 ] - 1 ) / 2 . 0 to var2 [ $$CONSTANT$$ + 1 ] [ var4 ] and to var2 [ $$CONSTANT$$ + 1 ] [ $$CONSTANT$$ + 1 ] . 
given an array var2 and an integer var3 . for each var4 from 1 to var3 , if var2 [ var3 ] [ var4 ] is greater than 1 , add ( var2 [ var3 ] [ var4 ] - 1 ) / 2 . 0 to var2 [ $$CONSTANT$$ + 1 ] [ var4 ] and to var2 [ $$CONSTANT$$ + 1 ] [ $$CONSTANT$$ + 1 ] . 
given an array var2 and integers var6 , var0 , var5 . for each var7 from 1 to var0 , if var2 [ var6 ] [ var7 ] is not less than 1 . 0 , increase var5 by 1 . 
given two integers var0 , var1 . initialize var2 to an array consisting of var0 + 2 rows and var0 + 2 columns . set var2 [ 1 ] [ 1 ] to var1 . for each var3 from 2 to var0 , perform the following operations . for each var4 from 1 to var3 , perform the following operations . if var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] and var2 [ $$CONSTANT$$ - 1 ] [ var4 ] are greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] - 1 + var2 [ $$CONSTANT$$ - 1 ] [ var4 ] - 1 ) / 2 ; else if var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] is greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] - 1 ) / 2 ; else if var2 [ $$CONSTANT$$ - 1 ] [ var4 ] is greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ var4 ] - 1 ) / 2 . initialize var5 to the number of $$CONSTANT$$ pairs of values ( var6 , var7 ) such that var2 [ var6 ] [ var7 ] is not less than 1 . 
given two integers var0 , var1 . initialize var2 to an array consisting of var0 + 2 rows and var0 + 2 columns . set var2 [ 1 ] [ 1 ] to var1 . for each var3 from 2 to var0 , perform the following operations . for each var4 from 1 to var3 , perform the following operations . if var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] and var2 [ $$CONSTANT$$ - 1 ] [ var4 ] are greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] - 1 + var2 [ $$CONSTANT$$ - 1 ] [ var4 ] - 1 ) / 2 ; else if var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] is greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] - 1 ) / 2 ; else if var2 [ $$CONSTANT$$ - 1 ] [ var4 ] is greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ var4 ] - 1 ) / 2 . 
given an integer var0 . if var0 is even , return strings " white " and " 1 2 " in two separate lines . otherwise , return " black " . 
given an integer var0 . if var0 is even , store strings " white " and " 1 2 " in two separate lines in variable ret . otherwise , set ret to string " black " . 
given strings var4 and var5 and an integer var3 , find the number of positions var7 such that var4 [ var7 ] ! = var5 [ var7 ] , store the result in var6 and set var3 to the minimum of var3 and ( var6 - 1 ) / 2 ( rounded down ) . 
given strings var4 and var5 , find the number of positions var7 such that var4 [ var7 ] ! = var5 [ var7 ] , store the result in var6 and set var6 to ( var6 - 1 ) / 2 ( rounded down ) . 
given strings var4 and var5 , find the number of positions var7 such that var4 [ var7 ] ! = var5 [ var7 ] and store the result in var6 . 
given integer var0 and char array var1 . let var5 and var6 be the first values in var2 , var3 and remove these first values from arrays . if var5 is less than var6 then add to the end of var2 the value r + n , or in other case add to the end of var3 the value d + n . 
given integer var0 and char array var1 . create integer arrays var2 , var3 . for each var4 from 0 to n - 1 , if var1 [ var4 ] equals 68 then add var4 to the end of var3 , or in othe case , add var4 to the end of var2 . 
given two integers var0 , var1 . initialize var2 to an array consisting of var0 + 2 rows and var0 + 2 columns . set var2 [ 1 ] [ 1 ] to var1 . for each var3 from 2 to var0 , perform the following operations . for each var4 from 1 to var3 , perform the following operations . if var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] and var2 [ $$CONSTANT$$ - 1 ] [ var4 ] are greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] - 1 + var2 [ $$CONSTANT$$ - 1 ] [ var4 ] - 1 ) / 2 ; else if var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] is greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] - 1 ) / 2 ; else if var2 [ $$CONSTANT$$ - 1 ] [ var4 ] is greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ var4 ] - 1 ) / 2 . initialize var5 to the number of $$CONSTANT$$ pairs of values ( var6 , var7 ) such that var2 [ var6 ] [ var7 ] is not less than 1 . return var5 . 
given integers var2 , var3 , var4 , $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . dir and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ , if $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . dir = 1 , then set var5 to var3 * ( 2 * ( var2 - $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ ) + $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ - var4 ) and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . dir to - 1 if var4 < $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ , set var5 to var4 * var3 - $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ * var3 otherwise . otherwise , set var5 to var3 * ( $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ + var4 ) and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . dir to 1 if var4 > $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ , set var5 to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ * var3 - var4 * var3 otherwise . set $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ to var4 and return var5 . 
given integers var2 , var3 , var4 , $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . dir and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ , if $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . dir = 1 , then set var5 to var3 * ( 2 * ( var2 - $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ ) + $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ - var4 ) and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . dir to - 1 if var4 < $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ , set var5 to var4 * var3 - $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ * var3 otherwise . otherwise , set var5 to var3 * ( $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ + var4 ) and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . dir to 1 if var4 > $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ , set var5 to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . $$CONSTANT$$ . $$CONSTANT$$ * var3 - var4 * var3 otherwise . 
given integers var0 , var4 , var5 and integer typed arrays var1 , var2 , var3 . assign the lengths of var1 and var2 to var6 and var7 , respectively . assign 0 to var8 . for all var13 $$CONSTANT$$ from 0 to $$CONSTANT$$ - 1 , add 1 to var4 and to var5 , and if the sum of elements of var1 in the range of positions from var2 [ var4 ] - 1 to var3 [ var5 ] - 1 , inclusive , is larger than 0 then add this sum to var8 . 
given integers var0 , var4 , var5 and integer typed arrays var1 , var2 , var3 . add 1 to var4 and to var5 . if the sum of elements of var1 in the range of positions from var2 [ var4 ] - 1 to var3 [ var5 ] - 1 , inclusive , is larger than 0 then add this sum to var8 . 
given integers var0 , var1 . initialize var2 to an array . set var2 [ 1 ] [ 1 ] to var1 . for each var3 from 1 to var0 excluisve and for each var4 from 1 to var3 , if var2 [ var3 ] [ var4 ] is greater than 1 , add ( var2 [ var3 ] [ var4 ] - 1 ) / 2 . 0 to var2 [ $$CONSTANT$$ + 1 ] [ var4 ] and to var2 [ $$CONSTANT$$ + 1 ] [ $$CONSTANT$$ + 1 ] . initialize var5 to 0 . for each var6 from 1 to var0 and for each var7 from 1 to var0 , if var2 [ var6 ] [ var7 ] is not less than 1 . 0 , increase var5 by 1 . return var5 . 
given integers var0 , var4 , var5 and integer typed arrays var1 , var2 , var3 . add 1 to var4 and to var5 . let var12 be the sum of elements of var1 in the range of positions from var2 [ var4 ] - 1 to var3 [ var5 ] - 1 , inclusive . 
given integers var0 , var4 , var5 and integer typed arrays var1 , var2 , var3 . assign the lengths of var1 and var2 to var6 and var7 , respectively . assign 0 to var8 . 
given integers var0 , var4 , var5 and integer typed arrays var1 , var2 , var3 . assign the lengths of var1 and var2 to var6 and var7 , respectively . assign 0 to var8 . 
given integers var0 , var4 , var5 and integer typed arrays var1 , var2 , var3 . assign the lengths of var1 and var2 to var6 and var7 , respectively . assign 0 to var8 . for all var13 $$CONSTANT$$ from 0 to $$CONSTANT$$ - 1 , add 1 to var4 and to var5 , and if the sum of elements of var1 in the range of positions from var2 [ var4 ] - 1 to var3 [ var5 ] - 1 , inclusive , is larger than 0 then add this sum to var8 . return var8 . 
given arrays of integers var0 and var1 , initialize var3 to length of var0 and var4 to length of var1 , var7 to an array of integers of length var4 . for each position var8 in var7 find the sum of all elements of var0 at 0 - based positions from var1 [ var8 ] - 1 to var2 [ var8 ] - 1 ( both inclusive ) and store the result in var7 [ var8 ] . find the sum of all positive elements of var7 and store the result in var10 . 
given arrays of integers var0 and var1 , initialize var3 to length of var0 and var4 to length of var1 , var7 to an array of integers of length var4 . for each position var8 in var7 find the sum of all elements of var0 at 0 - based positions from var1 [ var8 ] - 1 to var2 [ var8 ] - 1 ( both inclusive ) and store the result in var7 [ var8 ] . 
given arrays of integers var7 , var0 , var1 , var2 and an integer var8 , find the sum of all elements of var0 at 0 - based positions from var1 [ var8 ] - 1 to var2 [ var8 ] - 1 ( both inclusive ) and store the result in var7 [ var8 ] . 
given arrays of integers var0 and var1 , initialize var3 to length of var0 and var4 to length of var1 . 
you are given $$CONSTANT$$ number var2 . you have to return false if var2 is divisible by some integer number between 2 and the square root of var2 . 
given integer var0 . assign 1 to var1 and to var2 . assign 0 to var4 . as long as var2 is less than var0 do following operations . assign var2 to var3 . add var1 to var2 . assign var3 to var1 . if var2 exceeds var0 then exit from the loop . add 1 to var4 . 
given integer var0 . assign var2 to var3 . add var1 to var2 . assign var3 to var1 . if var2 exceeds var0 then exit from the loop . add 1 to var4 . 
given integer var0 . assign var2 to var3 . add var1 to var2 . assign var3 to var1 . if var2 exceeds var0 then exit from the loop . 
you are given $$CONSTANT$$ number var2 . you have to return false if var2 is divisible by some integer number between 2 and the square root of var2 . you have to return true . 
you are given $$CONSTANT$$ number var1 . you have to store in var3 the ( var1 + 1 ) fibonacci number . if var3 is equal to var1 subtract 1 to var5 , otherwise subtract 2 to var5 . 
you are given $$CONSTANT$$ number var1 . you have to store in var3 the ( var1 + 1 ) fibonacci number . if var3 is equal to var1 subtract 1 to var5 , otherwise subtract 2 to var5 . return var5 . 
given matrix var0 of char type . create $$CONSTANT$$ matrix var7 of char type . assign the length of var0 to var1 . create $$CONSTANT$$ map var2 of key value of type array of char type and $$CONSTANT$$ value type of integer . for all var3 $$CONSTANT$$ from 0 to var3 < var1 do following operations . let var4 be the next value in var0 . if var2 contains the key var4 then do following operations . let var5 be the value which stands with ket var4 in var2 . add values var4 and var5 to the end of var7 . add the value $$CONSTANT$$ + 1 with key var4 into var2 . otherwise , add " OK " to the end of var7 and add the value 1 with key var4 into var2 . 
given arrays of integers var0 and var1 , initialize var3 to length of var0 and var4 to length of var1 , var7 to an array of integers of length var4 . for each position var8 in var7 find the sum of all elements of var0 at 0 - based positions from var1 [ var8 ] - 1 to var2 [ var8 ] - 1 ( both inclusive ) and store the result in var7 [ var8 ] . find the sum of all positive elements of var7 and return the result . 
given matrix var0 of char type . let var4 be the next value in var0 . if var2 contains the key var4 then do following operations . let var5 be the value which stands with ket var4 in var2 . add values var4 and var5 to the end of var7 . add the value $$CONSTANT$$ + 1 with key var4 into var2 . otherwise , add " OK " to the end of var7 and add the value 1 with key var4 into var2 . 
given integer var0 . assign 1 to var1 and to var2 . assign 0 to var4 . as long as var2 is less than var0 do following operations . assign var2 to var3 . add var1 to var2 . assign var3 to var1 . if var2 exceeds var0 then exit from the loop . add 1 to var4 . return var4 . 
given matrix var0 of char type . create $$CONSTANT$$ matrix var7 of char type . assign the length of var0 to var1 . create $$CONSTANT$$ map var2 of key value of type array of char type and $$CONSTANT$$ value type of integer . for all var3 $$CONSTANT$$ from 0 to var3 < var1 do following operations . let var4 be the next value in var0 . if var2 contains the key var4 then do following operations . let var5 be the value which stands with ket var4 in var2 . add values var4 and var5 to the end of var7 . add the value $$CONSTANT$$ + 1 with key var4 into var2 . otherwise , add " OK " to the end of var7 and add the value 1 with key var4 into var2 . after the loop is ended , return var7 . 
given an array of strings var1 , initialize var5 to empty array of strings and var2 to empty string to integer map . for each position var6 in var1 set the value of var2 at var1 [ var6 ] to 1 and append " OK " to the end of var5 if var2 has not key var1 [ var6 ] , append $$CONSTANT$$ string , obtained by concatenation of var1 [ var6 ] and $$CONSTANT$$ string representation of the value of var2 at var1 [ var6 ] , to the end of var5 and increase the value of var2 at var1 [ var6 ] by 1 otherwise . 
given arrays of strings var1 and var5 , $$CONSTANT$$ string to integer map var2 and an integer var6 , set the value of var2 at var1 [ var6 ] to 1 and append " OK " to the end of var5 if var2 has not key var1 [ var6 ] , append $$CONSTANT$$ string , obtained by concatenation of var1 [ var6 ] and $$CONSTANT$$ string representation of the value of var2 at var1 [ var6 ] , to the end of var5 and increase the value of var2 at var1 [ var6 ] by 1 otherwise . 
given an array of strings var1 , initialize var5 to empty array of strings and var2 to empty string to integer map . for each position var6 in var1 set the value of var2 at var1 [ var6 ] to 1 and append " OK " to the end of var5 if var2 has not key var1 [ var6 ] , append $$CONSTANT$$ string , obtained by concatenation of var1 [ var6 ] and $$CONSTANT$$ string representation of the value of var2 at var1 [ var6 ] , to the end of var5 and increase the value of var2 at var1 [ var6 ] by 1 otherwise . return var5 . 
given $$CONSTANT$$ string array var0 , an integer var6 , $$CONSTANT$$ map var2 and an array var7 . initialize var4 to var0 [ var6 ] . if var2 contains var4 as $$CONSTANT$$ key , put the concatenation of var4 and var2 [ var4 ] + 1 into var7 and increase var2 [ var4 ] by 1 ; else put " YES " into var7 and set var2 [ var4 ] to 0 . 
given integer var0 and char matrix var1 . assign 0 to var4 , var5 . for each var3 from n - 1 downto 0 do following operations . if var1 [ var3 ] equals " halfplus " then add 0 . 5 to var5 . add var5 to var4 . multiply var5 by 2 . 
given integer var0 and char matrix var1 . if var1 [ var3 ] equals " halfplus " then add 0 . 5 to var5 . add var5 to var4 . multiply var5 by 2 . 
given integer var0 and char matrix var1 . assign 0 to var4 , var5 . for each var3 from n - 1 downto 0 do following operations . if var1 [ var3 ] equals " halfplus " then add 0 . 5 to var5 . add var5 to var4 . multiply var5 by 2 . when the loop is ended , return result * $$CONSTANT$$ . 
you are given an array var0 of itneger type ( 0 - based ) . create an array var3 of size var1 and of integer type ( 0 - based ) , at 0 - th position containing var0 [ 0 ] and at any var2 - th position containing the larger of var0 [ var2 ] and var3 [ $$CONSTANT$$ - 1 ] . create an array var4 of size var1 and of integer type ( 0 - based ) , at n - 1 - th position containing var0 [ n - 1 ] and at any var2 - th position containing the minimum of var0 [ var2 ] and var4 [ $$CONSTANT$$ + 1 ] . let var7 be the number of such cases that pmb [ var2 ] is less than or equal to var4 [ $$CONSTANT$$ + 1 ] where var2 obtains values from 0 to var2 < n - 1 . 
you are given an array var0 of itneger type ( 0 - based ) . create an array var3 of size var1 and of integer type ( 0 - based ) , at 0 - th position containing var0 [ 0 ] and at any var2 - th position containing the larger of var0 [ var2 ] and var3 [ $$CONSTANT$$ - 1 ] . create an array var4 of size var1 and of integer type ( 0 - based ) , at n - 1 - th position containing var0 [ n - 1 ] and at any var2 - th position containing the minimum of var0 [ var2 ] and var4 [ $$CONSTANT$$ + 1 ] . 
you are given an array var0 of itneger type ( 0 - based ) . create an array var3 of size var1 and of integer type ( 0 - based ) , at 0 - th position containing var0 [ 0 ] and at any var2 - th position containing the larger of var0 [ var2 ] and var3 [ $$CONSTANT$$ - 1 ] . 
you are given an array var0 of itneger type ( 0 - based ) . create an array var3 of size var1 and of integer type ( 0 - based ) , at 0 - th position containing var0 [ 0 ] and at any var2 - th position containing the larger of var0 [ var2 ] and var3 [ $$CONSTANT$$ - 1 ] . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to $$CONSTANT$$ 2 - dimensional array of integers of dimensions var1 * 2 , var4 to 0 , var5 to 0 , var6 to $$CONSTANT$$ . for each position var7 in var0 in increasing $$CONSTANT$$ set var5 to var0 [ var7 ] if var0 [ var7 ] > var5 and set var3 [ var7 ] [ 0 ] to var5 . for each position var8 in var0 in decreasing $$CONSTANT$$ set var3 [ var8 ] [ 1 ] to var6 , set var6 to var0 [ var8 ] if var0 [ var8 ] < var6 . count the number of positions var9 in var3 such that var3 [ var9 ] [ 0 ] < = var3 [ var9 ] [ 1 ] and store the result in var4 . 
you are given an array var0 of itneger type ( 0 - based ) . create an array var3 of size var1 and of integer type ( 0 - based ) , at 0 - th position containing var0 [ 0 ] and at any var2 - th position containing the larger of var0 [ var2 ] and var3 [ $$CONSTANT$$ - 1 ] . create an array var4 of size var1 and of integer type ( 0 - based ) , at n - 1 - th position containing var0 [ n - 1 ] and at any var2 - th position containing the minimum of var0 [ var2 ] and var4 [ $$CONSTANT$$ + 1 ] . let var7 be the number of such cases that pmb [ var2 ] is less than or equal to var4 [ $$CONSTANT$$ + 1 ] where var2 obtains values from 0 to var2 < n - 1 . return an + 1 . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to $$CONSTANT$$ 2 - dimensional array of integers of dimensions var1 * 2 , var4 to 0 , var5 to 0 , var6 to $$CONSTANT$$ . for each position var7 in var0 in increasing $$CONSTANT$$ set var5 to var0 [ var7 ] if var0 [ var7 ] > var5 and set var3 [ var7 ] [ 0 ] to var5 . for each position var8 in var0 in decreasing $$CONSTANT$$ set var3 [ var8 ] [ 1 ] to var6 , set var6 to var0 [ var8 ] if var0 [ var8 ] < var6 . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to $$CONSTANT$$ 2 - dimensional array of integers of dimensions var1 * 2 , var4 to 0 , var5 to 0 , var6 to $$CONSTANT$$ . for each position var7 in var0 in increasing $$CONSTANT$$ set var5 to var0 [ var7 ] if var0 [ var7 ] > var5 and set var3 [ var7 ] [ 0 ] to var5 . for each position var8 in var0 in decreasing $$CONSTANT$$ set var3 [ var8 ] [ 1 ] to var6 , set var6 to var0 [ var8 ] if var0 [ var8 ] < var6 . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to $$CONSTANT$$ 2 - dimensional array of integers of dimensions var1 * 2 , var4 to 0 , var5 to 0 , var6 to $$CONSTANT$$ . for each position var7 in var0 in increasing $$CONSTANT$$ set var5 to var0 [ var7 ] if var0 [ var7 ] > var5 and set var3 [ var7 ] [ 0 ] to var5 . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to $$CONSTANT$$ 2 - dimensional array of integers of dimensions var1 * 2 , var4 to 0 , var5 to 0 , var6 to $$CONSTANT$$ . for each position var7 in var0 in increasing $$CONSTANT$$ set var5 to var0 [ var7 ] if var0 [ var7 ] > var5 and set var3 [ var7 ] [ 0 ] to var5 . for each position var8 in var0 in decreasing $$CONSTANT$$ set var3 [ var8 ] [ 1 ] to var6 , set var6 to var0 [ var8 ] if var0 [ var8 ] < var6 . count the number of positions var9 in var3 such that var3 [ var9 ] [ 0 ] < = var3 [ var9 ] [ 1 ] and return the result . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) and an array of numbers var2 ( indexing is 0 - based ) . you have to set var4 to zero and var6 to zero . for each position var5 in var2 you have to add var2 [ var5 ] to var4 and add the maximum between 0 and var1 [ var5 ] - var0 * var4 to var6 . you have to set var4 to zero and var7 to zero . for each position var5 in var2 in $$CONSTANT$$ $$CONSTANT$$ you have to add var2 [ var5 ] to var4 and add the maximum between 0 and var1 [ var5 ] - var0 * var4 to var7 . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) and an array of numbers var2 ( indexing is 0 - based ) . you have to set var4 to zero and var6 to zero . for each position var5 in var2 you have to add var2 [ var5 ] to var4 and add the maximum between 0 and var1 [ var5 ] - var0 * var4 to var6 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var4 to array of integers of length 2 , filled with zeroes , var7 and var8 to 0 . for each position var9 in var2 add var2 [ var3 - var9 - 1 ] to var8 , add var2 [ var9 ] to var7 , add the maximum of 0 and var1 [ var9 ] - var7 * var0 to var4 [ 0 ] and add the maximum of 0 and var1 [ var3 - var9 - 1 ] - var8 * var0 to var4 [ 1 ] . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) and an array of numbers var2 ( indexing is 0 - based ) . you have to set var4 to zero and var6 to zero . for each position var5 in var2 you have to add var2 [ var5 ] to var4 and add the maximum between 0 and var1 [ var5 ] - var0 * var4 to var6 . you have to set var4 to zero and var7 to zero . for each position var5 in var2 in $$CONSTANT$$ $$CONSTANT$$ you have to add var2 [ var5 ] to var4 and add the maximum between 0 and var1 [ var5 ] - var0 * var4 to var7 . if var6 is greater than var7 you have to return " Limak " , otherwise if var7 is greater than var6 you have to return " Radewoosh " , otherwise you have to return " $$CONSTANT$$ " . 
given arrays of integers var1 and var2 and an integer var0 , initialize var11 to empty array of strings , var3 to length of var1 , var4 , var5 , var6 and var7 to 0 . for each position var10 in var2 add var2 [ var10 ] to var4 , add var2 [ var3 - 1 - var10 ] to var5 , add the greater of 0 and var1 [ var10 ] - var0 * var4 to var6 and add the greater of 0 and var1 [ var3 - 1 - var10 ] - var0 * var5 to var7 . append " Limak " to the end of var11 if var6 > var7 . append " Radewoosh " to the end of var11 if var6 < var7 . append " $$CONSTANT$$ " to the end of var11 if var6 = var7 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var11 to empty array of strings , var3 to length of var1 , var4 , var5 , var6 and var7 to 0 . for each position var10 in var2 add var2 [ var10 ] to var4 , add var2 [ var3 - 1 - var10 ] to var5 , add the greater of 0 and var1 [ var10 ] - var0 * var4 to var6 and add the greater of 0 and var1 [ var3 - 1 - var10 ] - var0 * var5 to var7 . append " Limak " to the end of var11 if var6 > var7 . append " Radewoosh " to the end of var11 if var6 < var7 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var11 to empty array of strings , var3 to length of var1 , var4 , var5 , var6 and var7 to 0 . for each position var10 in var2 add var2 [ var10 ] to var4 , add var2 [ var3 - 1 - var10 ] to var5 , add the greater of 0 and var1 [ var10 ] - var0 * var4 to var6 and add the greater of 0 and var1 [ var3 - 1 - var10 ] - var0 * var5 to var7 . append " Limak " to the end of var11 if var6 > var7 . 
given integers var1 , var2 , var3 . initialize var4 to var1 , var5 to var2 , var6 to var3 . compute the sum of var4 * var8 over all var8 from 1 inclusive to var6 inclusive and put this value into variable var7 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var4 to array of integers of length 2 , filled with zeroes , var7 and var8 to 0 . for each position var9 in var2 add var2 [ var3 - var9 - 1 ] to var8 , add var2 [ var9 ] to var7 , add the maximum of 0 and var1 [ var9 ] - var7 * var0 to var4 [ 0 ] and add the maximum of 0 and var1 [ var3 - var9 - 1 ] - var8 * var0 to var4 [ 1 ] . return " Limak " if var4 [ 0 ] > var4 [ 1 ] , return " $$CONSTANT$$ " if var4 [ 0 ] = var4 [ 1 ] , return " Radewoosh " if var4 [ 0 ] < var4 [ 1 ] . 
given $$CONSTANT$$ string var0 , if all letters of var0 , except for the first one , are uppercase , switch the case of all letters in var0 and return the result , otherwise return var0 . 
given strings var0 and var1 , set all letters in var1 to lowercase . if first letter of var0 is uppercase , set all letters of var0 to lowercase and return the result , otherwise concatenate first letter of var0 , switched to uppercase , and var1 and return the result . 
given strings var0 and var1 , set all letters in var1 to lowercase . if first letter of var0 is uppercase , set all letters of var0 to lowercase and store the result in var1 , otherwise concatenate first letter of var0 , switched to uppercase , and var1 and store the result in var1 . 
given integer array var0 . assign var0 to var2 . assign 0 to var4 . sort var2 . for each var3 from 0 to n - 1 do following operations . if var4 does not exceed var2 [ 0 ] then add 1 to var5 , add var2 [ 0 ] to var4 , then remove the first element from var2 . 
given integer array var0 . assign var0 to var2 . assign 0 to var4 . sort var2 . 
given integer array var0 . assign var0 to var2 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var11 to empty array of strings , var3 to length of var1 , var4 , var5 , var6 and var7 to 0 . for each position var10 in var2 add var2 [ var10 ] to var4 , add var2 [ var3 - 1 - var10 ] to var5 , add the greater of 0 and var1 [ var10 ] - var0 * var4 to var6 and add the greater of 0 and var1 [ var3 - 1 - var10 ] - var0 * var5 to var7 . append " Limak " to the end of var11 if var6 > var7 . append " Radewoosh " to the end of var11 if var6 < var7 . append " $$CONSTANT$$ " to the end of var11 if var6 = var7 . return var11 . 
given integer array var0 . if var4 does not exceed var2 [ 0 ] then add 1 to var5 , add var2 [ 0 ] to var4 , then remove the first element from var2 . 
given an array var0 . initialize var2 to var0 . sort var2 in increasing $$CONSTANT$$ . initialize var4 to 0 , var5 to 0 . for each var6 from 0 to the length of var2 exclusive , if var5 is not greater than var2 [ var6 ] , increase var4 by 1 and add var2 [ var6 ] to var5 . 
given an array var0 . initialize var2 to var0 . sort var2 in increasing $$CONSTANT$$ . 
given an array var0 . initialize var2 to var0 . 
given integer array var0 . assign var0 to var2 . assign 0 to var4 . sort var2 . for each var3 from 0 to n - 1 do following operations . if var4 does not exceed var2 [ 0 ] then add 1 to var5 , add var2 [ 0 ] to var4 , then remove the first element from var2 . when the loop is ended , return var5 . 
given an array of integers var0 , initialize var4 and var5 to 0 , $$CONSTANT$$ the array var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . for each position var3 in var2 increase var5 by 1 and add var2 [ var3 ] to var4 if var4 < = var2 [ var3 ] . 
given an array var0 . initialize var2 to var0 . sort var2 in increasing $$CONSTANT$$ . initialize var4 to 0 , var5 to 0 . for each var6 from 0 to the length of var2 exclusive , if var5 is not greater than var2 [ var6 ] , increase var4 by 1 and add var2 [ var6 ] to var5 . return var4 . 
given an array of integers var0 , initialize var4 and var5 to 0 , $$CONSTANT$$ the array var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . for each position var3 in var2 increase var5 by 1 and add var2 [ var3 ] to var4 if var4 < = var2 [ var3 ] . return var5 . 
given integers var0 , var1 , var2 , var3 , var4 and var5 , substract var1 from var0 , add var1 * var2 to var5 , initialize var6 to var3 * var1 and var7 to var2 * var1 + var4 , set var8 to the smaller of var6 and var7 ; add var8 * ( var0 / var1 ) ( the result of division is rounded down ) to var5 and set var0 to var0 % var1 if var0 > var1 ; add to var5 the smaller of var0 * var3 and var0 * var2 + var4 . 
given integers var0 , var1 , var2 , var3 , var4 and var5 , substract var1 from var0 , add var1 * var2 to var5 , initialize var6 to var3 * var1 and var7 to var2 * var1 + var4 , set var8 to the smaller of var6 and var7 ; add var8 * ( var0 / var1 ) ( the result of division is rounded down ) to var5 and set var0 to var0 % var1 if var0 > var1 . 
given integers var0 , var1 , var2 , var3 , var4 and var5 , substract var1 from var0 , add var1 * var2 to var5 , initialize var6 to var3 * var1 and var7 to var2 * var1 + var4 , set var8 to the smaller of var6 and var7 . 
given array var0 of integer type . initialize var0 to new array var2 . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . initialize var4 to 0 , var5 to 0 . for each position var6 in var2 continue the loop if var4 > var2 [ var6 ] , add var2 [ var6 ] to var4 and increase var5 by 1 otherwise . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . 
given an array of integers var2 and integers var6 , var4 and var5 , continue the enclosing loop if var4 > var2 [ var6 ] , add var2 [ var6 ] to var4 and increase var5 by 1 otherwise . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 . 
given array var0 of integer type . initialize var0 to new array var2 . sort the array var2 . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var3 . sort var3 in non - decreasing $$CONSTANT$$ . initialize var5 to 0 and var6 to 0 . for each position var7 in var3 add 1 to var6 and add var3 [ var7 ] to var5 if var3 [ var7 ] > = var5 . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . initialize var4 to 0 , var5 to 0 . for each position var6 in var2 continue the loop if var4 > var2 [ var6 ] , add var2 [ var6 ] to var4 and increase var5 by 1 otherwise . return var5 . 
given an array of integers var3 and integers var7 , var6 and var5 , add 1 to var6 and add var3 [ var7 ] to var5 if var3 [ var7 ] > = var5 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var1 to the length of var0 and var2 to 1 . you have to create an array of numbers var3 of length var1 and store in it the elements in var0 . you have to sort var3 and set var5 to var3 [ 0 ] . for each var6 between 1 and var1 - 1 , if var3 [ var6 ] is greater than or equal to var5 add var3 [ var6 ] to var5 and add 1 to var2 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var1 to the length of var0 . you have to create an array of numbers var3 of length var1 and store in it the elements in var0 . you have to sort var3 and set var5 to var3 [ 0 ] . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var1 to the length of var0 . you have to create an array of numbers var3 of length var1 and store in it the elements in var0 . you have to sort var3 and set var5 to var3 [ 0 ] . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var1 to the length of var0 . you have to create an array of numbers var3 of length var1 and store in it the elements in var0 . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var3 . sort var3 in non - decreasing $$CONSTANT$$ . initialize var5 to 0 and var6 to 0 . for each position var7 in var3 add 1 to var6 and add var3 [ var7 ] to var5 if var3 [ var7 ] > = var5 . return var6 , converted to string . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var1 to the length of var0 and var2 to 1 . you have to create an array of numbers var3 of length var1 and store in it the elements in var0 . you have to sort var3 and set var5 to var3 [ 0 ] . for each var6 between 1 and var1 - 1 , if var3 [ var6 ] is greater than or equal to var5 add var3 [ var6 ] to var5 and add 1 to var2 . you have to return var2 . 
given array var0 of integer type with size var2 and an integer var1 . initialize var0 to var3 . sort var3 . assign 1 to var5 . update var6 by var3 [ 0 ] . for all var7 $$CONSTANT$$ from 1 to var7 < var2 , if var3 [ var7 ] is larger than or equal var6 then increment var5 and increment var6 by var3 [ var7 ] . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var3 . sort var3 in non - decreasing $$CONSTANT$$ . initialize var5 to 0 . 
given an array of strings var0 . initialize var1 to the length of var0 , var2 to 0 , var3 to some big value . for each var4 from 0 to var1 exclusive and for each var5 from var4 + 1 , to var1 exclusive , perform the following operations . initialize var6 to 0 . for each var7 from 0 to 5 , if var0 [ var4 ] [ var7 ] not equals var0 [ var5 ] [ var7 ] , increase var6 by 1 . set var3 to the minimum between var3 and var6 . if var1 equals 1 , return 6 . otherwise , return ( var3 - 1 ) / 2 . 
given an array of integers var1 , $$CONSTANT$$ it into $$CONSTANT$$ new array var3 . 
given array var0 of integer type with size var2 and an integer var1 . initialize var0 to var3 . sort var3 . assign 1 to var5 . update var6 by var3 [ 0 ] . for all var7 $$CONSTANT$$ from 1 to var7 < var2 , if var3 [ var7 ] is larger than or equal var6 then increment var5 and increment var6 by var3 [ var7 ] . after the loop is ended , return var5 . 
given array var0 of integer type with size var2 and an integer var1 . initialize var0 to var3 . sort var3 . assign 1 to var5 . update var6 by var3 [ 0 ] . 
given array var0 of integer type with size var2 and an integer var1 . initialize var0 to var3 . sort var3 . assign 1 to var5 . update var6 by var3 [ 0 ] . 
given array var0 of integer type with size var2 and an integer var1 . initialize var0 to var3 . sort var3 . 
given array var0 of integer type with size var2 and an integer var1 . initialize var0 to var3 . 
given an array of integers var2 and integers var0 and var1 , initialize var4 and var5 to 0 . for each position var6 in var2 add var2 [ var6 ] to var5 if var2 [ var6 ] + var5 < = var0 , increase var4 by 1 and set var5 to var2 [ var6 ] otherwise , add var5 / var1 ( rounded down ) to var4 and set var5 to var5 % var1 . increase var4 by 1 if var5 ! = 0 . 
given an array of integers var2 and integers var0 and var1 , initialize var4 and var5 to 0 . for each position var6 in var2 add var2 [ var6 ] to var5 if var2 [ var6 ] + var5 < = var0 , increase var4 by 1 and set var5 to var2 [ var6 ] otherwise , add var5 / var1 ( rounded down ) to var4 and set var5 to var5 % var1 . 
given an array of integers var2 and integers var0 , var1 , var6 , var5 and var4 , add var2 [ var6 ] to var5 if var2 [ var6 ] + var5 < = var0 , increase var4 by 1 and set var5 to var2 [ var6 ] otherwise , add var5 / var1 ( rounded down ) to var4 and set var5 to var5 % var1 . 
given an array of integers var2 and integers var0 , var6 , var5 and var4 , add var2 [ var6 ] to var5 if var2 [ var6 ] + var5 < = var0 , increase var4 by 1 and set var5 to var2 [ var6 ] otherwise . 
given an array of integers var2 and integers var0 and var1 , initialize var4 and var5 to 0 . for each position var6 in var2 add var2 [ var6 ] to var5 if var2 [ var6 ] + var5 < = var0 , increase var4 by 1 and set var5 to var2 [ var6 ] otherwise , add var5 / var1 ( rounded down ) to var4 and set var5 to var5 % var1 . increase var4 by 1 if var5 ! = 0 . return var4 . 
given two strings var2 and var3 of length var0 , calculate : 1 . number of indices where the character is + in string var2 and store it in var4 . 2 . number of indices where the character is + in string var2 and + in string var3 and store it in var5 . 3 . number of indices where the character is + in string var2 and ? in string var3 and store it in var6 . 
given two strings var2 and var3 , calculate : 1 . number of indices where the character is + in string var2 and store it in var4 . 2 . number of indices where the character is + in string var2 and + in string var3 and store it in var5 . 3 . number of indices where the character is + in string var2 and ? in string var3 and store it in var6 . 
given two strings var2 and var3 of length var0 , calculate : 1 . number of indices where the character is + in string var2 and store it in var4 . 2 . number of indices where the character is + in string var2 and + in string var3 and store it in var5 . 3 . number of indices where the character is + in string var2 and ? in string var3 and store it in var6 . calculate the final value as x as follows : 1 . x = 0 if var4 - var5 > $$CONSTANT$$ or var4 - var5 < 0 2 . x = number of ways to choose var4 - var5 objects from var6 total objects divided by 2 ^ var6 . return x 
you are given $$CONSTANT$$ number var1 . you have to store in var3 the ( var1 + 1 ) fibonacci number . 
given an integer var0 , initialize var2 , var3 and var1 to zeroes . while var2 still less than or equals to var0 , set var3 to sum of var2 and var3 , then set var2 to the immediately previous value of var3 , then add 1 to var1 . 
given an integer var0 . initialize var3 to the index of the $$CONSTANT$$ fibonacci number which is not greater than var0 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var1 to the length of var0 . you have to create an array of numbers var4 of length var1 . for each position var5 in var0 , if var0 [ var5 ] - var4 [ var5 ] is less than 0 you have to return " NO " ; you have to set var3 to ( var0 [ var5 ] - var4 [ var5 ] ) modulo 2 ; if var3 is equal to zero you have to continue in the enclosing loop , otherwise you have to set var7 to var5 + 1 , if var7 is greater than or equal to var1 you have to return " NO " , otherwise you have to add 1 to var4 [ var7 ] . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var1 to the length of var0 . you have to create an array of numbers var4 of length var1 . for each position var5 in var0 , if var0 [ var5 ] - var4 [ var5 ] is less than 0 you have to return " NO " ; you have to set var3 to ( var0 [ var5 ] - var4 [ var5 ] ) modulo 2 ; if var3 is equal to zero you have to continue in the enclosing loop , otherwise you have to set var7 to var5 + 1 , if var7 is greater than or equal to var1 you have to return " NO " , otherwise you have to add 1 to var4 [ var7 ] . you have to return " YES " . 
you are given an index var5 , $$CONSTANT$$ number var1 , an array of numbers var4 , an array of numbers var0 . if var0 [ var5 ] - var4 [ var5 ] is less than 0 you have to return " NO " . you have to set var3 to ( var0 [ var5 ] - var4 [ var5 ] ) modulo 2 . if var3 is equal to zero you have to continue in the enclosing loop , otherwise you have to set var7 to var5 + 1 , if var7 is greater than or equal to var1 you have to return " NO " , otherwise you have to add 1 to var4 [ var7 ] . 
you are given an array of numbers var0 , an array of numbers var4 , an index var5 , an array of strings var8 . if var0 [ var5 ] - var4 [ var5 ] is less than 0 you have to return " NO " . you have to set var3 to ( var0 [ var5 ] - var4 [ var5 ] ) modulo 2 . 
you are given an index var5 , $$CONSTANT$$ number var1 , an array of numbers var4 . you have to set var7 to var5 + 1 . if var7 is greater than or equal to var1 you have to return " NO " , otherwise you have to add 1 to var4 [ var7 ] . 
given an integer var0 , initialize var2 , var3 and var1 to zeroes . while var2 still less than or equals to var0 , set var3 to sum of var2 and var3 , then set var2 to the immediately previous value of var3 , then add 1 to var1 . return the value of var1 . 
you are given an array of numbers var0 , an array of numbers var4 , an index var5 , an array of strings var8 . if var0 [ var5 ] - var4 [ var5 ] is less than 0 you have to return " NO " . 
given an array var0 , find the sum of all elements of var0 and store the result in var2 . 
given an integer var0 . return the index of the $$CONSTANT$$ fibonacci number which is not greater than var0 . 
given char typed array var0 . assign var0 to var1 with all elements being separated by spaces . assign to var2 the length of var1 after first index being removed . assing 2 and 0 to var3 and var4 , respectively . assign 1 to var5 . as long as var3 does not exceed var2 do following operations . add 1 to var5 . if n - t is divisble by 3 then increase var4 by 1 . increase var3 by the value ( 3 * var5 ) - 1 . 
given char typed array var0 . add 1 to var5 . if n - t is divisble by 3 then increase var4 by 1 . increase var3 by the value ( 3 * var5 ) - 1 . 
given char typed array var0 . add 1 to var5 . if n - t is divisble by 3 then increase var4 by 1 . 
given an array var0 . initialize var1 to the length of var0 , var2 to var0 , var4 to the sum of elements of var2 . sort var2 in increasing $$CONSTANT$$ . initialize var7 to var4 / var1 . for each var8 from 0 to var1 - ( var4 modulo var1 ) exclusive , set var3 [ var8 ] to var7 . 
given an array var0 , return the average value of elements of var0 . 
given an array var0 . initialize var1 to the length of var0 , var2 to var0 , var4 to the sum of elements of var2 . sort var2 in increasing $$CONSTANT$$ . initialize var7 to var4 / var1 . 
given an array var0 . initialize var1 to the length of var0 , var2 to var0 , var4 to the sum of elements of var2 . sort var2 in increasing $$CONSTANT$$ . initialize var7 to var4 / var1 . 
given an array var0 . initialize var2 to var0 , var4 to the sum of elements of var2 . 
given strings var0 and var1 . initialize var2 to var0 and var3 to var1 . create array ( 0 - based ) var4 of length equal to length of var3 + 1 where var4 [ var5 ] equals to the number of positions $$CONSTANT$$ < var5 such that var3 [ $$CONSTANT$$ ] equals to $$CONSTANT$$ . for each var7 from 0 inclusive to len ( var2 ) exclusive let var8 be var4 [ len ( var3 ) - len ( var2 ) + var7 + 1 ] - var4 [ var7 ] and var9 be len ( var3 ) - len ( var2 ) + 1 - var8 , if var2 [ var7 ] equals to 48 then add var8 to var6 , otherwise add var9 to var6 . 
given strings var2 and var3 , array var4 of integers , index var7 and integer var6 . let var8 be var4 [ len ( var3 ) - len ( var2 ) + var7 + 1 ] - var4 [ var7 ] and var9 be len ( var3 ) - len ( var2 ) + 1 - var8 . if var2 [ var7 ] equals to 48 then add var8 to var6 , otherwise add var9 to var6 . 
given strings var0 and var1 . initialize var2 to var0 and var3 to var1 . create array ( 0 - based ) var4 of length equal to length of var3 + 1 where var4 [ var5 ] equals to the number of positions $$CONSTANT$$ < var5 such that var3 [ $$CONSTANT$$ ] equals to $$CONSTANT$$ . 
you are given integers var0 and var1 . perform $$CONSTANT$$ binary search on the range from 0 to $$CONSTANT$$ . let var5 be the arithmetic mean between the $$CONSTANT$$ and $$CONSTANT$$ bounds of the range ( rounded down ) . set an integer var6 to var1 + var5 * 3 . if ( ( 2 * var6 ) + ( 3 * ( ( var6 * ( var6 - 1 ) ) divided by two ( rounded down ) ) ) is less than or equal to var0 , set the range ' $$CONSTANT$$ $$CONSTANT$$ bound to var5 + 1 , otherwise set the range ' $$CONSTANT$$ $$CONSTANT$$ bound to var5 . 
you are given integers var0 , var3 , var4 and var1 . set an integer var5 to the sum of var3 and var4 divided by two ( rounded down ) . set an integer var6 to var1 + var5 * 3 . if ( ( 2 * var6 ) + ( 3 * ( ( var6 * ( var6 - 1 ) ) divided by two ( rounded down ) ) ) is less than or equal to var0 , set var3 to var5 + 1 , otherwise set var4 to var5 . 
given strings var0 and var1 . initialize var2 to var0 and var3 to var1 . create array ( 0 - based ) var4 of length equal to length of var3 + 1 where var4 [ var5 ] equals to the number of positions $$CONSTANT$$ < var5 such that var3 [ $$CONSTANT$$ ] equals to $$CONSTANT$$ . for each var7 from 0 inclusive to len ( var2 ) exclusive let var8 be var4 [ len ( var3 ) - len ( var2 ) + var7 + 1 ] - var4 [ var7 ] and var9 be len ( var3 ) - len ( var2 ) + 1 - var8 , if var2 [ var7 ] equals to 48 then add var8 to var6 , otherwise add var9 to var6 . return var6 . 
you are given integers var0 and var1 . perform $$CONSTANT$$ binary search on the range from 0 to $$CONSTANT$$ . let var5 be the arithmetic mean between the $$CONSTANT$$ and $$CONSTANT$$ bounds of the range ( rounded down ) . set an integer var6 to var1 + var5 * 3 . if ( ( 2 * var6 ) + ( 3 * ( ( var6 * ( var6 - 1 ) ) divided by two ( rounded down ) ) ) is less than or equal to var0 , set the range ' $$CONSTANT$$ $$CONSTANT$$ bound to var5 + 1 , otherwise set the range ' $$CONSTANT$$ $$CONSTANT$$ bound to var5 . return the result of the search . 
given char typed array var0 . assign var0 to var1 with all elements being separated by spaces . assign to var2 the length of var1 after first index being removed . assing 2 and 0 to var3 and var4 , respectively . assign 1 to var5 . as long as var3 does not exceed var2 do following operations . add 1 to var5 . if n - t is divisble by 3 then increase var4 by 1 . increase var3 by the value ( 3 * var5 ) - 1 . when the loop is ended , return var4 . 
given char array var0 . create char matrix var4 . create map var1 of key type integer and value type of char typed array consisting of values " O - | - OOOO " , " O - | O - OOO " , " O - | OO - OO " , " O - | OOO - O " , " O - | OOOO - " , " - O | - OOOO " , " - O | O - OOO " , " - O | OO - OO " , " - O | OOO - O " , " - O | OOOO - " where keys are numbered from 0 to 9 . for each var3 from last position of var0 downto 0 , add to the end of var4 the key in var1 , corresponding to value var0 [ var3 ] - 48 . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to $$CONSTANT$$ 2 - dimensional array of integers of dimensions var1 * 2 , var4 to 0 , var5 to 0 , var6 to $$CONSTANT$$ . for each position var7 in var0 in increasing $$CONSTANT$$ set var5 to var0 [ var7 ] if var0 [ var7 ] > var5 and set var3 [ var7 ] [ 0 ] to var5 . 
given an array of integers var0 , $$CONSTANT$$ 2 - dimensional array of integers var3 and integers var8 and var6 , set var3 [ var8 ] [ 1 ] to var6 , set var6 to var0 [ var8 ] if var0 [ var8 ] < var6 . 
given an array of integers var0 , $$CONSTANT$$ 2 - dimensional array of integers var3 and integers var7 and var5 , set var5 to var0 [ var7 ] if var0 [ var7 ] > var5 and set var3 [ var7 ] [ 0 ] to var5 . 
given integer var0 and 0 - based , char typed array var1 . create an array var8 of integer type . create $$CONSTANT$$ zero based array var3 of size n + 1 at var4 th position containing the number of occurences of $$CONSTANT$$ in var1 before the position $$CONSTANT$$ + 1 . if total number of occurences of $$CONSTANT$$ in var1 , equals 1 or equals n - 1 then return 0 . assign var0 to var5 . set the minimum of var5 and var2 - var3 [ var2 - 1 ] to var5 . for all var6 $$CONSTANT$$ from 1 to n - t , set the minimum of var5 and t - $$CONSTANT$$ [ var6 + var2 - 1 ] + $$CONSTANT$$ [ var6 - 1 ] to var5 . after this , for all var7 $$CONSTANT$$ from ( var0 - var2 ) + 1 to n - 1 , update var5 by the minimum of var5 and var2 - ( ( var3 [ var0 - 1 ] - var3 [ var7 - 1 ] ) + var3 [ var7 + var2 - var0 - 1 ] ) . 
given integer var0 and 0 - based , char typed array var1 . create an array var8 of integer type . create $$CONSTANT$$ zero based array var3 of size n + 1 at var4 th position containing the number of occurences of $$CONSTANT$$ in var1 before the position $$CONSTANT$$ + 1 . if total number of occurences of $$CONSTANT$$ in var1 , equals 1 or equals n - 1 then return 0 . assign var0 to var5 . set the minimum of var5 and var2 - var3 [ var2 - 1 ] to var5 . for all var6 $$CONSTANT$$ from 1 to n - t , set the minimum of var5 and var3 [ var6 + var2 - 1 ] - var3 [ var6 - 1 ] to var5 . 
given integer var0 and 0 - based , char typed array var1 . create an array var8 of integer type . create $$CONSTANT$$ zero based array var3 of size n + 1 at var4 th position containing the number of occurences of $$CONSTANT$$ in var1 before the position $$CONSTANT$$ + 1 . if total number of occurences of $$CONSTANT$$ in var1 , equals 1 or equals n - 1 then return 0 . assign var0 to var5 . set the minimum of var5 and var2 - var3 [ var2 - 1 ] to var5 . for all var6 $$CONSTANT$$ from 1 to n - t , set the minimum of var5 and var3 [ var6 + var2 - 1 ] - var3 [ var6 - 1 ] to var5 . 
given integer var0 and 0 - based , char typed array var1 . create an array var8 of integer type . create $$CONSTANT$$ zero based array var3 of size n + 1 at var4 th position containing the number of occurences of $$CONSTANT$$ in var1 before the position $$CONSTANT$$ + 1 . if total number of occurences of $$CONSTANT$$ in var1 , equals 1 or equals n - 1 then return 0 . assign var0 to var5 . 
given integer var0 and 0 - based , char typed array var1 . create an array var8 of integer type . create $$CONSTANT$$ zero based array var3 of size n + 1 at var4 th position containing the number of occurences of $$CONSTANT$$ in var1 before the position $$CONSTANT$$ + 1 . if total number of occurences of $$CONSTANT$$ in var1 , equals 1 or equals n - 1 then return 0 . assign var0 to var5 . 
given integer var0 and 0 - based , char typed array var1 . create an array var8 of integer type . create $$CONSTANT$$ zero based array var3 of size n + 1 at var4 th position containing the number of occurences of $$CONSTANT$$ in var1 before the position $$CONSTANT$$ + 1 . if total number of occurences of $$CONSTANT$$ in var1 , equals 1 or equals n - 1 then return 0 . 
given integer var0 and 0 - based , char typed array var1 . create an array var8 of integer type . create $$CONSTANT$$ zero based array var3 of size n + 1 at var4 th position containing the number of occurences of $$CONSTANT$$ in var1 before the position $$CONSTANT$$ + 1 . 
given integer var0 and 0 - based , char typed array var1 . if var1 [ var4 ] equals $$CONSTANT$$ then increase var2 by 1 . assign var2 to var3 [ var4 ] . 
given integer array var0 . initialize var2 to the number of ones in var0 . add to var2 the number of such position var3 that var0 [ var3 ] equals 0 and var0 [ $$CONSTANT$$ - 1 ] equals 1 and var0 [ $$CONSTANT$$ + 1 ] equals 1 . 
given integer array var0 . initialize var2 to the number of ones in var0 . 
given integer array var0 . initialize var2 to the number of ones in var0 . 
given 0 - based array var0 of integer type . let var4 be the position of first non - zero element in var0 . assign 0 to var5 . as long as var4 is less than the length of var0 by increasing it by 1 do following operaitons . if current value in var0 is zero then increase var5 by 1 . otherwise , if var5 equals 1 then increase var3 by 2 and set 0 to var5 . otherwise , increase var3 by 1 and set 0 to var5 . 
given 0 - based array var0 of integer type . let var4 be the position of first non - zero element in var0 . 
given 0 - based array var0 of integer type . let var4 be the position of first non - zero element in var0 . 
given integers var0 , var1 , var2 . assign to var3 the value n * $$CONSTANT$$ + 1 . assign 0 to var4 . as long as var3 - var4 is larger than 1 do following operations . assign to var5 the value var4 + ( ( var3 - var4 ) / 2 ) . assign 0 to var7 . for all var6 $$CONSTANT$$ from var0 downto 1 , increase var7 by the minimum of var1 and half / rows . if var2 is larger than var7 then assign var5 to var4 . otherwise , assign var5 to var3 . 
given integers var0 , var1 , var2 . assign to var5 the value var4 + ( ( var3 - var4 ) / 2 ) . assign 0 to var7 . for all var6 $$CONSTANT$$ from var0 downto 1 , increase var7 by the minimum of var1 and half / rows . if var2 is larger than var7 then assign var5 to var4 . otherwise , assign var5 to var3 . 
given integers var0 , var1 , var2 . assign to var5 the value var4 + ( ( var3 - var4 ) / 2 ) . assign 0 to var7 . for all var6 $$CONSTANT$$ from var0 downto 1 , increase var7 by the minimum of var1 and half / rows . 
given integer var0 and 0 - based , char typed array var1 . create an array var8 of integer type . create $$CONSTANT$$ zero based array var3 of size n + 1 at var4 th position containing the number of occurences of $$CONSTANT$$ in var1 before the position $$CONSTANT$$ + 1 . if total number of occurences of $$CONSTANT$$ in var1 , equals 1 or equals n - 1 then return 0 . assign var0 to var5 . set the minimum of var5 and var2 - var3 [ var2 - 1 ] to var5 . for all var6 $$CONSTANT$$ from 1 to n - t , set the minimum of var5 and t - $$CONSTANT$$ [ var6 + var2 - 1 ] + $$CONSTANT$$ [ var6 - 1 ] to var5 . after this , for all var7 $$CONSTANT$$ from ( var0 - var2 ) + 1 to n - 1 , update var5 by the minimum of var5 and var2 - ( ( var3 [ var0 - 1 ] - var3 [ var7 - 1 ] ) + var3 [ var7 + var2 - var0 - 1 ] ) . return var5 . 
given an array of strings var0 . for every string var4 in var0 in $$CONSTANT$$ from 0 to ( | var0 | - 1 ) , add 1 to the number of occurrences of var4 . then , if that number is 1 , set the answer to var4 to be " OK " . otherwise , create $$CONSTANT$$ string str which consists of var4 contacted to the number of its previous occurrences , set the number of occurrences to str to 1 , and set the answer to var4 to be str . 
given an array of integers var0 , initialize var4 and var5 to 0 , $$CONSTANT$$ the array var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . 
given an array of integers var0 , initialize var4 and var5 to 0 , $$CONSTANT$$ the array var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ . 
given an array of integers var0 , $$CONSTANT$$ the array var0 into $$CONSTANT$$ new array var2 . 
given an array of strings var0 . for every string var4 in var0 in $$CONSTANT$$ from 0 to ( | var0 | - 1 ) , add 1 to the number of occurrences of var4 . then , if that number is 1 , set the answer to var4 to be " OK " . otherwise , create $$CONSTANT$$ string str which consists of var4 contacted to the number of its previous occurrences , set the number of occurrences to str to 1 , and set the answer to var4 to be str . return $$CONSTANT$$ list of strings which is the answers to each of the strings in var0 . 
given 0 - based array var0 of integer type . let var4 be the position of first non - zero element in var0 . assign 0 to var5 . as long as var4 is less than the length of var0 by increasing it by 1 do following operaitons . if current value in var0 is zero then increase var5 by 1 . otherwise , if var5 equals 1 then increase var3 by 2 and set 0 to var5 . otherwise , increase var3 by 1 and set 0 to var5 . when var4 becomes equal to the length of var0 , return var3 . 
given an array of integers var1 and an integer var0 , count the number of elements of array var1 , which are less than var0 . set var5 to the difference between var0 and the result . increase var5 by 1 , if var0 is present in array var1 . return var5 . 
given integer array var0 . initialize var2 to the number of ones in var0 . add to var2 the number of such position var3 that var0 [ var3 ] equals 0 and var0 [ $$CONSTANT$$ - 1 ] equals 1 and var0 [ $$CONSTANT$$ + 1 ] equals 1 . return var2 . 
given an integer var0 , initialize var1 to array of integers of length 2 * var0 . for each positive integer var2 such that 2 * var2 < = var0 set var1 [ var2 ] and var1 [ var0 + 1 - var2 ] to 2 * var2 - 1 . for each positive integer var3 such that 2 * var3 < = var0 - 1 set var1 [ var0 + var3 ] and var1 [ 2 * var0 - var3 ] to 2 * var3 . set var1 [ 0 ] to var0 . set var1 [ var0 / 2 + 1 ] to var0 if var0 is odd , set var1 [ var0 + ( var0 - 1 ) / 2 + 1 ] to var0 otherwise ( all divisions are rounded down to nearest integer ) . concatenate string representations of elements of var1 , separating them by space , and store the result in var4 . 
given an integer var0 , initialize var1 to array of integers of length 2 * var0 . for each positive integer var2 such that 2 * var2 < = var0 set var1 [ var2 ] and var1 [ var0 + 1 - var2 ] to 2 * var2 - 1 . for each positive integer var3 such that 2 * var3 < = var0 - 1 set var1 [ var0 + var3 ] and var1 [ 2 * var0 - var3 ] to 2 * var3 . set var1 [ 0 ] to var0 . set var1 [ var0 / 2 + 1 ] to var0 if var0 is odd , set var1 [ var0 + ( var0 - 1 ) / 2 + 1 ] to var0 otherwise ( all divisions are rounded down to nearest integer ) . concatenate string representations of elements of var1 , separating them by space , and return the result . 
given an integer var0 , initialize var1 to array of integers of length 2 * var0 . for each positive integer var2 such that 2 * var2 < = var0 set var1 [ var2 ] and var1 [ var0 + 1 - var2 ] to 2 * var2 - 1 . for each positive integer var3 such that 2 * var3 < = var0 - 1 set var1 [ var0 + var3 ] and var1 [ 2 * var0 - var3 ] to 2 * var3 . set var1 [ 0 ] to var0 . set var1 [ var0 / 2 + 1 ] to var0 if var0 is odd , set var1 [ var0 + ( var0 - 1 ) / 2 + 1 ] to var0 otherwise ( all divisions are rounded down to nearest integer ) . 
given an integer var0 , initialize var1 to array of integers of length 2 * var0 . for each positive integer var2 such that 2 * var2 < = var0 set var1 [ var2 ] and var1 [ var0 + 1 - var2 ] to 2 * var2 - 1 . for each positive integer var3 such that 2 * var3 < = var0 - 1 set var1 [ var0 + var3 ] and var1 [ 2 * var0 - var3 ] to 2 * var3 . set var1 [ 0 ] to var0 . 
given an integer var0 , initialize var1 to array of integers of length 2 * var0 . for each positive integer var2 such that 2 * var2 < = var0 set var1 [ var2 ] and var1 [ var0 + 1 - var2 ] to 2 * var2 - 1 . for each positive integer var3 such that 2 * var3 < = var0 - 1 set var1 [ var0 + var3 ] and var1 [ 2 * var0 - var3 ] to 2 * var3 . 
given an integer var0 , initialize var1 to array of integers of length 2 * var0 . for each positive integer var2 such that 2 * var2 < = var0 set var1 [ var2 ] and var1 [ var0 + 1 - var2 ] to 2 * var2 - 1 . 
given an integer var0 , initialize var1 to array of integers of length 2 * var0 . for each positive integer var2 such that 2 * var2 < = var0 set var1 [ var2 ] and var1 [ var0 + 1 - var2 ] to 2 * var2 - 1 . 
given $$CONSTANT$$ two - dimensional array var2 and an integer var3 . for each var4 from 1 to var3 , perform the following operations . if var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] and var2 [ $$CONSTANT$$ - 1 ] [ var4 ] are greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] - 1 + var2 [ $$CONSTANT$$ - 1 ] [ var4 ] - 1 ) / 2 ; else if var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] is greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ $$CONSTANT$$ - 1 ] - 1 ) / 2 ; else if var2 [ $$CONSTANT$$ - 1 ] [ var4 ] is greater than 1 , set var2 [ var3 ] [ var4 ] to ( var2 [ $$CONSTANT$$ - 1 ] [ var4 ] - 1 ) / 2 . 
given $$CONSTANT$$ two - dimensional array var2 and integer var6 . initialize var5 to the number of $$CONSTANT$$ values of var7 such that var2 [ var6 ] [ var7 ] is not less than 1 . 
given integers var0 , var1 , var2 . assign to var3 the value n * $$CONSTANT$$ + 1 . assign 0 to var4 . as long as var3 - var4 is larger than 1 do following operations . assign to var5 the value var4 + ( ( var3 - var4 ) / 2 ) . assign 0 to var7 . for all var6 $$CONSTANT$$ from var0 downto 1 , increase var7 by the minimum of var1 and half / rows . if var2 is larger than var7 then assign var5 to var4 . otherwise , assign var5 to var3 . when the loop is ended , return var3 . 
you are given $$CONSTANT$$ string var1 , an array of numbers var0 ( indexing is 0 - based ) . you have to store in var4 the sum of each element at position var5 in var0 with var1 [ var5 ] equal to 65 . you have to set var6 to var4 and var7 to var4 . for each position var8 in var1 if var1 [ var8 ] is equal to 65 add var0 [ var8 ] to var7 , otherwise subtract var0 [ var8 ] to var7 ; store in var6 the maximum between var6 and var7 . you have to set var7 to var4 . for each index var9 in var1 in $$CONSTANT$$ $$CONSTANT$$ if var1 [ var9 ] is equal to 65 add var0 [ var9 ] to var7 , otherwise subtract var0 [ var9 ] to var7 ; store in var6 the maximum between var6 and var7 . 
you are given $$CONSTANT$$ string var1 , an array of numbers var0 ( indexing is 0 - based ) . you have to store in var4 the sum of each element at position var5 in var0 with var1 [ var5 ] equal to 65 . you have to set var6 to var4 and var7 to var4 . for each position var8 in var1 if var1 [ var8 ] is equal to 65 add var0 [ var8 ] to var7 , otherwise subtract var0 [ var8 ] to var7 ; store in var6 the maximum between var6 and var7 . you have to set var7 to var4 . 
you are given $$CONSTANT$$ string var1 , an array of numbers var0 ( indexing is 0 - based ) . you have to store in var4 the sum of each element at position var5 in var0 with var1 [ var5 ] equal to 65 . you have to set var6 to var4 and var7 to var4 . for each position var8 in var1 if var1 [ var8 ] is equal to 65 add var0 [ var8 ] to var7 , otherwise subtract var0 [ var8 ] to var7 ; store in var6 the maximum between var6 and var7 . 
you are given $$CONSTANT$$ string var1 , an array of numbers var0 . you have to store in var4 the sum of each element at position var5 in var0 with var1 [ var5 ] equal to 65 . you have to set var6 to var4 and var7 to var4 . 
you are given $$CONSTANT$$ string var1 , an array of numbers var0 . you have to store in var4 the sum of each element at position var5 in var0 with var1 [ var5 ] equal to 65 . you have to set var6 to var4 and var7 to var4 . 
you are given $$CONSTANT$$ string var1 , an array of numbers var0 . you have to store in var4 the sum of each element at position var5 in var0 with var1 [ var5 ] equal to 65 . 
you are given $$CONSTANT$$ string var1 , an array of numbers var0 , an index var8 , $$CONSTANT$$ number var7 , $$CONSTANT$$ number var6 . if var1 [ var8 ] is equal to 65 add var0 [ var8 ] to var7 , otherwise subtract var0 [ var8 ] to var7 . you have to store in var6 the maximum between var6 and var7 . 
you are given $$CONSTANT$$ string var1 , an array of numbers var0 ( indexing is 0 - based ) , an index var9 , $$CONSTANT$$ number var7 , $$CONSTANT$$ number var6 . if var1 [ var9 ] is equal to 65 add var0 [ var9 ] to var7 , otherwise subtract var0 [ var9 ] to var7 . you have to store in var6 the maximum between var6 and var7 . 
given an array of integers var0 and $$CONSTANT$$ string var1 , initialize var3 to array of $$CONSTANT$$ of length equal to length of var0 . for each position var5 in var1 set var3 [ var5 ] to whether var1 [ var5 ] is equal to " B " . find the sum of var0 [ var7 ] at all positions var7 such that var3 [ var7 ] is true and store the result in var6 . initialize var8 and var9 to var6 . for each position var10 in var0 substract var0 [ var10 ] from var8 if var3 [ var10 ] is true , add var0 [ var10 ] to var8 otherwise , and set var9 to var8 if var8 > var9 . set var8 to var6 . for each position var11 in var0 in decreasing $$CONSTANT$$ substract var0 [ var11 ] from var8 if var3 [ var11 ] is true , add var0 [ var11 ] to var8 otherwise , and set var9 to var8 if var8 > var9 . 
given an array of integers var0 and $$CONSTANT$$ string var1 , initialize var3 to array of $$CONSTANT$$ of length equal to length of var0 . for each position var5 in var1 set var3 [ var5 ] to whether var1 [ var5 ] is equal to " B " . find the sum of var0 [ var7 ] at all positions var7 such that var3 [ var7 ] is true and store the result in var6 . initialize var8 and var9 to var6 . for each position var10 in var0 substract var0 [ var10 ] from var8 if var3 [ var10 ] is true , add var0 [ var10 ] to var8 otherwise , set var9 to var8 if var8 > var9 . set var8 to var6 . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) , an array of numbers var2 ( indexing is 0 - based ) . you have to store in var6 the minimum among the maximum between var1 [ var8 ] - 1 and var2 [ var8 ] - 1 , for each position var8 in var1 . you have to store in var7 the maximum among the minimum between var1 [ var8 ] - 1 and var2 [ var8 ] - 1 , for each position var8 in var1 . if var7 is less than var6 set var5 to var6 - var7 , otherwise set var5 to zero . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) , an array of numbers var2 ( indexing is 0 - based ) . you have to store in var6 the minimum among the maximum between var1 [ var8 ] - 1 and var2 [ var8 ] - 1 , for each position var8 in var1 . you have to store in var7 the maximum among the minimum between var1 [ var8 ] - 1 and var2 [ var8 ] - 1 , for each position var8 in var1 . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) , an array of numbers var2 ( indexing is 0 - based ) . you have to store in var6 the minimum among the maximum between var1 [ var8 ] - 1 and var2 [ var8 ] - 1 , for each position var8 in var1 . you have to store in var7 the maximum among the minimum between var1 [ var8 ] - 1 and var2 [ var8 ] - 1 , for each position var8 in var1 . if var7 is less than var6 set var5 to var6 - var7 , otherwise set var5 to zero . you have to return var5 . 
given an array of integers var0 and $$CONSTANT$$ string var1 , initialize var3 to array of $$CONSTANT$$ of length equal to length of var0 . for each position var5 in var1 set var3 [ var5 ] to whether var1 [ var5 ] is equal to " B " . find the sum of var0 [ var7 ] at all positions var7 such that var3 [ var7 ] is true and store the result in var6 . initialize var8 and var9 to var6 . for each position var10 in var0 substract var0 [ var10 ] from var8 if var3 [ var10 ] is true , add var0 [ var10 ] to var8 otherwise , and set var9 to var8 if var8 > var9 . set var8 to var6 . for each position var11 in var0 in decreasing $$CONSTANT$$ substract var0 [ var11 ] from var8 if var3 [ var11 ] is true , add var0 [ var11 ] to var8 otherwise , and set var9 to var8 if var8 > var9 . return var9 . 
you are given $$CONSTANT$$ string var2 . you have to store in var4 the number of characters " $$CONSTANT$$ " in var2 minus the number or characters " $$CONSTANT$$ " in var2 . you have to store in var5 the number of characters " $$CONSTANT$$ " in var2 minus the number of characters " $$CONSTANT$$ " in var2 . you have to return the sum of the absolute values of var5 and var4 divided by 2 ( rounded down ) . 
you are given $$CONSTANT$$ string var2 . you have to store in var4 the number of characters " $$CONSTANT$$ " in var2 minus the number or characters " $$CONSTANT$$ " in var2 . you have to store in var5 the number of characters " $$CONSTANT$$ " in var2 minus the number of characters " $$CONSTANT$$ " in var2 . 
given $$CONSTANT$$ string var1 . initialize var3 to the difference between the number of characters ' r ' and the number of characters ' $$CONSTANT$$ ' in the given string . initialize var2 to the difference between the number of characters ' u ' and the number of characters ' d ' in the given string . 
given $$CONSTANT$$ string var1 . initialize var3 to the difference between the number of characters ' r ' and the number of characters ' $$CONSTANT$$ ' in the given string . initialize var2 to the difference between the number of characters ' u ' and the number of characters ' d ' in the given string . if the value of ( var3 + var2 ) is even , return ( var3 + even ) / 2 . othewise , return - 1 . 
given array var1 with length var2 and $$CONSTANT$$ parameter var3 . calculate the number of elements in var1 that is positive and $$CONSTANT$$ smaller than var1 [ var3 - 1 ] . store the result in var4 . 
given var6 , var3 , and var4 . set var5 [ var6 ] = var1 [ var7 ] , then increase var7 by 1 . if var5 [ var6 ] is positive , and if var6 < var3 or var5 [ var6 ] = var5 [ var3 - 1 ] , increase var4 by 1 . 
given array var1 with length var2 and $$CONSTANT$$ parameter var3 . return the number of elements in var1 that is positive and $$CONSTANT$$ smaller than var1 [ var3 - 1 ] . 
you are given $$CONSTANT$$ number var0 . you have to set var1 to 1 and string var2 to " " . you have to iterate var3 between 1 and var0 - 1 . inside the loop , you have to set var1 to ( var1 + var3 ) modulo var0 . if var1 is equal to zero you have to set var1 to var0 . you have to insert the decimal representation of var1 with $$CONSTANT$$ space at the end in var2 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var3 and $$CONSTANT$$ string var2 . you have to set var1 to ( var1 + var3 ) modulo var0 . if var1 is equal to zero you have to set var1 to var0 . you have to insert the decimal representation of var1 with $$CONSTANT$$ space at the end in var2 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and $$CONSTANT$$ number var3 . you have to set var1 to ( var1 + var3 ) modulo var0 . if var1 is equal to zero you have to set var1 to var0 . 
given integers var1 , var2 and var3 , perform the binary search to find the $$CONSTANT$$ var4 such that the sum of minimum of ( var4 - 1 ) / var8 ( rounded down ) and var2 over all integers var8 from 1 to var1 ( both inclusive ) is smaller than var3 . 
given integers var5 , var4 , var1 , var2 and var3 , initialize var6 to ( var5 + var4 ) / 2 ( rounded down ) minus 1 . find the sum of the smaller of var6 / var8 ( rounded down ) and var2 over all integers var8 from 1 to var1 ( both inclusive ) and store the result in var7 . increase var6 by 1 . set var4 to var6 + 1 if var7 < var3 , set var5 to var6 otherwise . 
you are given $$CONSTANT$$ number var0 . you have to set var1 to 1 and string var2 to " " . you have to iterate var3 between 1 and var0 - 1 . inside the loop , you have to set var1 to ( var1 + var3 ) modulo var0 . if var1 is equal to zero you have to set var1 to var0 . you have to insert the decimal representation of var1 with $$CONSTANT$$ space at the end in var2 . after the loop ends , you have to return var2 without spaces at the end . 
given integers var5 , var4 , var1 and var2 , initialize var6 to ( var5 + var4 ) / 2 ( rounded down ) minus 1 . find the sum of the smaller of var6 / var8 ( rounded down ) and var2 over all integers var8 from 1 to var1 ( both inclusive ) and store the result in var7 . increase var6 by 1 . 
given integers var5 , var4 , var1 and var2 , initialize var6 to ( var5 + var4 ) / 2 ( rounded down ) minus 1 . find the sum of the smaller of var6 / var8 ( rounded down ) and var2 over all integers var8 from 1 to var1 ( both inclusive ) and store the result in var7 . 
given an array of strings var0 . initialize var1 to the length of var0 , var2 to 0 , var3 to some big value . for each var4 from 0 to var1 exclusive and for each var5 from var4 + 1 , to var1 exclusive , perform the following operations . initialize var6 to 0 . for each var7 from 0 to 5 , if var0 [ var4 ] [ var7 ] not equals var0 [ var5 ] [ var7 ] , increase var6 by 1 . set var3 to the minimum between var3 and var6 . 
given an array of strings var0 and integers var4 , var3 , var1 . for each var5 from var4 + 1 , to var1 exclusive , perform the following operations . initialize var6 to 0 . for each var7 from 0 to 5 , if var0 [ var4 ] [ var7 ] not equals var0 [ var5 ] [ var7 ] , increase var6 by 1 . set var3 to the minimum between var3 and var6 . 
given an array of strings var0 and integers var4 , var5 , var3 . initialize var6 to 0 . for each var7 from 0 to 5 , if var0 [ var4 ] [ var7 ] not equals var0 [ var5 ] [ var7 ] , increase var6 by 1 . set var3 to the minimum between var3 and var6 . 
given an array of strings var0 and integers var4 , var5 . initialize var6 to 0 . for each var7 from 0 to 5 , if var0 [ var4 ] [ var7 ] not equals var0 [ var5 ] [ var7 ] , increase var6 by 1 . 
given an array of strings var1 , initialize var2 to length of var1 and var4 to array of integers of length var2 + 1 . for each position var5 in var1 set var4 [ var5 + 1 ] to 1 if length of var1 [ var5 ] is greater than 4 , set var4 [ var5 + 1 ] to 2 otherwise . initialize var6 to 1 . for each position var7 from var2 - 1 down to 1 ( both inclusive ) set var6 to 2 * var6 + 1 if var4 [ var7 ] = 1 , multiply var6 by 2 otherwise . initialize var8 to 0 . for as long as var6 > 0 , increase var8 by product of var0 and var6 / 2 ( rounded down ) , add var0 / 2 ( rounded down ) to var8 if var6 is odd , set var6 to var6 / 2 ( rounded down ) . 
given an array of strings var1 , initialize var2 to length of var1 and var4 to array of integers of length var2 + 1 . for each position var5 in var1 set var4 [ var5 + 1 ] to 1 if length of var1 [ var5 ] is greater than 4 , set var4 [ var5 + 1 ] to 2 otherwise . initialize var6 to 1 . for each position var7 from var2 - 1 down to 1 ( both inclusive ) set var6 to 2 * var6 + 1 if var4 [ var7 ] = 1 , multiply var6 by 2 otherwise . 
given an array of strings var1 , initialize var2 to length of var1 and var4 to array of integers of length var2 + 1 . for each position var5 in var1 set var4 [ var5 + 1 ] to 1 if length of var1 [ var5 ] is greater than 4 , set var4 [ var5 + 1 ] to 2 otherwise . initialize var6 to 1 . for each position var7 from var2 - 1 down to 1 ( both inclusive ) set var6 to 2 * var6 + 1 if var4 [ var7 ] = 1 , multiply var6 by 2 otherwise . 
given an array of strings var1 , initialize var2 to length of var1 and var4 to array of integers of length var2 + 1 . for each position var5 in var1 set var4 [ var5 + 1 ] to 1 if length of var1 [ var5 ] is greater than 4 , set var4 [ var5 + 1 ] to 2 otherwise . 
given integers var8 , var6 and var0 , increase var8 by product of var0 and var6 / 2 ( rounded down ) , add var0 / 2 ( rounded down ) to var8 if var6 is odd , set var6 to var6 / 2 ( rounded down ) . 
given integers var8 , var6 and var0 , increase var8 by product of var0 and var6 / 2 ( rounded down ) , add var0 / 2 ( rounded down ) to var8 if var6 is odd . 
given an array of strings var1 , an array of integers var4 and an integer var5 , set var4 [ var5 ] to 1 if length of var1 [ var5 ] is greater than 4 , set var4 [ var5 ] to 2 otherwise . 
given arrays of integers var1 and var2 and an integer var0 , initialize var11 to empty array of strings , var3 to length of var1 , var4 , var5 , var6 and var7 to 0 . for each position var10 in var2 add var2 [ var10 ] to var4 , add var2 [ var3 - 1 - var10 ] to var5 , add the greater of 0 and var1 [ var10 ] - var0 * var4 to var6 and add the greater of 0 and var1 [ var3 - 1 - var10 ] - var0 * var5 to var7 . 
given an array of strings var1 , initialize var2 to length of var1 and var4 to array of integers of length var2 + 1 . for each position var5 in var1 set var4 [ var5 + 1 ] to 1 if length of var1 [ var5 ] is greater than 4 , set var4 [ var5 + 1 ] to 2 otherwise . initialize var6 to 1 . for each position var7 from var2 - 1 down to 1 ( both inclusive ) set var6 to 2 * var6 + 1 if var4 [ var7 ] = 1 , multiply var6 by 2 otherwise . initialize var8 to 0 . for as long as var6 > 0 , increase var8 by product of var0 and var6 / 2 ( rounded down ) , add var0 / 2 ( rounded down ) to var8 if var6 is odd , set var6 to var6 / 2 ( rounded down ) . return var8 . 
given an array of strings var0 , initialize var3 to 2 . for each pair of positions in var0 ( var4 ; var5 ) such that var4 ! = var5 count the number of positions , where var0 [ var4 ] and var0 [ var5 ] differ , and store the result in var8 , set var8 to ( var8 - 1 ) / 2 ( rounded down ) and set var3 to the minimum of var3 and var8 . set var3 to 6 if var1 = 1 . 
given an array of strings var0 , initialize var3 to 2 . for each pair of positions in var0 ( var4 ; var5 ) such that var4 ! = var5 count the number of positions , where var0 [ var4 ] and var0 [ var5 ] differ , and store the result in var8 , set var8 to ( var8 - 1 ) / 2 ( rounded down ) and set var3 to the minimum of var3 and var8 . 
given an array of strings var0 and integer var3 and var4 , for each position var5 in var0 , except for var4 , count the number of positions , where var0 [ var4 ] and var0 [ var5 ] differ , and store the result in var8 , set var8 to ( var8 - 1 ) / 2 ( rounded down ) and set var3 to the minimum of var3 and var8 . 
given an array of strings var0 and integers var3 , var4 and var5 , count the number of positions , where var0 [ var4 ] and var0 [ var5 ] differ , and store the result in var8 , set var8 to ( var8 - 1 ) / 2 ( rounded down ) and set var3 to the minimum of var3 and var8 . 
given an array of strings var0 and integers var4 and var5 , count the number of positions , where var0 [ var4 ] and var0 [ var5 ] differ , and store the result in var8 . 
given an array of integers var1 and an integer var0 , count the number of elements of array var1 , which are less than var0 . set var5 to the difference between var0 and the result . increase var5 by 1 , if var0 is present in array var1 . 
given an array of integers var1 and integers var0 and var5 . if var1 [ var6 ] < var0 , decrease var5 by 1 , otherwise if var1 [ var6 ] = var0 , increase var5 by 1 . 
given an array of strings var0 . assign var7 to empty string , assign var2 to an empty map with pairs ( string , integer ) . for each string var4 in var0 : ( assign var4 to var0 [ var6 ] . increment var6 . if map var2 has key var4 , increment value of that key and push pair key , value as concatenated string to var7 , else push " OK " to var7 and add pair ( var4 , 0 ) to var2 ) 
given an array of strings var0 . assign var7 to empty string , assign var2 to an empty map with pairs ( string , integer ) . for each string var4 in var0 : ( assign var4 to var0 [ var6 ] . increment var6 . if map var2 has key var4 , increment value of that key and push pair key , value as concatenated string to var7 , else push " OK " to var7 and add pair ( var4 , 0 ) to var2 ) . return var7 as answer . 
given string var1 and integer var0 . set boolean var4 to true if either 1 , 2 or 3 is present in var1 and either 7 or 9 is present in var1 and either 1 , 4 or 7 is present in var1 and either 3 , 6 or 9 is present in var1 . set boolean var4 to true if both 1 and 2 are present in var1 or both 0 and 1 are present in var1 or both 0 and 3 are present in var1 . 
given string var1 and integer var0 . return " YES " if either 1 , 2 or 3 is present in var1 and either 7 or 9 is present in var1 and either 1 , 4 or 7 is present in var1 and either 3 , 6 or 9 is present in var1 . return " YES " if both 1 and 2 are present in var1 or both 0 and 1 are present in var1 or both 0 and 3 are present in var1 . return " NO " , otherwise . 
given string var1 and integer var0 . set boolean var4 to true if either 1 , 2 or 3 is present in var1 and either 7 or 9 is present in var1 and either 1 , 4 or 7 is present in var1 and either 3 , 6 or 9 is present in var1 . 
given string var1 and integer var0 . create boolean array var2 of size 10 and set var2 [ var3 ] to true for all the integers that are present in var1 . 
given integers var1 , var2 and var3 , perform the binary search to find the $$CONSTANT$$ var4 such that the sum of minimum of ( var4 - 1 ) / var8 ( rounded down ) and var2 over all integers var8 from 1 to var1 ( both inclusive ) is smaller than var3 and return the result . 
given an array of integers var0 , initialize var1 to length of var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ , find the sum of all elements of var2 and store the result in var3 . set var5 to var3 / var1 ( rounded down ) , var6 to var3 % var1 , var7 to 0 , var8 to 0 . for each position var9 in var2 add 1 to var8 , add var5 - var2 [ var9 ] to var7 if var8 < = var1 - var6 and var2 [ var9 ] - var5 < 0 , add var5 + 1 - var2 [ var9 ] to var7 if var8 > var1 - var6 and var2 [ var9 ] - var5 - 1 < 0 . return var7 . 
given $$CONSTANT$$ string var1 , initialize var2 to var1 , var3 to var2 [ 0 ] ( 0 - based ) and var4 to 1 . for each position var5 starting from 1 ( 0 - based ) increase var4 by 1 if var2 [ var5 ] = var3 , set var4 to 1 and var3 to var2 [ var5 ] otherwise ; break from the enclosing loop if var4 > = 7 . 
given $$CONSTANT$$ string var2 , $$CONSTANT$$ character var3 and integers var5 and var4 , increase var4 by 1 if var2 [ var5 ] = var3 , set var4 to 1 and var3 to var2 [ var5 ] otherwise ( all indices are 0 - based ) . break from the enclosing loop if var4 > = 7 . 
given $$CONSTANT$$ string var2 , $$CONSTANT$$ character var3 and integers var5 and var4 , increase var4 by 1 if var2 [ var5 ] = var3 , set var4 to 1 and var3 to var2 [ var5 ] otherwise ( all indices are 0 - based ) . 
given an array of string var1 which uses 0 - based indexing . given also integer var0 . initialize var4 to zero . initialize var3 to empty integer array . check every element of array var10 , if var5 th element is equal to string " halfplus " set var3 [ var5 ] to 1 and increase var4 by var0 divided by 2 rounded down . otherwise set var3 [ var5 ] to zero . initialize var7 to 1 . start iterating from one before the last element of var3 to the beginning , with index var8 . multiply var7 by 2 and add var3 [ var8 ] to it . 
given an array of string var1 which uses 0 - based indexing . given also integer var0 . initialize var4 to zero . initialize var3 to empty integer array . check every element of array var10 , if var5 th element is equal to string " halfplus " set var3 [ var5 ] to 1 and increase var4 by var0 divided by 2 rounded down . otherwise set var3 [ var5 ] to zero . 
given an array of string var1 , an array of integer var3 . both arrays use 0 - based indexing . given also string var6 , integers var0 and var4 , an index var5 into array var3 , and an index var10 into array var1 . initialize var6 to var1 [ var10 ] , increament var10 . if var6 is equal to string " halfplus " , set var3 [ var5 ] to 1 and increase var4 by var0 divided by 2 rounded down . otherwise set var3 [ var5 ] to zero . 
given an array of string var1 which uses 0 - based indexing . given also integer var0 . initialize var4 to zero . initialize var3 to empty integer array . check every element of array var10 , if var5 th element is equal to string " halfplus " set var3 [ var5 ] to 1 and increase var4 by var0 divided by 2 rounded down . otherwise set var3 [ var5 ] to zero . initialize var7 to 1 . start iterating from one before the last element of var3 to the beginning , with index var8 , and multiply var7 by 2 after add var3 [ var8 ] to it . after iteration , return ( var7 * 2 ) - var4 . 
given $$CONSTANT$$ string var1 , initialize var2 to var1 , var3 to var2 [ 0 ] ( 0 - based ) and var4 to 1 . for each position var5 starting from 1 ( 0 - based ) increase var4 by 1 if var2 [ var5 ] = var3 , set var4 to 1 and var3 to var2 [ var5 ] otherwise ; break from the enclosing loop if var4 > = 7 . return " YES " if var4 > = 7 , return " NO " otherwise . 
given char array var0 . assign var0 to var1 . create char array var2 of size $$CONSTANT$$ . assign 0 to var3 . for each var5 from 0 to last position of var1 do following operations . assign var1 [ var5 ] to var4 . if var3 does not exceed 1 , var4 does not equal var2 [ ( var3 - 1 ) ] , var2 [ ( var3 - 2 ) ] does not equal var4 , var2 [ ( var3 - 3 ) ] does not equal var2 [ ( var3 - 2 ) ] , var2 [ ( var3 - 1 ) ] does not equal var4 then assign var4 to var2 [ var3 ] , increment var3 . when the loop is ended , assign var2 to var6 . 
given char array var0 . assign var0 to var1 . create char array var2 of size $$CONSTANT$$ . assign 0 to var3 . for each var5 from 0 to last position of var1 do following operations . assign var1 [ var5 ] to var4 . if var3 does not exceed 1 , var4 does not equal var2 [ ( var3 - 1 ) ] , var2 [ ( var3 - 2 ) ] does not equal var4 , var2 [ ( var3 - 3 ) ] does not equal var2 [ ( var3 - 2 ) ] , var2 [ ( var3 - 1 ) ] does not equal var4 then assign var4 to var2 [ var3 ] , increment var3 . 
given char array var0 . assign var1 [ var5 ] to var4 . if var3 does not exceed 1 , var4 does not equal var2 [ ( var3 - 1 ) ] , var2 [ ( var3 - 2 ) ] does not equal var4 , var2 [ ( var3 - 3 ) ] does not equal var2 [ ( var3 - 2 ) ] , var2 [ ( var3 - 1 ) ] does not equal var4 then assign var4 to var2 [ var3 ] , increment var3 . 
given char array var0 . assign var1 [ var5 ] to var4 . if var3 does not exceed 1 , var4 does not equal var2 [ ( var3 - 1 ) ] , var2 [ ( var3 - 2 ) ] does not equal var4 , var2 [ ( var3 - 3 ) ] does not equal var2 [ ( var3 - 2 ) ] , var2 [ ( var3 - 1 ) ] does not equal var4 then do following operations . 
given char array var0 . assign var1 [ var5 ] to var4 . if var3 does not exceed 1 , var4 does not equal var2 [ ( var3 - 1 ) ] , var2 [ ( var3 - 2 ) ] does not equal var4 then do following operations . 
given integers var0 , var1 , var2 , var3 and var4 , initialize var7 to empty array of strings . initialize var5 to var1 * var0 + 2 * var3 and var6 to var2 * var0 + 2 * var4 . append " $$CONSTANT$$ " to the end of var7 if var5 < var6 . append " $$CONSTANT$$ " to the end of var7 if var5 = var6 . append " $$CONSTANT$$ " to the end of var7 if var5 > var6 . return var7 . 
given integers var0 , var1 , var2 , var3 and var4 , initialize var7 to empty array of strings . initialize var5 to var1 * var0 + 2 * var3 and var6 to var2 * var0 + 2 * var4 . append " $$CONSTANT$$ " to the end of var7 if var5 < var6 . append " $$CONSTANT$$ " to the end of var7 if var5 = var6 . append " $$CONSTANT$$ " to the end of var7 if var5 > var6 . 
given integers var0 , var1 , var2 , var3 and var4 , initialize var7 to empty array of strings . initialize var5 to var1 * var0 + 2 * var3 and var6 to var2 * var0 + 2 * var4 . append " $$CONSTANT$$ " to the end of var7 if var5 < var6 . append " $$CONSTANT$$ " to the end of var7 if var5 = var6 . 
given an array of strings var0 , initialize var3 to 2 . for each pair of positions in var0 ( var4 ; var5 ) such that var4 ! = var5 count the number of positions , where var0 [ var4 ] and var0 [ var5 ] differ , and store the result in var8 , set var8 to ( var8 - 1 ) / 2 ( rounded down ) and set var3 to the minimum of var3 and var8 . set var3 to 6 if var1 = 1 and return var3 . 
given integers var0 , var1 , var2 , var3 and var4 , initialize var7 to empty array of strings . initialize var5 to var1 * var0 + 2 * var3 and var6 to var2 * var0 + 2 * var4 . append " $$CONSTANT$$ " to the end of var7 if var5 < var6 . 
given integers var0 and var1 , initialize var2 to $$CONSTANT$$ 2 - dimensional array of reals of dimensions var0 * var0 and set var2 [ 0 ] [ 0 ] to var1 . iterate over all integers var4 from 0 to var0 - 1 ( both inclusive ) and for each integer var5 between 0 and var4 ( both inclusive ) initialize var6 to var2 [ var4 ] [ var5 ] ; if var6 > 0 , then set var2 [ var4 ] [ var5 ] to 1 and add var6 / 2 to var2 [ var4 + 1 ] [ var5 ] and var2 [ var4 + 1 ] [ var5 + 1 ] if var4 + 1 < var0 . count the number of elements of var2 , which are greater than or equal to 1 , and store the result in var3 . 
given $$CONSTANT$$ 2 - dimensional array of reals var2 and integers var0 , var3 and var4 , for each integer var5 between 0 and var4 ( both inclusive ) initialize var6 to var2 [ var4 ] [ var5 ] ; if var6 > 0 , then set var2 [ var4 ] [ var5 ] to 1 and add var6 / 2 to var2 [ var4 + 1 ] [ var5 ] and var2 [ var4 + 1 ] [ var5 + 1 ] if var4 + 1 < var0 ; increase var3 by 1 if var2 [ var4 ] [ var5 ] > = 1 . 
given $$CONSTANT$$ 2 - dimensional array of reals var2 and integers var0 , var3 , var4 and var5 , initialize var6 to var2 [ var4 ] [ var5 ] . if var6 > 0 , then set var2 [ var4 ] [ var5 ] to 1 and add var6 / 2 to var2 [ var4 + 1 ] [ var5 ] and var2 [ var4 + 1 ] [ var5 + 1 ] if var4 + 1 < var0 . increase var3 by 1 if var2 [ var4 ] [ var5 ] > = 1 . 
given $$CONSTANT$$ 2 - dimensional array of reals var2 and integers var0 , var4 and var5 , initialize var6 to var2 [ var4 ] [ var5 ] . if var6 > 0 , then set var2 [ var4 ] [ var5 ] to 1 and add var6 / 2 to var2 [ var4 + 1 ] [ var5 ] and var2 [ var4 + 1 ] [ var5 + 1 ] if var4 + 1 < var0 . 
given $$CONSTANT$$ 2 - dimensional array of reals var2 , integers var0 , var4 and var5 and $$CONSTANT$$ real var6 , set var2 [ var4 ] [ var5 ] to 1 and if var4 + 1 < var0 , then add var6 / 2 to var2 [ var4 + 1 ] [ var5 ] and var2 [ var4 + 1 ] [ var5 + 1 ] . 
you are given arrays var0 , var1 of integer types . create an array var5 of size var2 where the value in position var6 equals to the sum of elements in var0 with positions less than or equal to var6 . store the elements of var5 in the sorted set , var7 . assign 0 to var9 , var10 . initialize var1 [ 0 ] to var11 . iterating over var7 where var12 is current element . assign var11 - var12 to var13 . increment var10 . for all var14 $$CONSTANT$$ from 1 to var14 < var3 , if var7 does not contain the value var1 [ var14 ] - var13 then decrement var10 and exit from the current loop . 
you are given arrays var0 , var1 . create an array var5 of size var2 where the value in position var6 equals to the sum of elements in var0 with positions less than or equal to var6 . store the elements of var5 in the sorted set , var7 . assign 0 to var9 , var10 . initialize var1 [ 0 ] to var11 . 
you are given arrays var0 , var1 . create an array var5 of size var2 where the value in position var6 equals to the sum of elements in var0 with positions less than or equal to var6 . store the elements of var5 in the sorted set , var7 . 
you are given arrays var0 , var1 of integer types . create an array var5 of size var2 where the value in position var6 equals to the sum of elements in var0 with positions less than or equal to var6 . store the elements of var5 in the sorted set , var7 . assign 0 to var9 , var10 . initialize var1 [ 0 ] to var11 . iterating over var7 where var12 is current element . assign var11 - var12 to var13 . increment var10 . for all var14 $$CONSTANT$$ from 1 to var14 < var3 , if var7 does not contain the value var1 [ var14 ] - var13 then decrement var10 and exit from the current loop . when both loops are ended , return var10 . 
you are given arrays var0 , var1 of integer types . assign var11 - var12 to var13 . increment var10 . for all var14 $$CONSTANT$$ from 1 to var14 < var3 , if var7 does not contain the value var1 [ var14 ] - var13 then decrement var10 and exit from the current loop . 
you are given arrays var0 , var1 . create an array var5 of size var2 where the value in position var6 equals to the sum of elements in var0 with positions less than or equal to var6 . 
given integers var0 and var1 , initialize var2 to $$CONSTANT$$ 2 - dimensional array of reals of dimensions var0 * var0 and set var2 [ 0 ] [ 0 ] to var1 . iterate over all integers var4 from 0 to var0 - 1 ( both inclusive ) and for each integer var5 between 0 and var4 ( both inclusive ) initialize var6 to var2 [ var4 ] [ var5 ] ; if var6 > 0 , then set var2 [ var4 ] [ var5 ] to 1 and add var6 / 2 to var2 [ var4 + 1 ] [ var5 ] and var2 [ var4 + 1 ] [ var5 + 1 ] if var4 + 1 < var0 . count the number of elements of var2 , which are greater than or equal to 1 , and return the result . 
given char array var2 . create char typed matrix var4 . assign to var3 the elements of var2 separated by spaces . assign to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . solution . n the integer representation of var3 with first element being removed . if $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . solution . n is even value then return values " white " and " 1 2 " in separated lines . otherwise , return " black " . 
given char array var2 . create char typed matrix var4 . assign to var3 the elements of var2 separated by spaces . assign to $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . solution . n the integer representation of var3 with first element being removed . if $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . solution . n is even value then assign the values " white " and " 1 2 " to first and second arrays of var4 , respectively . otherwise , assign " black " to var4 . 
given 0 - basec char typed array var0 and matrix var1 . assign true to var3 if the array var0 appears in var1 . assign true to var6 if there is such array in var1 at row var8 that var1 [ var8 ] [ 0 ] equals var0 [ 1 ] . assign true to var7 if there is such array in var1 at row var8 that var1 [ var8 ] [ 1 ] equals var0 [ 0 ] . 
given 0 - basec char typed array var0 and matrix var1 . if var1 [ var8 ] equals var0 then assign true to var3 . assign first and second values in var1 [ var8 ] to var4 [ var8 ] and to var5 [ var8 ] , respectively . if var4 [ var8 ] equals var0 [ 1 ] then assign true to var6 . if var5 [ var8 ] equals var0 [ 0 ] then assign true to var7 . 
given 0 - basec char typed array var0 and matrix var1 . if var1 [ var8 ] equals var0 then assign true to var3 . assign first and second values in var1 [ var8 ] to var4 [ var8 ] and to var5 [ var8 ] , respectively . if var4 [ var8 ] equals var0 [ 1 ] then assign true to var6 . 
you are given $$CONSTANT$$ number var0 . you have to set var2 to 2 . if var0 - 2 is divisible by 3 you have to set var1 to 1 , otherwise you have to set var1 to zero . for each var3 between 1 and var0 - 1 , if var2 is less than var0 you have to , add var3 * 3 + 2 to var2 , if var0 - var2 is greater than or equal to zero and var0 - var2 is divisible by 3 add 1 to var1 ; otherwise you have to break from the enclosing loop . 
you are given $$CONSTANT$$ number var2 , an index var3 , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 . you have to add var3 * 3 + 2 to var2 . if var0 - var2 is greater than or equal to zero and var0 - var2 is divisible by 3 you have to add 1 to var1 . 
you are given $$CONSTANT$$ number var0 . you have to set var2 to 2 . if var0 - 2 is divisible by 3 you have to set var1 to 1 , otherwise you have to set var1 to zero . 
you are given $$CONSTANT$$ number var0 . you have to set var2 to 2 . if var0 - 2 is divisible by 3 you have to set var1 to 1 , otherwise you have to set var1 to zero . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to array of integers of length var1 . set var3 [ 0 ] to var0 [ 0 ] and for each position var4 in var3 , starting from 1 , set var3 [ var4 ] to the greater of var0 [ var4 ] and var3 [ var4 - 1 ] . initialize var5 to array of integers of length var1 + 1 and set var5 [ var1 ] to $$CONSTANT$$ . for each position var6 in var0 in descending $$CONSTANT$$ set var5 [ var6 ] to the smaller of var0 [ var6 ] and var5 [ var6 + 1 ] . count the number of positions var8 between 0 and var1 - 1 ( both inclusive ) such that var5 [ var8 + 1 ] > = var3 [ var8 ] and store the result in var7 . 
given 0 - basec char typed array var0 and matrix var1 . if var1 [ var8 ] equals var0 then assign true to var3 . assign first and second values in var1 [ var8 ] to var4 [ var8 ] and to var5 [ var8 ] , respectively . 
given 0 - based array var0 of integer type . create an array var4 of size $$CONSTANT$$ and of integer type . for all var3 $$CONSTANT$$ from 0 to var3 < var1 do following operations . if var4 [ var0 [ var3 ] ] exceeds 0 then decrease it by 1 . otherwise , increase var2 by 1 . increase var4 [ $$CONSTANT$$ + 1 ] by 1 . 
given 0 - based array var0 of integer type . if var4 [ var6 ] exceeds 0 then decrease it by 1 . otherwise , increase var2 by 1 . increase var4 [ $$CONSTANT$$ $$CONSTANT$$ 1 + 1 ] by 1 . 
given 0 - based array var0 of integer type . if var4 [ var6 ] exceeds 0 then decrease it by 1 . otherwise , increase var2 by 1 . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to array of integers of length var1 . set var3 [ 0 ] to var0 [ 0 ] and for each position var4 in var3 , starting from 1 , set var3 [ var4 ] to the greater of var0 [ var4 ] and var3 [ var4 - 1 ] . initialize var5 to array of integers of length var1 + 1 and set var5 [ var1 ] to $$CONSTANT$$ . for each position var6 in var0 in descending $$CONSTANT$$ set var5 [ var6 ] to the smaller of var0 [ var6 ] and var5 [ var6 + 1 ] . count the number of positions var8 between 0 and var1 - 1 ( both inclusive ) such that var5 [ var8 + 1 ] > = var3 [ var8 ] and return the result . 
given integer var0 and integer arrays var1 , var2 . assign false to var3 . assign the length of var1 to var4 . assign 0 to var5 . for all var6 $$CONSTANT$$ from 0 to n - 1 do following operations . if var1 [ var6 ] does not exceed var5 and is less than var2 [ var6 ] then assign var2 [ var6 ] to var5 . if var0 does not exceed var5 then assign true to var3 and exit from the loop . 
given integer var0 and integer arrays var1 , var2 . if var1 [ var6 ] does not exceed var5 and is less than var2 [ var6 ] then assign var2 [ var6 ] to var5 . if var0 does not exceed var5 then assign true to var3 and exit from the loop . 
given integer var0 and integer arrays var1 , var2 . assign false to var3 . assign the length of var1 to var4 . assign 0 to var5 . 
given integer var0 and integer arrays var1 , var2 . assign false to var3 . assign the length of var1 to var4 . assign 0 to var5 . 
given array var0 of char type . let var2 be the number of characters in var0 which equal to one of values 97 , $$CONSTANT$$ , 105 , 111 , 117 , $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ , 57 . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to array of integers of length var1 . set var3 [ 0 ] to var0 [ 0 ] and for each position var4 in var3 , starting from 1 , set var3 [ var4 ] to the greater of var0 [ var4 ] and var3 [ var4 - 1 ] . initialize var5 to array of integers of length var1 + 1 and set var5 [ var1 ] to $$CONSTANT$$ . for each position var6 in var0 in descending $$CONSTANT$$ set var5 [ var6 ] to the smaller of var0 [ var6 ] and var5 [ var6 + 1 ] . 
given integer var0 and integer arrays var1 , var2 . assign false to var3 . assign the length of var1 to var4 . assign 0 to var5 . for all var6 $$CONSTANT$$ from 0 to n - 1 do following operations . if var1 [ var6 ] does not exceed var5 and is less than var2 [ var6 ] then assign var2 [ var6 ] to var5 . if var0 does not exceed var5 then assign true to var3 and exit from the loop . when the loop is ended , if var3 is true then return " YES " . otherwise , return " NO " . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to array of integers of length var1 . set var3 [ 0 ] to var0 [ 0 ] and for each position var4 in var3 , starting from 1 , set var3 [ var4 ] to the greater of var0 [ var4 ] and var3 [ var4 - 1 ] . initialize var5 to array of integers of length var1 + 1 and set var5 [ var1 ] to $$CONSTANT$$ . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to array of integers of length var1 . set var3 [ 0 ] to var0 [ 0 ] and for each position var4 in var3 , starting from 1 , set var3 [ var4 ] to the greater of var0 [ var4 ] and var3 [ var4 - 1 ] . 
given an integer var0 , initialize var1 to var0 , initialize var3 to 0 , initialize var2 to array , which is containing 2 and 3 . for each var4 from 4 to var1 ( both inclusive ) , count the number of elements of array var2 such that var4 is divisible by the element and store the result in var5 , append var4 to the end of var2 , if var5 = 0 , and increase var3 by 1 , if var5 = 2 . 
given integers var4 and var3 and an array var2 , count the number of elements of array var2 such that var4 is divisible by the element . store the result in var5 . append var4 to the end of var2 , if var5 = 0 . increase var3 by 1 , if var5 = 2 . 
given an integer var4 and an array var2 , count the number of elements of array var2 such that var4 is divisible by the element . store the result in var5 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var2 to zero and var3 to zero . for each position var4 in var0 if var0 [ var4 ] is equal to 1 you have to , add 1 to var3 , if var2 is equal to 1 and var3 is greater than 1 add 1 to var3 , set var2 to zero ; otherwise add 1 to var2 . 
you are given $$CONSTANT$$ number var3 , $$CONSTANT$$ number var2 . you have to add 1 to var3 . if var2 is equal to 1 and var3 is greater than 1 you have to add 1 to var3 . you have to set var2 to zero . 
you are given $$CONSTANT$$ number var3 , $$CONSTANT$$ number var2 . you have to add 1 to var3 . if var2 is equal to 1 and var3 is greater than 1 you have to add 1 to var3 . 
given 0 - based array var0 of integer type . create an array var4 of size $$CONSTANT$$ and of integer type . for all var3 $$CONSTANT$$ from 0 to var3 < var1 do following operations . if var4 [ var0 [ var3 ] ] exceeds 0 then decrease it by 1 . otherwise , increase var2 by 1 . increase var4 [ $$CONSTANT$$ + 1 ] by 1 . when the loop is ended , return var2 . 
you are given an array var0 of integer type . initialize var5 with initial value 1 . iterating over var2 , by starting from first character , while current element is not 0 , increment var5 by the difference of current and previous characters , if this difference is less than 3 . otherwise , increment var5 by 1 . when current character is 0 , return var5 . 
given integers var0 , var1 . create integer array var3 of size $$CONSTANT$$ at var4 th position containing the value ( var4 * ( var4 - 1 ) ) / 2 . create char array var5 . assign 0 to var6 . for each var4 from $$CONSTANT$$ downto 3 , if var2 is not les sthan var3 [ var4 ] then add to the end of var5 the char representation of 97 + idx var4 number of times , add 1 to var6 , substract var3 [ var4 ] from var2 . when var4 becomes less than 3 , for each var4 from 0 to n - 1 , add to the end of var5 the char representation of 97 + idx 2 times , and add 1 to var6 . 
given integers var0 , var1 . create integer array var3 of size $$CONSTANT$$ at var4 th position containing the value ( var4 * ( var4 - 1 ) ) / 2 . create char array var5 . assign 0 to var6 . for each var4 from $$CONSTANT$$ downto 3 , if var2 is not les sthan var3 [ var4 ] then add to the end of var5 the char representation of 97 + idx var4 number of times , add 1 to var6 , substract var3 [ var4 ] from var2 . 
given array var0 of char type . return the number of characters in var0 which equal to one of values 97 , $$CONSTANT$$ , 105 , 111 , 117 , $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ , 57 . 
given integers var0 , var1 . create integer array var3 of size $$CONSTANT$$ at var4 th position containing the value ( var4 * ( var4 - 1 ) ) / 2 . create char array var5 . assign 0 to var6 . for each var4 from $$CONSTANT$$ downto 3 , if var2 is not les sthan var3 [ var4 ] then add to the end of var5 the char representation of 97 + idx var4 number of times , add 1 to var6 , substract var3 [ var4 ] from var2 . 
given integers var0 , var1 . add to the end of var5 the char representation of 97 + idx var4 number of times . add 1 to var6 . substract var3 [ var4 ] from var2 . 
given integers var0 , var1 . create integer array var3 of size $$CONSTANT$$ at var4 th position containing the value ( var4 * ( var4 - 1 ) ) / 2 . 
you are given $$CONSTANT$$ number var0 . you have to set var2 to 2 . if var0 - 2 is divisible by 3 you have to set var1 to 1 , otherwise you have to set var1 to zero . for each var3 between 1 and var0 - 1 , if var2 is less than var0 you have to , add var3 * 3 + 2 to var2 , if var0 - var2 is greater than or equal to zero and var0 - var2 is divisible by 3 add 1 to var1 ; otherwise you have to break from the enclosing loop . you have to return var1 . 
given integers var1 and var2 , initialize var5 to 2 - dimensional array of reals of dimensions var1 + 1 by var1 + 1 and set var5 [ 0 ] [ 0 ] to var2 . initialize var6 to 0 . iterate over all integers var7 from 0 to var1 - 1 ( both inclusive ) and for each integer var8 from 0 to var7 ( both inclusive ) set var9 to var5 [ var7 ] [ var8 ] , if var9 > = 1 , then add 1 to var6 , substract 1 from var9 , add var9 / 2 to var5 [ var7 + 1 ] [ var8 ] and add var9 / 2 to var5 [ var7 + 1 ] [ var8 + 1 ] . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var2 to zero and var3 to zero . for each position var4 in var0 if var0 [ var4 ] is equal to 1 you have to , add 1 to var3 , if var2 is equal to 1 and var3 is greater than 1 add 1 to var3 , set var2 to zero ; otherwise add 1 to var2 . you have to return var3 . 
given $$CONSTANT$$ 2 - dimensional array of reals var5 and integers var7 and var6 , for each integer var8 from 0 to var7 ( both inclusive ) set var9 to var5 [ var7 ] [ var8 ] , if var9 > = 1 , then add 1 to var6 , substract 1 from var9 , add var9 / 2 to var5 [ var7 + 1 ] [ var8 ] and add var9 / 2 to var5 [ var7 + 1 ] [ var8 + 1 ] . 
given $$CONSTANT$$ 2 - dimensional array of reals var5 and integers var7 , var8 and var6 , set var9 to var5 [ var7 ] [ var8 ] . if var9 > = 1 , then add 1 to var6 , substract 1 from var9 , add var9 / 2 to var5 [ var7 + 1 ] [ var8 ] and add var9 / 2 to var5 [ var7 + 1 ] [ var8 + 1 ] . 
given an array of integers var0 , initialize var1 to length of var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ , find the sum of all elements of var2 and store the result in var3 . set var5 to var3 / var1 ( rounded down ) , var6 to var3 % var1 , var7 to 0 , var8 to 0 . for each position var9 in var2 add 1 to var8 , add var5 - var2 [ var9 ] to var7 if var8 < = var1 - var6 and var2 [ var9 ] - var5 < 0 , add var5 + 1 - var2 [ var9 ] to var7 if var8 > var1 - var6 and var2 [ var9 ] - var5 - 1 < 0 . 
given an array of integers var2 and integers var1 , var5 , var6 , var7 , var8 and var9 , add 1 to var8 , add var5 - var2 [ var9 ] to var7 if var8 < = var1 - var6 and var2 [ var9 ] - var5 < 0 , add var5 + 1 - var2 [ var9 ] to var7 if var8 > var1 - var6 and var2 [ var9 ] - var5 - 1 < 0 . 
given an array of integers var0 , initialize var1 to length of var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 and sort var2 in non - decreasing $$CONSTANT$$ , find the sum of all elements of var2 and store the result in var3 . set var5 to var3 / var1 ( rounded down ) and var6 to var3 % var1 . 
given an array of integers var0 , $$CONSTANT$$ var0 into $$CONSTANT$$ new array var2 , find the sum of all elements of var2 and store the result in var3 . 
you are given an array var0 of integer type . let var1 be the length of var0 . create an array var2 of size n + 2 and of integer type . initialize var3 equal to the number of ' 1 ' $$CONSTANT$$ in var0 . store the positions of such characters in var2 . if first character in var2 is 0 then return 0 . initialize var5 with initial value 1 . iterating over var2 , by starting from first character , while current element is not 0 , increment var5 by the difference of current and previous characters , if this difference is less than 3 . otherwise , increment var5 by 1 . when current character is 0 , return var5 . 
given integers var1 and var2 , initialize var5 to 2 - dimensional array of reals of dimensions var1 + 1 by var1 + 1 and set var5 [ 0 ] [ 0 ] to var2 . initialize var6 to 0 . iterate over all integers var7 from 0 to var1 - 1 ( both inclusive ) and for each integer var8 from 0 to var7 ( both inclusive ) set var9 to var5 [ var7 ] [ var8 ] , if var9 > = 1 , then add 1 to var6 , substract 1 from var9 , add var9 / 2 to var5 [ var7 + 1 ] [ var8 ] and add var9 / 2 to var5 [ var7 + 1 ] [ var8 + 1 ] . return var6 . 
you are given array of strings var1 and integer var0 . initialize var2 to empty map with string and int as key and value . initialize var6 to zero . while var6 < var0 do : assign var3 to var1 [ var6 ] , increment var6 , if var2 has not var3 as key , assign var2 [ var3 ] to zero and push " OK " and " \ t " to var5 , else assign var4 to var2 [ var3 ] , increment var4 , assign var2 [ var3 ] to var4 and push var3 and var4 as string to var5 . 
you are given array of strings var1 , map var2 with string and int as key and value and string var5 . assign var3 to var1 [ var6 ] . if var2 has not var3 as key , assign var2 [ var3 ] to zero and push " OK " and " \ t " to var5 , else assign var4 to var2 [ var3 ] , increment var4 , assign var2 [ var3 ] to var4 and push var3 and var4 as string to var5 . 
you are given array of strings var1 and integer var0 . initialize var2 to empty map with string and int as key and value . initialize var6 to zero . while var6 < var0 do : assign var3 to var1 [ var6 ] , increment var6 , if var2 has not var3 as key , assign var2 [ var3 ] to zero and push " OK " and " \ t " to var5 , else assign var4 to var2 [ var3 ] , increment var4 , assign var2 [ var3 ] to var4 and push var3 and var4 as string to var5 . return var5 as answer . 
given integer var1 , char matrix var2 . create char matrix var6 . create map var3 of key type of char typed array and value type of integer . for each var7 from 0 to $$CONSTANT$$ - 1 , do following operations . assign var2 [ var7 ] to var4 . if var3 does not contain the key var4 then insert the pair of var4 and 1 into var3 and add to the end of var6 the value " OK " , or in other case , add to the end of var6 the value standing with key var4 in var3 and add 1 to this value in var3 . 
given an array of integers var0 and $$CONSTANT$$ string var1 , initialize var3 to array of $$CONSTANT$$ of length equal to length of var0 . for each position var5 in var1 set var3 [ var5 ] to whether var1 [ var5 ] is equal to " B " . find the sum of var0 [ var7 ] at all positions var7 such that var3 [ var7 ] is true and store the result in var6 . initialize var8 and var9 to var6 . for each position var10 in var0 substract var0 [ var10 ] from var8 if var3 [ var10 ] is true , add var0 [ var10 ] to var8 otherwise , set var9 to var8 if var8 > var9 . 
given integer var1 , char matrix var2 . create char matrix var6 . create map var3 of key type of char typed array and value type of integer . for each var7 from 0 to $$CONSTANT$$ - 1 , do following operations . assign var2 [ var7 ] to var4 . if var3 does not contain the key var4 then insert the pair of var4 and 1 into var3 and add to the end of var6 the value " OK " , or in other case , add to the end of var6 the value standing with key var4 in var3 and add 1 to this value in var3 . when the loop is ended , return var6 . 
given an integer var0 , initialize var1 to var0 , initialize var3 to 0 , initialize var2 to array , which is containing 2 and 3 . for each var4 from 4 to var1 ( both inclusive ) , count the number of elements of array var2 such that var4 is divisible by the element and store the result in var5 , append var4 to the end of var2 , if var5 = 0 , and increase var3 by 1 , if var5 = 2 . return var3 . 
given an array of integers var0 and $$CONSTANT$$ string var1 , initialize var3 to array of $$CONSTANT$$ of length equal to length of var0 . for each position var5 in var1 set var3 [ var5 ] to whether var1 [ var5 ] is equal to " B " . find the sum of var0 [ var7 ] at all positions var7 such that var3 [ var7 ] is true and store the result in var6 . initialize var8 and var9 to var6 . 
given an array of integers var0 and $$CONSTANT$$ string var1 , initialize var3 to array of $$CONSTANT$$ of length equal to length of var0 . for each position var5 in var1 set var3 [ var5 ] to whether var1 [ var5 ] is equal to " B " . find the sum of var0 [ var7 ] at all positions var7 such that var3 [ var7 ] is true and store the result in var6 . initialize var8 and var9 to var6 . 
given an array of integers var0 and $$CONSTANT$$ string var1 , initialize var3 to array of $$CONSTANT$$ of length equal to length of var0 . for each position var5 in var1 set var3 [ var5 ] to whether var1 [ var5 ] is equal to " B " . find the sum of var0 [ var7 ] at all positions var7 such that var3 [ var7 ] is true and store the result in var6 . 
given an array of integers var0 and $$CONSTANT$$ string var1 , initialize var3 to array of $$CONSTANT$$ of length equal to length of var0 . for each position var5 in var1 set var3 [ var5 ] to whether var1 [ var5 ] is equal to " B " . 
given an array of integers var0 , an array of $$CONSTANT$$ var3 and integers var10 , var8 and var9 , substract var0 [ var10 ] from var8 if var3 [ var10 ] is true , add var0 [ var10 ] to var8 otherwise , set var9 to var8 if var8 > var9 . 
given an array of integers var0 , an array of $$CONSTANT$$ var3 and integers var11 , var8 and var9 , substract var0 [ var11 ] from var8 if var3 [ var11 ] is true , add var0 [ var11 ] to var8 otherwise , set var9 to var8 if var8 > var9 . 
given an array of strings var1 and an integer var0 , initialize var2 to length of var1 , var6 to 1 and var7 to var0 / 2 ( rounded down ) . for each position var8 from var2 - 2 down to 0 ( both inclusive ) set var6 to 2 * var6 if var1 [ var8 ] = " half " , set var6 to 2 * var6 + 1 otherwise , add var6 * var0 / 2 ( rounded down ) to var7 . 
given an array of strings var1 and an integer var0 , initialize var2 to length of var1 and var3 to array of $$CONSTANT$$ of length var2 . for each position var4 in var1 set var3 [ var4 ] to whether var1 [ var4 ] = " half " . initialize var6 to 1 and var7 to var0 / 2 ( rounded down ) . 
given an array of strings var1 , initialize var2 to length of var1 and var3 to array of $$CONSTANT$$ of length var2 . for each position var4 in var1 set var3 [ var4 ] to whether var1 [ var4 ] = " half " . 
given an array of $$CONSTANT$$ var3 and integers var8 , var6 , var7 and var0 , set var6 to 2 * var6 if var3 [ var8 ] = true , set var6 to 2 * var6 + 1 otherwise , add var6 * var0 / 2 ( rounded down ) to var7 . 
given integer var1 , char matrix var2 . assign var2 [ var7 ] to var4 . if var3 does not contain the key var4 then insert the pair of var4 and 1 into var3 and add to the end of var6 the value " OK " , or in other case , add to the end of var6 the value standing with key var4 in var3 and add 1 to this value in var3 . 
given $$CONSTANT$$ string array var0 . initialize var6 to an empty array . for each string var4 in var0 , perform the following operations . initialize var4 to var0 [ var5 ] . if var2 contains var4 as $$CONSTANT$$ key , put the concatenation of var4 and var2 [ var4 ] + 1 into var6 and increase var2 [ var4 ] by 1 ; else put " OK " into var6 and set var2 [ var4 ] to 0 . 
given string arrays var0 , var6 , an integer var5 , $$CONSTANT$$ map var2 . initialize var4 to var0 [ var5 ] . if var2 contains var4 as $$CONSTANT$$ key , put the concatenation of var4 and var2 [ var4 ] + 1 into var6 and increase var2 [ var4 ] by 1 ; else put " OK " into var6 and set var2 [ var4 ] to 0 . 
given an array of strings var1 and an integer var0 , initialize var2 to length of var1 , var6 to 1 and var7 to var0 / 2 ( rounded down ) . for each position var8 from var2 - 2 down to 0 ( both inclusive ) set var6 to 2 * var6 if var1 [ var8 ] = " half " , set var6 to 2 * var6 + 1 otherwise , add var6 * var0 / 2 ( rounded down ) to var7 . return var7 . 
given $$CONSTANT$$ string array var0 . initialize var6 to an empty array . for each string var4 in var0 , perform the following operations . initialize var4 to var0 [ var5 ] . if var2 contains var4 as $$CONSTANT$$ key , put the concatenation of var4 and var2 [ var4 ] + 1 into var6 and increase var2 [ var4 ] by 1 ; else put " OK " into var6 and set var2 [ var4 ] to 0 . return var6 . 
given an array of strings var0 , initialize var6 to empty array of strings , var1 to empty string to integer map . for each position var3 in var0 append " OK " to the end of var6 and set the value of var1 at var0 [ var3 ] to 1 if var1 has not key var0 [ var3 ] , append $$CONSTANT$$ string , obtained by concatenation of var0 [ var3 ] and the value of var1 at var0 [ var3 ] , which is converted to string , to the end of var6 and add 1 to the value of var1 at var0 [ var3 ] otherwise . 
given arrays of strings var0 and var6 , $$CONSTANT$$ string to integer map var1 and an integer var3 , append " OK " to the end of var6 and set the value of var1 at var0 [ var3 ] to 1 if var1 has not key var0 [ var3 ] , append $$CONSTANT$$ string , obtained by concatenation of var0 [ var3 ] and the value of var1 at var0 [ var3 ] , which is converted to string , to the end of var6 and add 1 to the value of var1 at var0 [ var3 ] otherwise . 
given an array of strings var0 , initialize var6 to empty array of strings , var1 to empty string to integer map . for each position var3 in var0 append " OK " to the end of var6 and set the value of var1 at var0 [ var3 ] to 1 if var1 has not key var0 [ var3 ] , append $$CONSTANT$$ string , obtained by concatenation of var0 [ var3 ] and the value of var1 at var0 [ var3 ] , which is converted to string , to the end of var6 and add 1 to the value of var1 at var0 [ var3 ] otherwise . return var6 . 
given char matrix var0 . create char array var1 . create map var3 of key type of char typed array and value type of integer , for each var4 from 0 to last position of var0 do following operations . assign var0 [ var4 ] to var5 . if var3 contains the key nam then assign var3 [ var5 ] to var6 , add values var5 , var6 , 10 to the end of var1 , increment var6 , assign var6 to map [ var5 ] . otherwise , assign 1 to var3 [ var5 ] , add values " OK " , 10 to the end of var1 . 
given char matrix var0 . assign var0 [ var4 ] to var5 . if var3 contains the key nam then assign var3 [ var5 ] to var6 , add values var5 , var6 , 10 to the end of var1 , increment var6 , assign var6 to map [ var5 ] . otherwise , assign 1 to var3 [ var5 ] , add values " OK " , 10 to the end of var1 . 
given an array of strings var1 , an array of $$CONSTANT$$ var3 and an integer var4 , set var3 [ var4 ] to whether var1 [ var4 ] = " half " . 
given char matrix var0 . create char array var1 . create map var3 of key type of char typed array and value type of integer , for each var4 from 0 to last position of var0 do following operations . assign var0 [ var4 ] to var5 . if var3 contains the key nam then assign var3 [ var5 ] to var6 , add values var5 , var6 , 10 to the end of var1 , increment var6 , assign var6 to map [ var5 ] . otherwise , assign 1 to var3 [ var5 ] , add values " OK " , 10 to the end of var1 . when the loop is ended , return var1 . 
given an integer var0 and arrays of integers var1 and var2 of the same size . initialize var6 and var9 to zero . starting from beginning iterate var1 and var2 . while iterating , add contemporary element of var1 minus var0 times sum of all iterated elements including current element of var2 to var6 . again iterate arrays but from last element to first element and add current element of var1 minus var0 times sum of all iterated elements including current element of var2 to var9 . 
given an integer var0 and arrays of integers var1 and var2 of the same size . initialize var6 to zero . starting from beginning iterate var1 and var2 . while iterating , add contemporary element of var1 minus var0 times sum of all iterated elements including current element of var2 to var6 . 
you are given an integer var0 and arrays var1 , var2 of integer types . assign 0 to var6 , var7 , var8 . for all var9 $$CONSTANT$$ from 0 to var9 < var3 increment var8 by var2 [ var9 ] and increment var6 by the larger of 0 and the value var1 [ var9 ] - ( var0 * var8 ) . when var9 becomes equal to var3 , exit from the loop . assign 0 to var8 . for all var10 $$CONSTANT$$ from var3 - 1 to var10 > = 0 increment var8 by var2 [ var10 ] and increment var7 by the larger of 0 and the value var1 [ var10 ] - ( var0 * var8 ) . 
you are given an integer var0 and arrays var1 , var2 of integer types . assign 0 to var6 , var7 , var8 . for all var9 $$CONSTANT$$ from 0 to var9 < var3 increment var8 by var2 [ var9 ] and increment var6 by the larger of 0 and the value var1 [ var9 ] - ( var0 * var8 ) . 
given an integer var0 and arrays of integers var1 and var2 of the same size . initialize var6 and var9 to zero . starting from beginning iterate var1 and var2 . while iterating , add contemporary element of var1 minus var0 times sum of all iterated elements including current element of var2 to var6 . again iterate arrays but from last element to first element and add current element of var1 minus var0 times sum of all iterated elements including current element of var2 to var9 . after finishing , determine if var6 is strictly bigger than var9 , if it is the case return string " Limak " as $$CONSTANT$$ result . otherwise , if var9 is strictly bigger than var6 then return " Radewoosh " . if both have same amount , return " $$CONSTANT$$ " as $$CONSTANT$$ result . 
you are given an integer var0 and arrays var1 , var2 of integer types . assign 0 to var6 , var7 , var8 . for all var9 $$CONSTANT$$ from 0 to var9 < var3 increment var8 by var2 [ var9 ] and increment var6 by the larger of 0 and the value var1 [ var9 ] - ( var0 * var8 ) . when var9 becomes equal to var3 , exit from the loop . assign 0 to var8 . for all var10 $$CONSTANT$$ from var3 - 1 to var10 > = 0 increment var8 by var2 [ var10 ] and increment var7 by the larger of 0 and the value var1 [ var10 ] - ( var0 * var8 ) . when var10 becomes less than 0 , exit from the loop . if var6 is larger than var7 then return " Limak " . otherwise , if var6 is less than var7 then return " Radewoosh " . otherwise , return " $$CONSTANT$$ " . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 . you have to performing binary search to store in var3 the least number between 1 and var0 * var1 in such $$CONSTANT$$ way that the sum of the minimum between var1 and var3 divided by var7 ( rounded down ) , for each var7 between 1 and var0 , is greater than or equal to var2 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var1 to the length of var0 . you have to create an array of numbers var2 of length var1 initializated with zeros . for each var3 between 1 and var1 - 1 , set var2 [ var3 ] to ( var3 bitwise xor var2 [ var3 - 1 ] ) . store in var4 the bitwise xor of all elements in var0 . for each var6 between 1 and var1 , set var4 to ( ( var4 bitwise xor var2 [ var1 modulo var6 ] ) bitwise xor ( var2 [ var6 - 1 ] * ( var1 divided by var6 ( rounded down ) modulo 2 ) ) ) . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var1 to the length of var0 . you have to create an array of numbers var2 of length var1 initializated with zeros . for each var3 between 1 and var1 - 1 , set var2 [ var3 ] to ( var3 bitwise xor var2 [ var3 - 1 ] ) . store in var4 the bitwise xor of all elements in var0 . for each var6 between 1 and var1 , set var4 to ( ( var4 bitwise xor var2 [ var1 modulo var6 ] ) bitwise xor ( var2 [ var6 - 1 ] * ( var1 divided by var6 ( rounded down ) modulo 2 ) ) ) . return var4 . 
given integer var0 arrays var1 , var2 of integer types . assign 0 to var4 . for each var5 from 0 to last position of var1 , if var1 [ var5 ] does not exceed var4 then add to var4 the number of values from var1 [ var5 ] to var2 [ var5 ] , inclusive , which exceed the current value of var4 . 
given integer var0 arrays var1 , var2 of integer types . if var1 [ var5 ] does not exceed var4 then add to var4 the number of values from var1 [ var5 ] to var2 [ var5 ] , inclusive , which exceed the current value of var4 . 
given integer var0 arrays var1 , var2 of integer types . add to var4 the number of values from var6 to var7 , inclusive , which exceed the current value of var4 . 
given integer array var0 . assign var0 to var1 . let var5 be the sum of all values in var1 . assign to var7 the var5 divided by the length of var1 . assign to var8 the var5 modulo the length of var1 . assign 0 to var9 . iterating over var1 where var10 is current value do following operations . if var10 exceeds var7 then add the value var10 - var7 to var4 . otherwise , add the value ( var10 - var7 ) - 1 to var4 and add 1 to var9 . 
given integer array var0 . assign var0 to var1 . let var5 be the sum of all values in var1 . assign to var7 the var5 divided by the length of var1 . assign to var8 the var5 modulo the length of var1 . 
given integer array var0 . assign var0 to var1 . let var5 be the sum of all values in var1 . assign to var7 the var5 divided by the length of var1 . assign to var8 the var5 modulo the length of var1 . assign 0 to var9 . iterating over var1 where var10 is current value do following operations . if var10 exceeds var7 then add the value var10 - var7 to var4 . otherwise , add the value ( var10 - var7 ) - 1 to var4 and add 1 to var9 . when the loop is ended , return var4 . 
given integer array var0 . assign var0 to var1 . let var5 be the sum of all values in var1 . 
given integer array var0 . assign var0 to var1 . 
given 0 - based integer typed array var0 . assign to var2 the sum of elements in var0 . assign the values sum / n , sum % n to var4 and var5 , respectively . assign to var6 the sum of values var0 [ var8 ] - var4 such that var0 [ var8 ] exceeds var4 where var8 obtains values from 0 to n - 1 , and assign to var7 the number of such cases . 
given 0 - based integer typed array var0 . assign to var2 the sum of elements in var0 . assign the values sum / n , sum % n to var4 and var5 , respectively . 
given 0 - based integer typed array var0 . assign to var2 the sum of elements in var0 . 
given 0 - based integer typed array var0 . assign to var2 the sum of elements in var0 . assign the values sum / n , sum % n to var4 and var5 , respectively . assign to var6 the sum of values var0 [ var8 ] - var4 such that var0 [ var8 ] exceeds var4 where var8 obtains values from 0 to n - 1 , and assign to var7 the number of such cases . substract from var6 the minimum of var7 and var5 . return var6 . 
given integer typed array var0 . assign the sorted version of var0 to var4 . let var3 be the sum of all elements in var4 . assign 0 and n - 1 to var6 and var7 , respectively . create an integer typed array var8 of size var2 at first var2 - ( var3 % var2 ) positions containing the value all / n and at positions from n - all % n to n - 1 containing the value ( all + n - 1 ) / n . return the sum of all values var8 [ var5 ] - $$CONSTANT$$ [ var5 ] such that var8 [ var5 ] exceeds var4 [ var5 ] . 
given integer typed array var0 . assign the sorted version of var0 to var4 . let var3 be the sum of all elements in var4 . assign 0 and n - 1 to var6 and var7 , respectively . create an integer typed array var8 of size var2 at first var2 - ( var3 % var2 ) positions containing the value all / n and at positions from n - all % n to n - 1 containing the value ( all + n - 1 ) / n . let var1 be the sum of all values var8 [ var5 ] - $$CONSTANT$$ [ var5 ] such that var8 [ var5 ] exceeds var4 [ var5 ] . 
you are given an array var0 of integer type . initialize var5 with initial value 1 . iterating over var2 , by starting from first character , while current element is not 0 , increment var5 by the difference of current and previous characters , if this difference is less than 3 . otherwise , increment var5 by 1 . 
you are given an array var0 of integer type ( 0 - based ) . let var1 be the length of var0 . create an array var2 of size n + 2 and of integer type . initialize var3 equal to the number of ' 1 ' $$CONSTANT$$ in var0 . store the positions , incremented by 1 , of such characters in var2 . 
given char matrix var0 . create char matrix var6 . create map var1 of key type of char typed array and value type of integer . for each var3 from 0 to last position of var0 , assign var0 [ var3 ] to var4 , then if var1 contains the key var4 then add 1 to the value standing with key var4 and add to the end of var6 the values , var4 , var1 [ var4 ] , separated by space , or in other case , insert into var1 the pair of var4 and 0 , and add to the end of var6 the value " OK " . 
given char array var0 . assign var0 [ var3 ] to var4 . if var1 contains the key var4 then add 1 to the value standing with key var4 and add to the end of var6 the values , var4 , var1 [ var4 ] , separated by space , or in other case , insert into var1 the pair of var4 and 0 , and add to the end of var6 the value " OK " . 
given char matrix var0 . create char matrix var6 . create map var1 of key type of char typed array and value type of integer . for each var3 from 0 to last position of var0 , assign var0 [ var3 ] to var4 , then if var1 contains the key var4 then add 1 to the value standing with key var4 and add to the end of var6 the values , var4 , var1 [ var4 ] , separated by space , or in other case , insert into var1 the pair of var4 and 0 , and add to the end of var6 the value " OK " . when the loop is ended , return var6 . 
given $$CONSTANT$$ string array var0 . initialize var3 to an empty string , var5 to an empty map . for each var1 in var0 , perform the following operations . if var5 contains var1 as $$CONSTANT$$ key , put the concatenation of var1 and var5 [ var1 ] + 1 into var3 and increase var5 [ var1 ] by 1 ; else put " OK " into var3 and set var5 [ var1 ] to 0 . 
given $$CONSTANT$$ string array var0 , an integer var7 , $$CONSTANT$$ map var5 and $$CONSTANT$$ string var3 . initialize var1 to var0 [ var7 ] . if var5 contains var1 as $$CONSTANT$$ key , put the concatenation of var1 and var5 [ var1 ] + 1 into var3 and increase var5 [ var1 ] by 1 ; else put " OK " into var3 and set var5 [ var1 ] to 0 . 
given $$CONSTANT$$ string array var0 . initialize var3 to an empty string , var5 to an empty map . for each var1 in var0 , perform the following operations . if var5 contains var1 as $$CONSTANT$$ key , put the concatenation of var1 and var5 [ var1 ] + 1 into var3 and increase var5 [ var1 ] by 1 ; else put " OK " into var3 and set var5 [ var1 ] to 0 . return var3 . 
given integers var0 , var1 . add to the end of var5 the char representation of 97 + idx var4 number of times . 
given integer var0 arrays var1 , var2 of integer types . assign 0 to var4 . for each var5 from 0 to last position of var1 , if var1 [ var5 ] does not exceed var4 then add to var4 the number of values from var1 [ var5 ] to var2 [ var5 ] , inclusive , which exceed the current value of var4 . if var4 equals var0 then return " YES " . otherwise , return " NO " . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to create $$CONSTANT$$ $$CONSTANT$$ * $$CONSTANT$$ matrix of numbers var2 . you have to set var3 to zero and var2 [ 0 ] [ 0 ] to var1 . for each var4 between 0 and var0 - 1 and each var5 between 0 and var4 you have to set var6 to var4 - var5 , var7 to var5 and var8 to var2 [ var6 ] [ var7 ] , if var8 is greater than or equal to 1 you have to : add 1 to var3 , set var9 to var8 - 1 divided by 2 , add var9 to var2 [ var6 + 1 ] [ var7 ] , add var9 to var2 [ var6 ] [ var7 + 1 ] . 
you are given $$CONSTANT$$ matrix of reals var2 , $$CONSTANT$$ number var3 and an index var4 . for each var5 between 0 and var4 you have to set var6 to var4 - var5 , var7 to var5 and var8 to var2 [ var6 ] [ var7 ] , if var8 is greater than or equal to 1 you have to : add 1 to var3 , set var9 to var8 - 1 divided by 2 , add var9 to var2 [ var6 + 1 ] [ var7 ] , add var9 to var2 [ var6 ] [ var7 + 1 ] . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 . you have to performing binary search to store in var3 the least number between 1 and var0 * var1 in such $$CONSTANT$$ way that the sum of the minimum between var1 and var3 divided by var7 ( rounded down ) , for each var7 between 1 and var0 , is greater than or equal to var2 . you have to return var3 . 
you are given $$CONSTANT$$ matrix of reals var2 , $$CONSTANT$$ number var3 , an index var4 and an index var5 . you have to set var6 to var4 - var5 , var7 to var5 and var8 to var2 [ var6 ] [ var7 ] . if var8 is greater than or equal to 1 you have to : add 1 to var3 , set var9 to var8 - 1 divided by 2 , add var9 to var2 [ var6 + 1 ] [ var7 ] , add var9 to var2 [ var6 ] [ var7 + 1 ] . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to create $$CONSTANT$$ $$CONSTANT$$ * $$CONSTANT$$ matrix of numbers var2 . you have to set var3 to zero and var2 [ 0 ] [ 0 ] to var1 . for each var4 between 0 and var0 - 1 and each var5 between 0 and var4 you have to set var6 to var4 - var5 , var7 to var5 and var8 to var2 [ var6 ] [ var7 ] , if var8 is greater than or equal to 1 you have to : add 1 to var3 , set var9 to var8 - 1 divided by 2 , add var9 to var2 [ var6 + 1 ] [ var7 ] , add var9 to var2 [ var6 ] [ var7 + 1 ] . you have to return var3 . 
given an array of characters var1 and an integer var4 . set the value of var2 to the number of consecutive position from var1 starting at position var4 and whose value is equal to 48 , and add the same number to var4 . then , set the value of var3 to the number of consecutive position from var1 starting at position var4 and whose value is equal to $$CONSTANT$$ , and add the same number to var4 . then , subtract 1 from var4 . 
given an array of characters var1 and an integer var4 . set the value of var2 to the number of consecutive position from var1 starting at position var4 and whose value is equal to 48 , and add the same number to var4 . then , set the value of var3 to the number of consecutive position from var1 starting at position var4 and whose value is equal to $$CONSTANT$$ , and add the same number to var4 . 
given an array of characters var1 and an integer var4 . set the value of var3 to 0 . set the value of var2 to the number of consecutive position from var1 starting at position var4 and whose value is equal to 48 , and add the same number to var4 . 
given an integer var0 , initialize var2 to empty array of strings . append " black " to the end of var2 if var0 is odd , append " white " and " 1 2 " to the end of var2 otherwise . 
given an integer var0 , initialize var2 to empty array of strings . append " black " to the end of var2 if var0 is odd , append " white " and " 1 2 " to the end of var2 otherwise . return var2 . 
you are given integers var0 and var1 . initialize var2 and var3 to var1 . initialize var4 to 1 . while var2 < var0 : assign var5 to var2 , increase var2 by var3 - 1 , assign var3 to var5 , increment var4 . 
you are given integers var0 and var1 . initialize var2 and var3 to var1 . initialize var4 to 1 . while var2 < var0 : assign var5 to var2 , increase var2 by var3 - 1 , assign var3 to var5 , increment var4 . return var4 + 1 as answer . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to create an array of numbers var2 of length $$CONSTANT$$ . set var2 [ 1 ] to 1 and var2 [ 2 ] to 2 . for each var3 between 3 and $$CONSTANT$$ set var2 [ var3 ] to var2 [ var3 - 1 ] + var2 [ var3 - 2 ] . 
given $$CONSTANT$$ string var0 . initialize var1 to an array where var1 [ var2 ] stores the number of occurences of letter var2 in var0 . initialize var3 to 0 , var4 to the minimum between var1 [ $$CONSTANT$$ ] and var1 [ 68 ] . decrease var1 [ $$CONSTANT$$ ] , var1 [ 68 ] by var4 . add ( var1 [ $$CONSTANT$$ ] + var1 [ 68 ] ) / 2 to var3 . set var4 to ( var1 [ $$CONSTANT$$ ] + var1 [ 68 ] ) modulo 2 , var5 to the minimum between var1 [ $$CONSTANT$$ ] and var1 [ $$CONSTANT$$ ] . decrease var1 [ $$CONSTANT$$ ] , var1 [ $$CONSTANT$$ ] by var5 . add ( var1 [ $$CONSTANT$$ ] + var1 [ $$CONSTANT$$ ] ) / 2 to var3 . set var5 to ( var1 [ $$CONSTANT$$ ] + var1 [ $$CONSTANT$$ ] ) modulo 2 . if var4 equals var5 , add var4 to var3 ; else set var3 to - 1 . 
given $$CONSTANT$$ string var0 . initialize var1 to an array where var1 [ var2 ] stores the number of occurences of letter var2 in var0 . initialize var3 to 0 , var4 to the minimum between var1 [ $$CONSTANT$$ ] and var1 [ 68 ] . decrease var1 [ $$CONSTANT$$ ] , var1 [ 68 ] by var4 . add ( var1 [ $$CONSTANT$$ ] + var1 [ 68 ] ) / 2 to var3 . set var4 to ( var1 [ $$CONSTANT$$ ] + var1 [ 68 ] ) modulo 2 , var5 to the minimum between var1 [ $$CONSTANT$$ ] and var1 [ $$CONSTANT$$ ] . decrease var1 [ $$CONSTANT$$ ] , var1 [ $$CONSTANT$$ ] by var5 . add ( var1 [ $$CONSTANT$$ ] + var1 [ $$CONSTANT$$ ] ) / 2 to var3 . set var5 to ( var1 [ $$CONSTANT$$ ] + var1 [ $$CONSTANT$$ ] ) modulo 2 . 
given $$CONSTANT$$ string var0 . initialize var1 to an array where var1 [ var2 ] stores the number of occurences of letter var2 in var0 . 
given $$CONSTANT$$ string var0 . initialize var1 to an array where var1 [ var2 ] stores the number of occurences of letter var2 in var0 . initialize var3 to 0 , var4 to the minimum between var1 [ $$CONSTANT$$ ] and var1 [ 68 ] . decrease var1 [ $$CONSTANT$$ ] , var1 [ 68 ] by var4 . add ( var1 [ $$CONSTANT$$ ] + var1 [ 68 ] ) / 2 to var3 . set var4 to ( var1 [ $$CONSTANT$$ ] + var1 [ 68 ] ) modulo 2 , var5 to the minimum between var1 [ $$CONSTANT$$ ] and var1 [ $$CONSTANT$$ ] . decrease var1 [ $$CONSTANT$$ ] , var1 [ $$CONSTANT$$ ] by var5 . add ( var1 [ $$CONSTANT$$ ] + var1 [ $$CONSTANT$$ ] ) / 2 to var3 . set var5 to ( var1 [ $$CONSTANT$$ ] + var1 [ $$CONSTANT$$ ] ) modulo 2 . if var4 equals var5 , add var4 to var3 ; else set var3 to - 1 . return var3 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to create an array of numbers var2 of length $$CONSTANT$$ . set var2 [ 1 ] to 1 and var2 [ 2 ] to 2 . for each var3 between 3 and $$CONSTANT$$ set var2 [ var3 ] to var2 [ var3 - 1 ] + var2 [ var3 - 2 ] . set var4 to zero . for each var5 between 1 and $$CONSTANT$$ if var2 [ var5 ] * var1 - var2 [ var5 ] + 1 is greater than or equal to var0 set var4 to var5 and break from the enclosing loop . if var0 is equal to var1 return 0 , otherwise return var4 + 1 . 
given integer array var0 . assign var0 to var3 . let var2 be the sum of all elements from var0 . sort var3 . assign to var6 the value sum / n . if var2 is divisible by var1 then return the half of sum of all modules goal - myarray [ var4 ] . assign 0 to var7 . assign the values sum % n , n - rem , 0 to var9 , var10 and to var11 , respectively . for each element var8 in my array do following operations . add to var7 the module goal - x . add 1 to var11 . if var11 equals var10 then add 1 to var6 . return var7 / 2 . 
given integer array var0 . assign the values sum % n , n - rem , 0 to var9 , var10 and to var11 , respectively . for each element var8 in my array do following operations . add to var7 the module goal - x . add 1 to var11 . if var11 equals var10 then add 1 to var6 . 
given integer array var0 . assign var0 to var3 . let var2 be the sum of all elements from var0 . sort var3 . assign to var6 the value sum / n . if var2 is divisible by var1 then return the half of sum of all modules goal - myarray [ var4 ] . assign 0 to var7 . assign the values sum % n , n - rem , 0 to var9 , var10 and to var11 , respectively . for each element var8 in my array do following operations . add to var7 the module goal - x . add 1 to var11 . if var11 equals var10 then add 1 to var6 . return var7 / 2 . 
given integer array var0 . assign var0 to var3 . let var2 be the sum of all elements from var0 . sort var3 . assign to var6 the value sum / n . 
given integer array var0 . add to var7 the module goal - x . add 1 to var11 . if var11 equals var10 then add 1 to var6 . 
you are given an integer var0 . set the value of var3 ( 1 < = var3 < = the square root of var0 ( rounded to the nearest integer ) ) to the maximum integer such that ( the integer value of ( ( ( ( 3 * var3 ) * ( var3 + 1 ) ) / 2 ) - var3 ) < = var0 ) using binary search . 
you are given an integer var1 , an integer var2 , and an integer var3 . set the value of var4 to the integer value of ( var1 + var2 ) / 2 . set the value of var5 to the integer value of ( ( ( ( 3 * var4 ) * ( var4 + 1 ) ) / 2 ) - var4 ) . set the value of var1 to ( var4 + 1 ) and set the value of var3 to var4 if var5 is less than or equal to var0 , set the value of var2 to ( var4 - 1 ) otherwise . 
given strings var0 and var1 , count the number of occurrences of each lowercase letter in string var0 and store the results in array var2 , count the number of occurrences of each lowercase letter in string var1 and store the results in array var3 . initialize var6 to 0 , var7 to true . for each position var8 in var3 set var7 to false and break from the enclosing loop if var2 [ var8 ] = 0 and var3 [ var8 ] ! = 0 , add the minimum of var2 [ var8 ] and var3 [ var8 ] to var6 otherwise . 
given strings var0 and var1 , count the number of occurrences of each lowercase letter in string var0 and store the results in array var2 , count the number of occurrences of each lowercase letter in string var1 and store the results in array var3 . 
given arrays of integers var2 and var3 , integers var6 and var8 and $$CONSTANT$$ boolean var7 , set var7 to false and break from the enclosing loop if var2 [ var8 ] = 0 and var3 [ var8 ] ! = 0 , add the minimum of var2 [ var8 ] and var3 [ var8 ] to var6 otherwise . 
given $$CONSTANT$$ string var0 , initialize var3 to array of integers of length $$CONSTANT$$ , filled with zeroes . count the number of occurrences of each lowercase letter in string var0 and store the results in array var2 . 
given $$CONSTANT$$ string var0 , initialize var3 to array of integers of length $$CONSTANT$$ , filled with zeroes . count the number of occurrences of each lowercase letter in string var0 and store the results in array var2 . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) . set var2 to zero and var3 to zero . set var4 to true . for each position var6 less than var0 in var1 you have to , if var1 [ var6 ] is equal to 1 you have to , if var4 is equal to false and var3 is equal to zero , add 1 to var2 ; set var4 to false , add 1 to var2 ; otherwise , if var3 is equal to zero set var4 to true , otherwise to false ; set var3 to var1 [ var6 ] . 
you are given $$CONSTANT$$ boolean var4 , $$CONSTANT$$ number var3 , $$CONSTANT$$ number var2 , an array of numbers var1 , an index var6 . if var1 [ var6 ] is equal to 1 you have to , if var4 is equal to false and var3 is equal to zero , add 1 to var2 ; set var4 to false , add 1 to var2 ; otherwise , if var3 is equal to zero set var4 to true , otherwise to false . set var3 to var1 [ var6 ] . 
you are given $$CONSTANT$$ boolean var4 , $$CONSTANT$$ number var3 , $$CONSTANT$$ number var2 , an array of numbers var1 , an index var6 . if var1 [ var6 ] is equal to 1 you have to , if var4 is equal to false and var3 is equal to zero , add 1 to var2 ; set var4 to false , add 1 to var2 ; otherwise , if var3 is equal to zero set var4 to true , otherwise to false . 
you are given $$CONSTANT$$ boolean var4 , $$CONSTANT$$ number var3 , $$CONSTANT$$ number var2 . if var4 is equal to false and var3 is equal to zero , add 1 to var2 . set var4 to false and add 1 to var2 . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) . set var2 to zero and var3 to zero . set var4 to true . for each position var6 less than var0 in var1 you have to , if var1 [ var6 ] is equal to 1 you have to , if var4 is equal to false and var3 is equal to zero , add 1 to var2 ; set var4 to false , add 1 to var2 ; otherwise , if var3 is equal to zero set var4 to true , otherwise to false ; set var3 to var1 [ var6 ] . you have to return var2 . 
given strings var0 and var1 , count the number of occurrences of each lowercase letter in string var0 and store the results in array var2 , count the number of occurrences of each lowercase letter in string var1 and store the results in array var3 . initialize var6 to 0 , var7 to true . for each position var8 in var3 set var7 to false and break from the enclosing loop if var2 [ var8 ] = 0 and var3 [ var8 ] ! = 0 , add the minimum of var2 [ var8 ] and var3 [ var8 ] to var6 otherwise . return var6 if var6 ! = 0 and var7 = true , return - 1 otherwise . 
given an array of strings var0 , initialize var6 to empty array of strings and var2 to empty string to integer map . for each position var3 in var0 set the value of var2 at var0 [ var3 ] to 1 and append " OK " to the end of var6 if var2 has not key var0 [ var3 ] , append $$CONSTANT$$ string , obtained by concatenation of var0 [ var3 ] and string representation of the value of var2 at var0 [ var3 ] , and increase the value of var2 at var0 [ var3 ] by 1 otherwise . 
given arrays of strings var0 and var6 , $$CONSTANT$$ string to integer map var2 and an integer var3 , set the value of var2 at var0 [ var3 ] to 1 and append " OK " to the end of var6 if var2 has not key var0 [ var3 ] , append $$CONSTANT$$ string , obtained by concatenation of var0 [ var3 ] and string representation of the value of var2 at var0 [ var3 ] , and increase the value of var2 at var0 [ var3 ] by 1 otherwise . 
given an array of strings var0 , initialize var6 to empty array of strings and var2 to empty string to integer map . for each position var3 in var0 set the value of var2 at var0 [ var3 ] to 1 and append " OK " to the end of var6 if var2 has not key var0 [ var3 ] , append $$CONSTANT$$ string , obtained by concatenation of var0 [ var3 ] and string representation of the value of var2 at var0 [ var3 ] , and increase the value of var2 at var0 [ var3 ] by 1 otherwise . return var6 . 
you are given an array of strings var0 . you have to create an array of strings var6 initially empty . for each position var3 in var0 in $$CONSTANT$$ , if string var0 [ var3 ] does not exist at positions less than var3 you have to insert string " OK " to var6 ; otherwise you have to insert string var0 [ var3 ] plus the decimal representation of the number of times that string var0 [ var3 ] is located at positions less than var3 . you have to return var6 . 
given an integer var0 , initialize var1 to empty string , var2 to array of integers of length 2 * var0 , var3 to var0 - 1 and var4 to 0 . for as long as var3 > 0 , set var2 [ var4 ] and var2 [ var4 + var3 ] to var0 - var3 , substract 2 from var3 and increase var4 by 1 . set var4 to var0 and var3 to var0 - 2 . for as long as var3 > 0 , set var2 [ var4 ] and var2 [ var4 + var3 ] to var0 - var3 , substract 2 from var3 and increase var4 by 1 . for each position var5 in var2 set var1 to concatenation of var1 , var0 , converted to string , and " " if var2 [ var5 ] = 0 , set var1 to concatenation of var1 , var2 [ var5 ] , converted to string , and " " otherwise . 
given an integer var0 , initialize var1 to empty string , var2 to array of integers of length 2 * var0 , var3 to var0 - 1 and var4 to 0 . for as long as var3 > 0 , set var2 [ var4 ] and var2 [ var4 + var3 ] to var0 - var3 , substract 2 from var3 and increase var4 by 1 . set var4 to var0 and var3 to var0 - 2 . for as long as var3 > 0 , set var2 [ var4 ] and var2 [ var4 + var3 ] to var0 - var3 , substract 2 from var3 and increase var4 by 1 . for each position var5 in var2 set var1 to concatenation of var1 , var0 , converted to string , and " " if var2 [ var5 ] = 0 , set var1 to concatenation of var1 , var2 [ var5 ] , converted to string , and " " otherwise . return var1 . 
given an integer var0 , initialize var2 to array of integers of length 2 * var0 , var3 to var0 - 1 and var4 to 0 . for as long as var3 > 0 , set var2 [ var4 ] and var2 [ var4 + var3 ] to var0 - var3 , substract 2 from var3 and increase var4 by 1 . set var4 to var0 and var3 to var0 - 2 . for as long as var3 > 0 , set var2 [ var4 ] and var2 [ var4 + var3 ] to var0 - var3 , substract 2 from var3 and increase var4 by 1 . 
given an integer var0 , initialize var2 to array of integers of length 2 * var0 , var3 to var0 - 1 and var4 to 0 . for as long as var3 > 0 , set var2 [ var4 ] and var2 [ var4 + var3 ] to var0 - var3 , substract 2 from var3 and increase var4 by 1 . set var4 to var0 and var3 to var0 - 2 . for as long as var3 > 0 , set var2 [ var4 ] and var2 [ var4 + var3 ] to var0 - var3 , substract 2 from var3 and increase var4 by 1 . 
given $$CONSTANT$$ string var1 , count the number of positions var5 in var1 such that var1 [ var5 ] appears in " $$CONSTANT$$ " . store the result in var4 . 
given $$CONSTANT$$ string var0 . return the number of vowels and odd digits in var0 . 
you are given integers var0 , var1 , var2 . initialize 0 to resultant value . while var1 % 10 does not equal 7 and var2 % 10 does not equal 7 , do following operations . assign the value $$CONSTANT$$ - ( var0 - var2 ) to var2 . if var1 equals 0 then assign 23 to var1 . otherwise , decrement var1 . if var0 was not larger than var2 then decrement var2 by var0 . increment the result . when at least one of values var1 or var2 taken by modulo 10 becomes equal 7 , exit from the loop . 
you are given integers var0 , var1 , var2 . assign the value $$CONSTANT$$ - ( var0 - var2 ) to var2 . if var1 equals 0 then assign 23 to var1 . otherwise , decrement var1 . if var0 was not larger than var2 then decrement var2 by var0 . increment var3 . 
you are given integers var0 , var1 , var2 . assign the value $$CONSTANT$$ - ( var0 - var2 ) to var2 . if var1 equals 0 then assign 23 to var1 . otherwise , decrement var1 . 
you are given integers var0 , var1 , var2 . initialize 0 to resultant value . while var1 % 10 does not equal 7 and var2 % 10 does not equal 7 , do following operations . assign the value $$CONSTANT$$ - ( var0 - var2 ) to var2 . if var1 equals 0 then assign 23 to var1 . otherwise , decrement var1 . if var0 was not larger than var2 then decrement var2 by var0 . increment the result . when at least one of values var1 or var2 taken by modulo 10 becomes equal 7 , exit from the loop . return the result . 
given an integer var0 . create $$CONSTANT$$ matrix var6 of char type . create an array var1 of size 2 * var0 and of integer type , consisting of values var0 . add the values 1 + ( 2 * var2 ) , separated by spaces to the end of var6 where var2 obtains values from 0 to var2 < var0 / 2 . if var0 is not divisible by 2 then add var0 to the end of var6 . add the values 1 + ( 2 * var3 ) , separated by spaces to the end of var6 where var3 obtains values from ( var0 / 2 ) - 1 to var3 > - 1 . 
given an integer var0 . create $$CONSTANT$$ matrix var6 of char type . create an array var1 of size 2 * var0 and of integer type , consisting of values var0 . add the values 1 + ( 2 * var2 ) , separated by spaces to the end of var6 where var2 obtains values from 0 to var2 < var0 / 2 . if var0 is not divisible by 2 then add var0 to the end of var6 . add the values 1 + ( 2 * var3 ) , separated by spaces to the end of var6 where var3 obtains values from ( var0 / 2 ) - 1 to var3 > - 1 . add the values 2 + ( 2 * var4 ) , separated by spaces to the end of var6 where var4 obtains values from 0 to var4 < var0 / 2 . 
given an integer var0 . create $$CONSTANT$$ matrix var6 of char type . create an array var1 of size 2 * var0 and of integer type , consisting of values var0 . add the values 1 + ( 2 * var2 ) , separated by spaces to the end of var6 where var2 obtains values from 0 to var2 < var0 / 2 . if var0 is not divisible by 2 then add var0 to the end of var6 . add the values 1 + ( 2 * var3 ) , separated by spaces to the end of var6 where var3 obtains values from ( var0 / 2 ) - 1 to var3 > - 1 . 
given an integer var0 . create $$CONSTANT$$ matrix var6 of char type . create an array var1 of size 2 * var0 and of integer type , consisting of values var0 . add the values 1 + ( 2 * var2 ) , separated by spaces to the end of var6 where var2 obtains values from 0 to var2 < var0 / 2 . if var0 is not divisible by 2 then add var0 to the end of var6 . 
given $$CONSTANT$$ string var0 . return the number of vowels and odd digits in var0 . 
given an integer var0 . create $$CONSTANT$$ matrix var6 of char type . create an array var1 of size 2 * var0 and of integer type , consisting of values var0 . add the values 1 + ( 2 * var2 ) , separated by spaces to the end of var6 where var2 obtains values from 0 to var2 < var0 / 2 . if var0 is not divisible by 2 then add var0 to the end of var6 . 
given integer typed array var0 . assign the sorted version of var0 to var4 . let var3 be the sum of all elements in var4 . assign 0 and n - 1 to var6 and var7 , respectively . create an integer typed array var8 of size var2 at first var2 - ( var3 % var2 ) positions containing the value all / n and at positions from n - all % n to n - 1 containing the value ( all + n - 1 ) / n . 
given integer typed array var0 . assign the sorted version of var0 to var4 . let var3 be the sum of all elements in var4 . assign 0 and n - 1 to var6 and var7 , respectively . create an integer typed array var8 of size var2 at first var2 - ( var3 % var2 ) positions containing the value all / n and at positions from n - all % n to n - 1 containing the value ( all + n - 1 ) / n . 
given integer typed array var0 . assign the sorted version of var0 to var4 . let var3 be the sum of all elements in var4 . assign 0 and n - 1 to var6 and var7 , respectively . create an integer typed array var8 of size var2 at first var2 - ( var3 % var2 ) positions containing the value all / n . 
given $$CONSTANT$$ string var1 , count the number of positions var5 in var1 such that var1 [ var5 ] appears in " $$CONSTANT$$ " . return the result . 
given integer typed array var0 . assign the sorted version of var0 to var4 . let var3 be the sum of all elements in var4 . assign 0 and n - 1 to var6 and var7 , respectively . create an integer typed array var8 of size var2 at first var2 - ( var3 % var2 ) positions containing the value all / n . 
given integer typed array var0 . assign the sorted version of var0 to var4 . let var3 be the sum of all elements in var4 . assign 0 and n - 1 to var6 and var7 , respectively . 
given integer typed array var0 . assign the sorted version of var0 to var4 . let var3 be the sum of all elements in var4 . 
given integer typed array var0 . assign var0 to var4 . let var3 be the sum of all elements in var4 . 
given an integer var0 . create $$CONSTANT$$ matrix var6 of char type . create an array var1 of size 2 * var0 and of integer type , consisting of values var0 . add the values 1 + ( 2 * var2 ) , separated by spaces to the end of var6 where var2 obtains values from 0 to var2 < var0 / 2 . 
you are given an array var0 . initialize the sum of elements in var0 to var3 . assign the values var3 / var1 , var4 + 1 to var4 and var6 , respectively . let var7 be the sum of differences between values var4 and the element from var0 which is less than var4 and var6 be the sum of differences between two values where first value is from var0 which is larger than var6 and second value is var6 . 
you are given an array var0 . initialize the sum of elements in var0 to var3 . assign the values var3 / var1 , var4 + 1 to var4 and var6 , respectively . 
you are given an array var0 . initialize the sum of elements in var0 to var3 . 
you are given an array var0 . initialize the sum of elements in var0 to var3 . assign the values var3 / var1 , var4 + 1 to var4 and var6 , respectively . let var7 be the sum of differences between values var4 and the element from var0 which is less than var4 and var8 be the sum of differences between two values where first value is from var0 which is larger than var6 and second value is var6 . return the larger of var8 and var7 . 
you are given $$CONSTANT$$ number var0 . set var2 to zero . for each var3 between 1 and 999999 , set var4 to ( ( 3 * var3 + 1 ) * var3 ) divided by 2 ( rounded down ) , if var0 is less than var4 you have to break from the enclosing loop , if ( var0 - var4 ) is divisible by 3 you have to add 1 to var2 . you have to return var2 . 
given strings var0 , two sets var4 , var5 and an array of strings var0 . for each var7 in var1 , perform the following operations . if var7 equals to var0 , set var3 to false . otherwise , push var7 [ 0 ] into var4 and var7 [ 1 ] into var5 . if var0 [ 0 ] is presented in var5 and var0 [ 1 ] is presented in var4 , set var3 to false . 
given strings var0 , two sets var4 , var5 and an array of strings var0 . for each var7 in var1 , perform the following operations . if var7 equals to var0 , set var3 to false . otherwise , push var7 [ 0 ] into var4 and var7 [ 1 ] into var5 . if var0 [ 0 ] is presented in var5 and var0 [ 1 ] is presented in var4 , set var3 to false . 
given strings var0 , var7 and two sets var4 , var5 . if var7 equals to var0 , set var3 to false . otherwise , push var7 [ 0 ] into var4 and var7 [ 1 ] into var5 . if var0 [ 0 ] is presented in var5 and var0 [ 1 ] is presented in var4 , set var3 to false . 
given strings var0 , two sets var4 , var5 and an array of strings var0 . for each var7 in var1 , perform the following operations . if var7 equals to var0 , set var3 to false . otherwise , push var7 [ 0 ] into var4 and var7 [ 1 ] into var5 . if var0 [ 0 ] is presented in var5 and var0 [ 1 ] is presented in var4 , set var3 to false . if var3 equals to true , return " NO " . otherwise , return " YES " . 
given an array of strings var1 and an integer var0 , $$CONSTANT$$ var1 into $$CONSTANT$$ new array var3 and $$CONSTANT$$ var3 . initialize var5 and var6 to 0 . for each position var7 in var3 multiply var6 by 2 and add var0 * ( var6 / 2 . 0 ) ( rounded down ) to var5 if var3 [ var7 ] = " half " , set var6 to 2 * var6 + 1 and add var0 * ( var6 / 2 . 0 ) ( rounded down ) to var5 if var3 [ var7 ] = " halfplus " . 
given an array of strings var3 and integers var7 , var6 , var5 and var0 , multiply var6 by 2 and add var0 * ( var6 / 2 . 0 ) ( rounded down ) to var5 if var3 [ var7 ] = " half " , set var6 to 2 * var6 + 1 and add var0 * ( var6 / 2 . 0 ) ( rounded down ) to var5 if var3 [ var7 ] = " halfplus " . 
given an array of strings var1 , $$CONSTANT$$ var1 into $$CONSTANT$$ new array var3 and $$CONSTANT$$ var3 . 
given an array of strings var3 and integers var7 , var6 , var5 and var0 , multiply var6 by 2 and add var0 * ( var6 / 2 . 0 ) ( rounded down ) to var5 if var3 [ var7 ] = " half " . 
given an array of strings var1 , $$CONSTANT$$ var1 into $$CONSTANT$$ new array var3 . 
given an array of strings var1 and an integer var0 , $$CONSTANT$$ var1 into $$CONSTANT$$ new array var3 and $$CONSTANT$$ var3 . initialize var5 and var6 to 0 . for each position var7 in var3 multiply var6 by 2 and add var0 * ( var6 / 2 . 0 ) ( rounded down ) to var5 if var3 [ var7 ] = " half " , set var6 to 2 * var6 + 1 and add var0 * ( var6 / 2 . 0 ) ( rounded down ) to var5 if var3 [ var7 ] = " halfplus " . return var5 . 
given integers var0 , var1 , var2 . initialize var3 to 1 and var4 to ( var0 * var1 + 1 ) . while var3 + 1 is less than var4 , perform the following operations . initialize var5 to the integer division of var3 by var4 . initialize var6 to the number of values of var7 from 1 to var0 such that the boolean expression ( var5 is divisible by var7 and var5 / var7 is not greater than var1 ) is false . initialize var8 to the sum of min ( var5 / var9 , var1 ) over all var9 from 1 to var0 . decrease var8 by var6 . if var8 is less than var2 , set var3 to var5 ; else set var4 to var5 . 
given integers var0 , var1 , var3 , var4 , var2 . initialize var5 to the integer division of var3 by var4 . initialize var6 to the number of values of var7 from 1 to var0 such that the boolean expression ( var5 is divisible by var7 and var5 / var7 is not greater than var1 ) is false . initialize var8 to the sum of min ( var5 / var9 , var1 ) over all var9 from 1 to var0 . decrease var8 by var6 . if var8 is less than var2 , set var3 to var5 ; else set var4 to var5 . 
given integers var0 , var1 , var3 , var4 . initialize var5 to the integer division of var3 by var4 . initialize var6 to the number of values of var7 from 1 to var0 such that the boolean expression ( var5 is divisible by var7 and var5 / var7 is not greater than var1 ) is false . initialize var8 to the sum of min ( var5 / var9 , var1 ) over all var9 from 1 to var0 . decrease var8 by var6 . 
given integers var0 , var1 , var3 , var4 . initialize var5 to the integer division of var3 by var4 . initialize var6 to the number of values of var7 from 1 to var0 such that the boolean expression ( var5 is divisible by var7 and var5 / var7 is not greater than var1 ) is false . initialize var8 to the sum of min ( var5 / var9 , var1 ) over all var9 from 1 to var0 . 
given integers var0 , var1 , var3 , var4 . initialize var5 to the integer division of var3 by var4 . initialize var6 to the number of values of var7 from 1 to var0 such that the expression ( var5 is divisible by var7 and var5 / var7 is not greater than var1 ) is false . 
given integers var5 , var6 , var7 . let var1 and var2 be the minimum and maximum of var5 and var6 . assign 0 to var8 . assign ( $$CONSTANT$$ * $$CONSTANT$$ ) * $$CONSTANT$$ to var9 . as long as max - min exceeds 1 do following operations . assign to var0 the value ( var9 + var8 ) / 2 . if func0 ( med , r , var2 ) is not less than var7 then assign var0 to var9 . otherwise , assign it to var8 . 
given integers var5 , var6 , var7 . assign to var0 the value ( var9 + var8 ) / 2 . if func0 ( med , r , var2 ) is not less than var7 then assign var0 to var9 . otherwise , assign it to var8 . 
given integers var0 , var1 , var2 . return the sum of minimums of med / $$CONSTANT$$ and var2 where var4 obtains values from 1 to var1 . 
given integers var0 , var1 , var2 . let var3 be the sum of minimums of med / $$CONSTANT$$ and var2 where var4 obtains values from 1 to var1 . 
you are given $$CONSTANT$$ string arrays var0 . create $$CONSTANT$$ new string array var7 , and $$CONSTANT$$ map var1 indexed with strings which are mapped to integers . iterate over all elements in var0 . let var4 be the current element . if var4 is already in var1 , increment the value of the element corresponding to var4 and append var4 concatenated with var1 [ var4 ] to var7 , otherwise set var1 [ var4 ] to 0 and append " OK " to var7 . 
you are given $$CONSTANT$$ string arrays var0 . create $$CONSTANT$$ new string array var7 , and $$CONSTANT$$ map var1 indexed with strings which are mapped to integers . iterate over all elements in var0 . let var4 be the current element . if var4 is already in var1 , increment the value of the element corresponding to var4 and append var4 concatenated with var1 [ var4 ] to var7 , otherwise set var1 [ var4 ] to 0 and append " OK " to var7 . after all iterations , return var7 . 
given integer var0 and char typed arrays var1 , var2 . assign var1 and var2 to var3 and var4 , respectively . create integer typed arrays var5 , var6 both of sizes $$CONSTANT$$ . add 1 to elements in var5 and var6 at positions stored in var3 and var4 , respectively . if there is such position var11 that var6 [ var11 ] exceeds 0 and var5 [ var11 ] does not then return - 1 . otherwise , return the sum of minimums of var5 [ var11 ] and var6 [ var11 ] where var11 obtains values from 0 to length of var6 minus 1 and where both var6 [ var11 ] and var5 [ var11 ] exceed 0 . 
given an array var0 . initialize var1 to the length of var0 , var2 to the sum of elements of var0 , var4 to var2 modulo var1 , var5 to 0 . divide var2 by var1 . for each var6 in var0 , if var6 is greater than var2 , perform the following operations . add var6 - var2 to var5 . if var4 is greater than 0 , decrease var5 and var4 by 1 . 
given an array var0 . initialize var1 to the length of var0 , var2 to the sum of elements of var0 , var4 to var2 modulo var1 , var5 to 0 . divide var2 by var1 . 
given an array var0 . initialize var1 to the length of var0 , var2 to the sum of elements of var0 , var4 to var2 modulo var1 , var5 to 0 . divide var2 by var1 . for each var6 in var0 , if var6 is greater than var2 , perform the following operations . add var6 - var2 to var5 . if var4 is greater than 0 , decrease var5 and var4 by 1 . return var5 . 
given integers var6 , var2 , var4 , var5 . add var6 - var2 to var5 . if var4 is greater than 0 , decrease var5 and var4 by 1 . 
given an array var0 . initialize var1 to the length of var0 , var2 to the sum of elements of var0 , var4 to var2 modulo var1 . 
given an array var0 . initialize var2 to the sum of elements of var0 . 
given an array of integers var1 , an array of integers var2 , $$CONSTANT$$ boolean array var3 , $$CONSTANT$$ boolean array var5 , an integer var4 , an integer var6 , and an integer var9 . increase the value of var4 by 1 and mark the value of var3 [ var1 [ var9 ] ] as true if the value var3 [ var1 [ var9 ] ] was marked as false . set the value of var8 to var2 [ var9 ] . increase the value of var6 by 1 and mark the value of var5 [ var2 [ var9 ] ] as true if the value var5 [ var2 [ var9 ] ] was marked as false . 
given an integer var7 and the map var2 , set the string var3 to be var1 [ var7 ] . if var3 is in the map , then let var4 be the number associated with var3 in the map . concatenate var3 and var4 and call it var5 , add var5 to the array var6 , and then increment var4 by 1 and then add the pair ( var5 , var4 ) to var2 . otherwise , if var3 doesn ' t exist in the map , add the pair ( var3 , 1 ) to var2 , and then add the string " OK " to the array var6 . 
given $$CONSTANT$$ hashmap var2 and var3 initialized as var1 [ var7 ] . if var2 contains the key var3 , then , initialize var4 as var2 [ var3 ] . then , while var2 has the concatenation of var3 and var4 as $$CONSTANT$$ key , increment var4 by one . finally , push the concatenation of var3 and var4 to var6 , put key var5 and var3 into var2 with values 1 and var4 + 1 respectively . otherwise , push the string " OK " into var6 and put key var3 into var2 with value 1 . 
given $$CONSTANT$$ hashmap var2 and $$CONSTANT$$ string var3 , initialize var4 as var2 [ var3 ] . then , while var2 has the concatenation of var3 and var4 as $$CONSTANT$$ key , increment var4 by one . finally , push the concatenation of var3 and var4 to var6 , put key var5 and var3 into var2 with values 1 and var4 + 1 respectively . 
given $$CONSTANT$$ hashmap var2 and $$CONSTANT$$ string var3 , initialize var4 as var2 [ var3 ] . then , while var2 has the concatenation of var3 and var4 as $$CONSTANT$$ key , increment var4 by one . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var1 to the length of var0 . you have to create an array of numbers var2 of length var1 initializated with zeros . for each var3 between 1 and var1 - 1 , set var2 [ var3 ] to ( var3 bitwise xor var2 [ var3 - 1 ] ) . store in var4 the bitwise xor of all elements in var0 . 
given integer var0 and char typed arrays var1 , var2 . assign var1 and var2 to var3 and var4 , respectively . create integer typed arrays var5 , var6 both of sizes $$CONSTANT$$ . add 1 to elements in var5 and var6 at positions stored in var3 and var4 , respectively . if there is such position var11 that var6 [ var11 ] exceeds 0 and var5 [ var11 ] does not then return - 1 . otherwise , return the sum of minimums of var5 [ var11 ] and var6 [ var11 ] where var11 obtains values from 0 to length of var6 minus 1 and where both var6 [ var11 ] and var5 [ var11 ] exceed 0 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var1 to the length of var0 . you have to create an array of numbers var2 of length var1 initializated with zeros . for each var3 between 1 and var1 - 1 , set var2 [ var3 ] to ( var3 bitwise xor var2 [ var3 - 1 ] ) . store in var4 the bitwise xor of all elements in var0 . 
you are given an array of numbers var0 . set var1 to the length of var0 . you have to create an array of numbers var2 of length var1 . for each var3 between 1 and var1 - 1 , set var2 [ var3 ] to ( var3 biwise xor var2 [ var3 - 1 ] ) . 
you are given an array of strings var0 . you have to create an array of strings var6 initially empty . for each position var3 in var0 in $$CONSTANT$$ , if string var0 [ var3 ] does not exist at positions less than var3 you have to insert string " OK " to var6 ; otherwise you have to insert string var0 [ var3 ] plus the decimal representation of the number of times that string var0 [ var3 ] is located at positions less than var3 . 
you are given an array of strings var0 , an array of strings var6 , an index var5 , an associative container var1 . you have to set var4 to var0 [ var5 ] and add 1 to var5 . if var1 does not contain var4 as key you have to insert string " OK " in var6 , insert the key var4 with the value 1 in var1 ; otherwise you have to insert string var4 with the decimal representation of the value of key var4 in var1 in var6 , add 1 to the value of the key var4 in var1 . 
given integers var0 , var2 and char typed matrix var1 . create integer typed sorted sets var5 , cells containing such values var7 , var9 , respectively , that var1 [ var7 ] [ var9 ] equals 83 . 
given integers var0 , var2 and char typed matrix var1 . in each case , when var1 [ var7 ] [ var9 ] equals 83 , insert into var5 the value var7 and insert into var6 the value var9 . 
given an integer var0 , initialize var2 to array of integers of length 2 * var0 , var3 to var0 - 1 and var4 to 0 . for as long as var3 > 0 , set var2 [ var4 ] and var2 [ var4 + var3 ] to var0 - var3 , substract 2 from var3 and increase var4 by 1 . set var4 to var0 . 
given an integer var0 , initialize var2 to array of integers of length 2 * var0 , var3 to var0 - 1 and var4 to 0 . for as long as var3 > 0 , set var2 [ var4 ] and var2 [ var4 + var3 ] to var0 - var3 , substract 2 from var3 and increase var4 by 1 . 
given an array var0 . initialize var2 to var0 , var3 to the sum of elements of var0 . initialize var5 to var3 modulo var1 , var6 to an array of length var1 filled with ( var3 / var1 ) . for each var8 from var1 - 1 to var1 - 1 - var5 exclusive , increase var6 [ var8 ] by 1 . sort var2 in increasing $$CONSTANT$$ . initialize var9 to 0 . for each var10 from 0 to var1 exclusive , add | var2 [ var10 ] - var6 [ var10 ] | to var9 . 
given integers var0 , var1 , var2 . initialize var3 to 1 and var4 to ( var0 * var1 + 1 ) . while var3 + 1 is less than var4 , perform the following operations . initialize var5 to the integer division of var3 by var4 . initialize var6 to the number of values of var7 from 1 to var0 such that the boolean expression ( var5 is divisible by var7 and var5 / var7 is not greater than var1 ) is false . initialize var8 to the sum of min ( var5 / var9 , var1 ) over all var9 from 1 to var0 . decrease var8 by var6 . if var8 is less than var2 , set var3 to var5 ; else set var4 to var5 . return var3 . 
given an array var0 . initialize var2 to var0 , var3 to the sum of elements of var0 . initialize var5 to var3 modulo var1 , var6 to an array of length var1 filled with ( var3 / var1 ) . for each var8 from var1 - 1 to var1 - 1 - var5 exclusive , increase var6 [ var8 ] by 1 . sort var2 in increasing $$CONSTANT$$ . 
given integers var0 , var2 and char typed matrix var1 . create integer typed sorted sets var5 , cells containing such values var7 , var9 , respectively , that var1 [ var7 ] [ var9 ] equals 83 . return the value ( ( ( var4 - len ( var6 ) ) * var3 ) + ( ( var3 - len ( var5 ) ) * var4 ) ) - ( ( var3 - len ( var5 ) ) * ( var4 - len ( var6 ) ) ) . 
given an array var0 . initialize var2 to var0 , var3 to the sum of elements of var0 . initialize var5 to var3 modulo var1 , var6 to an array of length var1 filled with ( var3 / var1 ) . for each var8 from var1 - 1 to var1 - 1 - var5 exclusive , increase var6 [ var8 ] by 1 . 
you are given an array of strings var1 , $$CONSTANT$$ number var0 , an index var2 . you have to create $$CONSTANT$$ sorted set var5 and $$CONSTANT$$ sorted set var6 . for each position var7 in var1 you have to set var8 to var1 [ var2 ] and add 1 to var2 , for each var9 between 0 and var0 - 1 , if var8 [ var9 ] is equal to 83 insert var7 in var5 and insert var9 in var6 . you have to set var3 to the length of var1 , $$CONSTANT$$ to the length of var6 , $$CONSTANT$$ to the length of var5 . you have to return ( var0 - $$CONSTANT$$ ) * var3 + ( var3 - $$CONSTANT$$ ) * var0 - ( var3 - $$CONSTANT$$ ) * ( var0 - $$CONSTANT$$ ) . 
given an array var0 . initialize var2 to var0 , var3 to the sum of elements of var0 . initialize var5 to var3 modulo var1 , var6 to an array of length var1 filled with ( var3 / var1 ) . 
given an array var0 . initialize var2 to var0 , var3 to the sum of elements of var0 . initialize var5 to var3 modulo var1 , var6 to an array of length var1 filled with ( var3 / var1 ) . for each var8 from var1 - 1 to var1 - 1 - var5 exclusive , increase var6 [ var8 ] by 1 . sort var2 in increasing $$CONSTANT$$ . initialize var9 to 0 . for each var10 from 0 to var1 exclusive , add | var2 [ var10 ] - var6 [ var10 ] | to var9 . return var9 / 2 . 
given an array var0 . initialize var2 to var0 , var3 to the sum of elements of var0 . initialize var5 to var3 modulo var1 , var6 to an array of length var1 filled with ( var3 / var1 ) . 
given an array var0 . initialize var2 to var0 , var3 to the sum of elements of var0 . initialize var5 to var3 modulo var1 . 
you are given an array of strings var1 , $$CONSTANT$$ number var0 , an index var2 . you have to create $$CONSTANT$$ sorted set var5 and $$CONSTANT$$ sorted set var6 . for each position var7 in var1 you have to set var8 to var1 [ var2 ] and add 1 to var2 , for each var9 between 0 and var0 - 1 , if var8 [ var9 ] is equal to 83 insert var7 in var5 and insert var9 in var6 . 
you are given an array of strings var1 , an index var2 , $$CONSTANT$$ sorted set var5 , $$CONSTANT$$ sorted set var6 , $$CONSTANT$$ number var4 . you have to set var8 to var1 [ var2 ] and add 1 to var2 . for each var9 between 0 and var4 - 1 , if var8 [ var9 ] is equal to 83 insert var7 in var5 and insert var9 in var6 . 
given an array var0 . initialize var2 to var0 , var3 to the sum of elements of var0 . 
you are given an integer array var0 . set var1 to the size of var0 . let var2 be the sum of all elements of var0 . let var4 be var2 divided by var1 ( rounded down ) . let var5 be var2 modulo var1 . initialize var6 , var8 , var9 all to 0 . iterate from 0 to var1 - 1 with index var7 , in each iteration , if var0 [ var7 ] is less than var4 , add ( var4 - var0 [ var7 ] ) to var8 . otherwise , if var0 [ var7 ] is more than var4 + 1 , add ( var0 [ var7 ] - ( var4 + 1 ) ) to var9 . 
you are given an integer array var0 . set var1 to the size of var0 . let var2 be the sum of all elements of var0 . let var4 be var2 divided by var1 ( rounded down ) . let var5 be var2 modulo var1 . 
you are given an integer array var0 . set var1 to the size of var0 . let var2 be the sum of all elements of var0 . 
you are given an integer array var0 . set var1 to the size of var0 . let var2 be the sum of all elements of var0 . let var4 be var2 divided by var1 ( rounded down ) . let var5 be var2 modulo var1 . initialize var6 , var8 , var9 all to 0 . iterate from 0 to var1 - 1 with index var7 , in each iteration , if var0 [ var7 ] is less than var4 , add ( var4 - var0 [ var7 ] ) to var8 . otherwise , if var0 [ var7 ] is more than var4 + 1 , add ( var0 [ var7 ] - ( var4 + 1 ) ) to var9 . after all iterations , return the maximum between var8 and var9 . 
given $$CONSTANT$$ string var4 [ ] . iterate var6 from 0 to ( var5 - 1 ) . for each var6 , integers var7 , var8 , and var9 are given . shift the $$CONSTANT$$ var4 [ var7 . . . var8 ] var9 times to the $$CONSTANT$$ . 
given integer array var0 . create $$CONSTANT$$ map var2 with key and value types of integer initially consisting of key 0 and of value 1 . assign 1 to var3 . for all var4 $$CONSTANT$$ from 1 to var1 do following operations . if the map var2 does not containg the key var0 [ var4 ] then add 1 to var3 and insert into var2 the key var4 with value var3 . otherwise , insert into var2 the key var4 with the same value as with the key var0 [ var4 ] and remove the key var0 [ var4 ] from var2 . 
given 0 - based string array var1 and string var0 . initialize var3 and var4 to empty boolean arrays of size $$CONSTANT$$ . iterate over var1 with index var9 and if var1 [ var9 ] is equal to var0 return string " YES " , otherwise set both var3 [ var1 [ var9 ] [ 0 ] ] and var4 [ var1 [ var9 ] [ 1 ] ] to true . after iteration , if both var4 [ var0 [ 0 ] ] and var3 [ var0 [ 1 ] ] are true store " YES " otherwise " NO " into var10 . 
given integer array var0 . if the map var2 does not containg the key var0 [ var4 ] then add 1 to var3 and insert into var2 the key var4 with value var3 . otherwise , insert into var2 the key var4 with the same value as with the key var0 [ var4 ] and remove the key var0 [ var4 ] from var2 . 
you are given an array of strings var1 ( indexing is 0 - based ) , an array of strings var2 ( indexing is 0 - based ) . you have to create an array of numbers var8 of length $$CONSTANT$$ initializated with zeros . for each position var9 in var1 add 1 to var8 [ var1 [ var9 ] ] , subtract 1 to var8 [ var2 [ var9 ] ] . store in var4 the minimum sum of $$CONSTANT$$ preffix of var8 ending at position var10 , for each var10 between 0 and var0 - 1 . 
given integer array var0 . create $$CONSTANT$$ map var2 with key and value types of integer initially consisting of key 0 and of value 1 . assign 1 to var3 . for all var4 $$CONSTANT$$ from 1 to var1 do following operations . if the map var2 does not containg the key var0 [ var4 ] then add 1 to var3 and insert into var2 the key var4 with value var3 . otherwise , insert into var2 the key var4 with the same value as with the key var0 [ var4 ] and remove the key var0 [ var4 ] from var2 . when the loop is ended , return var3 . 
you are given an array of strings var1 ( indexing is 0 - based ) , an array of strings var2 ( indexing is 0 - based ) . you have to create an array of numbers var8 of length $$CONSTANT$$ . for each position var9 in var1 add 1 to var8 [ var1 [ var9 ] ] , subtract 1 to var8 [ var2 [ var9 ] ] . 
you are given $$CONSTANT$$ number var0 . set var2 to zero . for each var3 between 1 and 999999 , set var4 to ( ( 3 * var3 + 1 ) * var3 ) divided by 2 ( rounded down ) , if var0 is less than var4 you have to break from the enclosing loop , if ( var0 - var4 ) is divisible by 3 you have to add 1 to var2 . 
you are given $$CONSTANT$$ number var3 , $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 . set var4 to ( ( 3 * var3 + 1 ) * var3 ) divided by 2 ( rounded down ) . if var1 is less than var4 you have to break from the enclosing loop . if ( var1 - var4 ) is divisible by 3 you have to add 1 to var2 . 
given integers var0 and integer array var1 . assign 0 to var4 , bk . assign var2 to var5 . assign 0 to var7 . while var4 does not exceed var5 do following operations . initialize var8 to the value ( $$CONSTANT$$ + $$CONSTANT$$ ) / 2 . create array var9 of size var2 at var10 th position containing the value var1 [ var10 ] + ( ( var10 + 1 ) * var8 ) . sort var9 . initialize var11 to the sum of first var8 elements in var9 . if var11 does not exceed var0 then assign the values $$CONSTANT$$ + 1 , var8 , var11 to var4 , bk and to var7 , respectively . otherwise , assign $$CONSTANT$$ - 1 to var5 . when the loop is ended , return bk and var7 , separated by space . 
you are given $$CONSTANT$$ number var3 , $$CONSTANT$$ number var1 . set var4 to ( ( 3 * var3 + 1 ) * var3 ) divided by 2 ( rounded down ) . if var1 is less than var4 you have to break from the enclosing loop . 
given 0 - based array var0 of integer type . assign var0 to var2 . sort var2 . let var6 be the number of consequent sub - arrays of var0 and var2 which have equal sums of elements where each position of array corresponds to only one sub - array . 
given 0 - based array var0 of integer type . assign var0 to var2 . sort var2 . assign 0 to var4 and var5 . 
given 0 - based array var0 of integer type . increase var4 by var0 [ var3 ] and increase var5 by var2 [ var3 ] . if var4 equals var5 then increase var6 by 1 and assign 0 to var4 and var5 . 
given 0 - based array var0 of integer type . assign var0 to var2 . 
given 0 - based array var0 of integer type . assign var0 to var2 . sort var2 . return the number of consequent sub - arrays of var0 and var2 which have equal sums of elements where each position of array corresponds to only one sub - array . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . if the value var0 * var0 + var1 * var1 is $$CONSTANT$$ perfect square you have to set var4 to 1 , otherwise , you have to set var5 to the integer part of the square root of var0 * var0 + var1 * var1 , and if var5 is odd and var0 * var1 is greater than zero you have to set var4 to 0 , otherwise if var5 is even and var0 * var1 is less than or equal to zero you have to set var4 to 0 , otherwise you have to set var4 to 1 . if var4 is different to zero you have to return " black " , otherwise you have to return " white " . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . if the value var0 * var0 + var1 * var1 is $$CONSTANT$$ perfect square you have to set var4 to 1 , otherwise , you have to set var5 to the integer part of the square root of var0 * var0 + var1 * var1 , and if var5 is odd and var0 * var1 is greater than zero you have to set var4 to 0 , otherwise if var5 is even and var0 * var1 is less than or equal to zero you have to set var4 to 0 , otherwise you have to set var4 to 1 . 
you are given $$CONSTANT$$ 0 - based array var0 of integer type . assign 0 to var2 . assign the length of var0 to var3 . for all var4 $$CONSTANT$$ from 0 to var4 < length of var0 do following operations . if var0 [ var4 ] equals 1 then do following operations . if var2 is larger than 2 or var2 equals var4 then decrement var3 by var2 . otherwise , do nothing . assign 0 to var2 . if var0 [ var4 ] was not equal 1 then increment var2 . when var4 becomes equal to the length of var0 , exit from the loop . 
given strings var0 , var7 and two sets var4 , var5 . if var7 equals to var0 , set var3 to false . otherwise , push var7 [ 0 ] into var4 and var7 [ 1 ] into var5 . 
you are given an array of strings var1 ( indexing is 0 - based ) , an array of strings var2 ( indexing is 0 - based ) . you have to create an array of numbers var8 of length $$CONSTANT$$ initializated with zeros . for each position var9 in var1 add 1 to var8 [ var1 [ var9 ] ] , subtract 1 to var8 [ var2 [ var9 ] ] . store in var4 the minimum sum of $$CONSTANT$$ preffix of var8 ending at position var10 , for each var10 between 0 and var0 - 1 . if var4 is equal to zero return " NO " , otherwise return " YES " . 
given an array var0 initialize var6 with 0 , var1 with the length of var0 , var4 with 3 , var2 with 1 , var3 with 2 and var8 with 0 . then iterate through the elements of var9 and if the next element of var0 is var4 then set var6 to 1 , otherwise if the next element of var0 is var2 then swap var4 with var3 otherwise swap var4 with var2 . 
given an array var0 and integers var4 var2 and var3 if the next element of var0 is var4 then set var6 to 1 , otherwise if the next element of var0 is var2 then swap var4 with var3 otherwise swap var4 with var2 . 
given arrays of integers var1 and var2 and an integer var5 , initialize var5 to 0 and var6 to " NO " . for each position var7 in var1 if var7 = 0 and var1 [ var7 ] = 0 , then set var5 to var2 [ var7 ] , otherwise , break from the loop if var1 [ var7 ] > var5 , set var5 to the greater of var5 and var2 [ var7 ] otherwise , set var6 to " YES " and break from the loop if var5 > = var0 . 
given arrays of integers var1 and var2 , $$CONSTANT$$ string var6 and integers var7 , var0 and var5 , if var7 = 0 and var1 [ var7 ] = 0 , then set var5 to var2 [ var7 ] , otherwise , break from the enclosing loop if var1 [ var7 ] > var5 , set var5 to the greater of var5 and var2 [ var7 ] otherwise , set var6 to " YES " and break from the enclosing loop if var5 > = var0 . 
given arrays of integers var1 and var2 and integers var7 and var5 , if var7 = 0 and var1 [ var7 ] = 0 , then set var5 to var2 [ var7 ] , otherwise , break from the enclosing loop if var1 [ var7 ] > var5 , set var5 to the greater of var5 and var2 [ var7 ] otherwise . 
you are given $$CONSTANT$$ 0 - based array var0 of integer type . assign 0 to var2 . assign the length of var0 to var3 . for all var4 $$CONSTANT$$ from 0 to var4 < length of var0 do following operations . if var0 [ var4 ] equals 1 then do following operations . if var2 is larger than 2 or var2 equals var4 then decrement var3 by var2 . otherwise , do nothing . assign 0 to var2 . if var0 [ var4 ] was not equal 1 then increment var2 . when var4 becomes equal to the length of var0 , exit from the loop . return var3 - var2 . 
given arrays of integers var1 and var2 and an integer var5 , initialize var5 to 0 and var6 to " NO " . for each position var7 in var1 if var7 = 0 and var1 [ var7 ] = 0 , then set var5 to var2 [ var7 ] , otherwise , break from the loop if var1 [ var7 ] > var5 , set var5 to the greater of var5 and var2 [ var7 ] otherwise , set var6 to " YES " and break from the loop if var5 > = var0 . return var6 . 
given an array var0 initialize var6 with 0 , var1 with the length of var0 , var4 with 3 , var2 with 1 , var3 with 2 and var8 with 0 . then iterate through the elements of var9 and if the next element of var0 is var4 then set var6 to 1 , otherwise if the next element of var0 is var2 then swap var4 with var3 otherwise swap var4 with var2 . finally if the flag var6 is 1 then return " NO " otherwise return " YES " 
you are given an array of numbers var1 . you have to set var4 to the number of elements 2 in var1 . you have to set var5 to the number of elements 1 in var5 . if var4 is less than var5 you have to set var8 to var4 + ( onecount - twocount ) divided by 3 ( rounded down ) , otherwise you have to set var8 to var5 . 
you are given an array of numbers var1 , $$CONSTANT$$ number var2 . you have to set var4 to the number of elements 2 in var1 . you have to set var5 to the number of elements 1 in var5 . 
you are given an array of numbers var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var5 , $$CONSTANT$$ number var4 . you have to set var7 to var1 [ var2 ] , add 1 to var2 . if var7 is equal to 1 you have to add 1 to var5 , otherwise you have to add 1 to var4 . 
you are given an array of numbers var1 . you have to set var4 to the number of elements 2 in var1 . you have to set var5 to the number of elements 1 in var5 . if var4 is less than var5 you have to return var4 + ( onecount - twocount ) divided by 3 ( rounded down ) , otherwise you have to return var5 . 
given 0 - based array var0 of integer type . create an array var7 of integer type . assign true to var4 . for all var6 $$CONSTANT$$ from 0 to var6 < var1 do following operations . if var0 [ var6 ] is even number then if var4 is true then insert 1 into var7 and assign false to var4 . otherwise , if var4 was false then insert 2 into var7 and assign true to var4 . if var0 [ var6 ] is odd number then if var4 is true then insert 2 into var7 . otherwise , if var4 is false then insert 1 into var7 . after the loop is ended , return var7 . 
given 0 - based array var0 of integer type . create an array var7 of integer type . assign true to var4 . for all var6 $$CONSTANT$$ from 0 to var6 < var1 do following operations . if var0 [ var6 ] is even number then if var4 is true then insert 1 into var7 and assign false to var4 . otherwise , if var4 was false then insert 2 into var7 and assign true to var4 . if var0 [ var6 ] is odd number then if var4 is true then insert 2 into var7 . otherwise , if var4 is false then insert 1 into var7 . 
you are given an array of numbers var8 , $$CONSTANT$$ number var9 , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var10 , $$CONSTANT$$ number var11 . insert var9 divided by var0 ( rounded down ) to var8 , insert var10 divided by var0 ( rounded down ) to var8 , insert var11 divided by var0 ( rounded down ) to var8 . store in var12 the minnimum among all elements in var8 . you have to return var12 . 
you are given an array of numbers var8 , $$CONSTANT$$ number var9 , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var10 , $$CONSTANT$$ number var11 . insert var9 divided by var0 ( rounded down ) to var8 , insert var10 divided by var0 ( rounded down ) to var8 , insert var11 divided by var0 ( rounded down ) to var8 . store in var12 the minnimum among all elements in var8 . 
given an array of integers var0 , initialize var4 to empty array of integers and var2 to 2 . for each position var3 in var0 set var2 to 3 - var2 if var0 [ var3 ] is even and append var2 to the end of var4 . return var4 . 
given integer var0 and char typed arrays var1 , var2 . assign var1 and var2 to var3 and var4 , respectively . create integer typed arrays var5 , var6 both of sizes $$CONSTANT$$ . add 1 to elements in var5 and var6 at positions stored in var3 and var4 , respectively . 
given integer var0 and char typed arrays var1 , var2 . assign var1 and var2 to var3 and var4 , respectively . create integer typed arrays var5 , var6 both of sizes $$CONSTANT$$ . add 1 to elements in var5 at positions stored in var3 . 
given integer var0 and char typed arrays var1 , var2 . assign var1 and var2 to var3 and var4 , respectively . create integer typed arrays var5 , var6 both of sizes $$CONSTANT$$ . add 1 to elements in var5 at positions stored in var3 . 
you are given an array of strings var0 . you have to create an associative container ( string , int ) var2 . you have to create an array of strings var7 initially empty . for each position var3 in var0 , set var4 to var0 [ var3 ] , if var2 does not contains var4 as key insert string " OK " to var7 , set the value of key var4 in var2 to zero ; otherwise , set var5 to the value of key var4 in var2 plus 1 , set the value of key var4 in var2 to var5 , insert the string var4 plus the decimal representation of var5 to var7 . 
you are given an array of strings var0 , an index var6 , an associative container ( string , int ) var2 , an array of strings var7 . set var4 to var0 [ var6 ] and add 1 to var6 . if var2 does not contains var4 as key insert string " OK " to var7 , set the value of key var4 in var2 to zero ; otherwise , set var5 to the value of key var4 in var2 plus 1 , set the value of key var4 in var2 to var5 , insert the string var4 plus the decimal representation of var5 to var7 . 
given integers var0 and integer array var1 . assign 0 to var4 , bk . assign var2 to var5 . assign 0 to var7 . while var4 does not exceed var5 do following operations . initialize var8 to the value ( $$CONSTANT$$ + $$CONSTANT$$ ) / 2 . create array var9 of size var2 at var10 th position containing the value var1 [ var10 ] + ( ( var10 + 1 ) * var8 ) . sort var9 . initialize var11 to the sum of first var8 elements in var9 . if var11 does not exceed var0 then assign the values $$CONSTANT$$ + 1 , var8 , var11 to var4 , bk and to var7 , respectively . otherwise , assign $$CONSTANT$$ - 1 to var5 . 
you are given an array of strings var0 . you have to create an array of strings var7 initially empty . for each position var3 in var0 , if string var0 [ var3 ] is not found at positions less than var3 you have to insert string " OK " to var7 , otherwise you have to insert string var0 [ var3 ] plus the decimal representation of the number of times that string var0 [ var3 ] is found at positions less than var3 . you have to return var7 . 
given integers var0 and integer array var1 . initialize var8 to the value ( $$CONSTANT$$ + $$CONSTANT$$ ) / 2 . create array var9 of size var2 at var10 th position containing the value var1 [ var10 ] + ( ( var10 + 1 ) * var8 ) . sort var9 . initialize var11 to the sum of first var8 elements in var9 . if var11 does not exceed var0 then assign the values $$CONSTANT$$ + 1 , var8 , var11 to var4 , bk and to var7 , respectively . otherwise , assign $$CONSTANT$$ - 1 to var5 . 
given integers var0 and integer array var1 . initialize var8 to the value ( $$CONSTANT$$ + $$CONSTANT$$ ) / 2 . create array var9 of size var2 at var10 th position containing the value var1 [ var10 ] + ( ( var10 + 1 ) * var8 ) . sort var9 . initialize var11 to the sum of first var8 elements in var9 . 
given integers var0 and integer array var1 . initialize var8 to the value ( $$CONSTANT$$ + $$CONSTANT$$ ) / 2 . create array var9 of size var2 at var10 th position containing the value var1 [ var10 ] + ( ( var10 + 1 ) * var8 ) . sort var9 . 
given integers var0 and integer array var1 . initialize var8 to the value ( $$CONSTANT$$ + $$CONSTANT$$ ) / 2 . create array var9 of size var2 at var10 th position containing the value var1 [ var10 ] + ( ( var10 + 1 ) * var8 ) . 
given integers var0 , var1 . create integer array var3 of size $$CONSTANT$$ at var4 th position containing the value ( var4 * ( var4 - 1 ) ) / 2 . create char array var5 . assign 0 to var6 . for each var4 from $$CONSTANT$$ downto 3 , if var2 is not les sthan var3 [ var4 ] then add to the end of var5 the char representation of 97 + idx var4 number of times , add 1 to var6 , substract var3 [ var4 ] from var2 . when var4 becomes less than 3 , for each var4 from 0 to n - 1 , add to the end of var5 the char representation of 97 + idx 2 times , and add 1 to var6 . if resultant var5 is empty then return the character " $$CONSTANT$$ " . otherwise , return var5 . 
given an array of strings var0 . you have to create an associative container string - int var3 . you have to create an array of strings of the length of var0 . for each position var4 in var0 , set var5 to var0 [ var4 ] , if var3 does not contain to var5 as key set var2 [ var4 ] to " OK " , insert the key var5 with value 1 to var3 ; otherwise set var2 [ var4 ] to var5 plus the decimal representation of the value of the key var5 in var3 , add 1 to the value of key var5 in var3 . 
given an array of strings var0 . you have to create an associative container string - int var3 . you have to create an array of strings of the length of var0 . for each position var4 in var0 , set var5 to var0 [ var4 ] , if var3 does not contain to var5 as key set var2 [ var4 ] to " OK " , insert the key var5 with value 1 to var3 ; otherwise set var2 [ var4 ] to var5 plus the decimal representation of the value of the key var5 in var3 , add 1 to the value of key var5 in var3 . 
given an array of strings var0 . you have to create an associative container string - int var3 . you have to create an array of strings of the length of var0 . for each position var4 in var0 , set var5 to var0 [ var4 ] , if var3 does not contain to var5 as key set var2 [ var4 ] to " OK " , insert the key var5 with value 1 to var3 ; otherwise set var2 [ var4 ] to var5 plus the decimal representation of the value of the key var5 in var3 , add 1 to the value of key var5 in var3 . 
given an array of strings , an index var7 , an index var4 , an associative container string - int var3 , an array of strings var2 . set var5 to var0 [ var7 ] and add 1 to var7 . if var3 does not contain to var5 as key , set var2 [ var4 ] to " OK " , insert the key var5 with value 1 to var3 ; otherwise set var2 [ var4 ] to var5 plus the decimal representation of the value of the key var5 in var3 , add 1 to the value of key var5 in var3 . 
given an array of strings var0 . for each position var4 in var0 you have to store in an associative container string - int the number of times that the string var0 [ var4 ] if founded at $$CONSTANT$$ position less than var4 , if var0 [ var4 ] is not founded at position less than var4 then you have to print " OK " , otherwise you have to print var0 [ var4 ] plus the decimal representation of the value of the key var0 [ var4 ] in the associative container . 
given an array of integers var1 , initialize var2 to length of var1 , var4 to $$CONSTANT$$ , var5 and var6 to array of integers of length var2 + 1 , set var5 [ 0 ] to 1 , var6 [ 1 ] to 0 , var7 to 2 . for each integer var8 from 1 to var2 ( both inclusive ) initialize var9 to var1 [ var8 - 1 ] and var10 to var5 [ var9 ] ; set var5 [ var8 ] to var10 and var6 [ var10 ] to var8 if var6 [ var10 ] = var9 , set var5 [ var8 ] to var7 and var6 [ var7 ] to var8 and increase var7 by 1 otherwise . 
given arrays of integers var1 , var6 and var5 and integers var8 and var7 , initialize var9 to var1 [ var8 - 1 ] and var10 to var5 [ var9 ] ; set var5 [ var8 ] to var10 and var6 [ var10 ] to var8 if var6 [ var10 ] = var9 , set var5 [ var8 ] to var7 and var6 [ var7 ] to var8 and increase var7 by 1 otherwise . 
given an array of integers var1 , initialize var2 to length of var1 , var4 to $$CONSTANT$$ , var5 and var6 to array of integers of length var2 + 1 , set var5 [ 0 ] to 1 , var6 [ 1 ] to 0 . 
given an array of integers var1 , initialize var2 to length of var1 , var4 to $$CONSTANT$$ . 
given an array of integers var1 , initialize var2 to length of var1 . 
given an array of integers var1 , count the number of elements of var1 , which are equal to 1 , and store the result in var4 ; count the number of elements of var1 , which are not equal to 1 , and store the result in var5 . return the sum of the smaller of var4 and var5 and the greater of 0 and ( var4 - var5 ) / 3 ( rounded down ) . 
given $$CONSTANT$$ string var1 with length var0 . for each position var3 in var1 check if var3 mod var0 equals to zero and $$CONSTANT$$ [ ( $$CONSTANT$$ - 3 ) ] = = $$CONSTANT$$ [ ( $$CONSTANT$$ - 2 ) ] and $$CONSTANT$$ [ ( $$CONSTANT$$ - 2 ) ] = = $$CONSTANT$$ [ ( $$CONSTANT$$ - 1 ) ] . if so , add var2 by 1 
given an array of integers var1 , initialize var2 to length of var1 , var4 to $$CONSTANT$$ , var5 and var6 to array of integers of length var2 + 1 , set var5 [ 0 ] to 1 , var6 [ 1 ] to 0 , var7 to 2 . for each integer var8 from 1 to var2 ( both inclusive ) initialize var9 to var1 [ var8 - 1 ] and var10 to var5 [ var9 ] ; set var5 [ var8 ] to var10 and var6 [ var10 ] to var8 if var6 [ var10 ] = var9 , set var5 [ var8 ] to var7 and var6 [ var7 ] to var8 and increase var7 by 1 otherwise . return var7 - 1 . 
you are given $$CONSTANT$$ string var0 and $$CONSTANT$$ sorted set of strings var2 . you have to insert each character of var0 in var2 . 
given an array of integers var1 , count the number of elements of var1 , which are equal to 1 , and store the result in var4 ; count the number of elements of var1 , which are not equal to 1 , and store the result in var5 . 
given an array of integers var1 and integers var6 , var4 and var5 , if var1 [ var6 ] = 1 , add 1 to var4 , otherwise add 1 to var5 . 
given $$CONSTANT$$ string var1 , count the number of characters of var1 , which are present in string " $$CONSTANT$$ " , and store the result in var2 . 
you are given $$CONSTANT$$ string var0 and $$CONSTANT$$ number var1 . if the number of differents characters in var0 is greater than or equal to var1 you have tu return " 0 " , otherwise you have to return var1 minus the number of differents characters in var0 . 
given $$CONSTANT$$ string var1 and integers var3 and var2 , increase var2 by 1 if var1 [ var3 ] is equal to " $$CONSTANT$$ " , " e " , " $$CONSTANT$$ " , " o " or " u " , " 1 " , " 3 " , " 5 " , " 7 " or " 9 " . 
given $$CONSTANT$$ string var1 and integers var3 and var2 , increase var2 by 1 if var1 [ var3 ] is equal to " $$CONSTANT$$ " , " e " , " $$CONSTANT$$ " , " o " or " u " . 
given string var0 . set integer var1 to the number of times the var2 - th element of var0 is equal to any of 97 , $$CONSTANT$$ , 105 , 111 , 117 , $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ or 57 . 
given string var0 and integer var2 , var1 . if the var2 - th element of var0 is equal to any of 97 , $$CONSTANT$$ , 105 , 111 , 117 , $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ or 57 increase the value of var1 by 1 . 
given integers var0 , var1 , var2 , var3 , var4 . assign the values y - x * 2 - y to var7 , b - $$CONSTANT$$ * 3 - y to var8 . if both var7 and var8 are negative then assign $$CONSTANT$$ + $$CONSTANT$$ to var5 and return - var5 . if var7 is negative then return - $$CONSTANT$$ . if var8 is negative then return - $$CONSTANT$$ . return 0 . 
given integer var0 and integer typed arrays var1 , var2 . assign 0 to var4 . iterating over var1 , for each case when var1 [ var5 ] does not exceed var4 , update var4 by the larger of var4 and var2 [ var5 ] . 
given $$CONSTANT$$ string var1 , count the number of characters of var1 , which are present in string " $$CONSTANT$$ " , and return the result . 
given integer var0 and integer typed arrays var1 , var2 . if var1 [ var5 ] does not exceed var4 then set the larger of var4 and var2 [ var5 ] to var4 . 
you are given $$CONSTANT$$ 0 - based array var0 of integer type . if var0 [ var4 ] equals 1 then do following operations . if var2 is larger than 2 or var2 equals var4 then decrement var3 by var2 . otherwise , do nothing . assign 0 to var2 . if var0 [ var4 ] was not equal 1 then increment var2 . 
you are given $$CONSTANT$$ 0 - based array var0 of integer type . if var2 is larger than 2 or var2 equals var4 then decrement var3 by var2 . otherwise , do nothing . 
given string var0 . return the number of times the var2 - th element of var0 is equal to any of 97 , $$CONSTANT$$ , 105 , 111 , 117 , $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ or 57 . 
given an array var0 . initialize ret to an empty array , var2 to the sum of elements of var0 . if var2 is odd , return 0 . initialize var5 to var2 / 2 , set var2 to 0 . for each var6 from 0 to the length of var0 - 1 exclusive , perform the following operations . add var0 [ var6 ] to var2 . if var2 equals var5 , increase var3 by 1 . 
given an array var0 and integers var2 , var3 . initialize var5 to var2 / 2 , set var2 to 0 . for each var6 from 0 to the length of var0 - 1 exclusive , perform the following operations . add var0 [ var6 ] to var2 . if var2 equals var5 , increase var3 by 1 . 
given an array var0 . initialize ret to an empty array , var2 to the sum of elements of var0 . 
given an array var0 and integers var2 , var5 , var6 , var3 . add var0 [ var6 ] to var2 . if var2 equals var5 , increase var3 by 1 . 
given 6 integers var10 , var8 , var11 , var9 , var0 and var1 . set both var10 and var11 to the smaller value among them . set var8 to var10 * var0 , set var9 to var11 * var1 . return $$CONSTANT$$ string contains var8 followed by $$CONSTANT$$ space and then var9 . 
given integer var0 and integer typed arrays var1 , var2 . assign 0 to var4 . iterating over var1 , for each case when var1 [ var5 ] does not exceed var4 , update var4 by the larger of var4 and var2 [ var5 ] . eventually , if var4 is not less than var0 then return " YES " . otherwise , return " NO " . 
given 4 integers var2 , var3 , var4 and var5 . determine the greatest common divisor of var4 and var5 and strore it to var12 . initialize var0 , var1 to var4 / var12 and var5 / var12 respectively . initialize var10 , var11 to var6 / var0 and var7 / var1 respectively . if var10 and var11 are both positive , return $$CONSTANT$$ string contains var0 multiply by the smaller value between var10 and var11 , followed by $$CONSTANT$$ space and var0 multiply by the smaller value between var10 and var11 . otherwise , return the string " 0 0 " . 
given an array var0 . initialize ret to an empty array , var2 to the sum of elements of var0 . if var2 is odd , return 0 . initialize var5 to var2 / 2 , set var2 to 0 . for each var6 from 0 to the length of var0 - 1 exclusive , perform the following operations . add var0 [ var6 ] to var2 . if var2 equals var5 , increase var3 by 1 . return var3 . 
given integers var2 , var3 . initialize var6 to 0 . set var6 to the minimum between var2 , var3 . if var2 is not less than var3 , decrease var2 by var6 and add the integer value of ( var2 / 3 ) to var6 . return var6 . 
given integers var5 , var6 , var7 . let var1 and var2 be the minimum and maximum of var5 and var6 . assign 0 to var8 . assign ( $$CONSTANT$$ * $$CONSTANT$$ ) * $$CONSTANT$$ to var9 . as long as max - min exceeds 1 do following operations . assign to var0 the value ( var9 + var8 ) / 2 . if func0 ( med , r , var2 ) is not less than var7 then assign var0 to var9 . otherwise , assign it to var8 . when the loop is ended , return var9 . 
given integers var2 , var3 . initialize var6 to 0 . set var6 to the minimum between var2 , var3 . if var2 is not less than var3 , decrease var2 by var6 and add the integer value of ( var2 / 3 ) to var6 . 
given an array var0 . initialize var2 to the number of 1s in var0 and var3 to the number of 2s in var0 . 
given an array var0 . initialize var2 to the number of 1s in var0 and var3 to the number of 2s in var0 . 
given an array var0 . initialize var2 to the number of 1s in var0 and var3 to the number of 2s in var0 . if var3 equals 0 , return the integer value of var1 / 3 . if var2 equals 0 , return 0 . if var2 equals var3 , return var2 . initialize var6 to 0 . set var6 to the minimum between var2 , var3 . if var2 is not less than var3 , decrease var2 by var6 and add the integer value of ( var2 / 3 ) to var6 . return var6 . 
given integers var0 , var1 , var2 , var3 , var4 . initialize var5 , var6 to ( ( 2 * var2 ) + var3 ) - var0 and to ( var3 + ( 3 * var4 ) ) - var1 , respectively . initialize var7 to larger of 0 and var5 . if var6 exceeds 0 then add it to var7 . return var7 . 
given integers var0 , var1 , var2 , var3 , var4 . initialize var5 , var6 to ( ( 2 * var2 ) + var3 ) - var0 and to ( var3 + ( 3 * var4 ) ) - var1 , respectively . initialize var7 to larger of 0 and var5 . if var6 exceeds 0 then add it to var7 . 
given integers var0 , var1 , var2 , var3 , var4 . initialize var5 , var6 to ( ( 2 * var2 ) + var3 ) - var0 and to ( var3 + ( 3 * var4 ) ) - var1 , respectively . initialize var7 to larger of 0 and var5 . 
given integers var0 , var1 , var2 . create an integer typed array var8 . assing 0 to var3 . for all var4 $$CONSTANT$$ from 0 to $$CONSTANT$$ * $$CONSTANT$$ - 1 do following operations . assign the string representations of var1 and var2 to var5 and var6 , respectively . add var6 to the end of var5 . if var5 contains the value ' 7 ' then return var3 . add 1 to var3 . update var7 by the value $$CONSTANT$$ - n . if var7 is negative value then substract 1 from var1 and add $$CONSTANT$$ - $$CONSTANT$$ to var2 . otherwise , assign var7 to var2 . 
given integers var0 , var1 , var2 . assign the string representations of var1 and var2 to var5 and var6 , respectively . add var6 to the end of var5 . if var5 contains the value ' 7 ' then return var3 . add 1 to var3 . update var7 by the value $$CONSTANT$$ - n . if var7 is negative value then substract 1 from var1 and add $$CONSTANT$$ - $$CONSTANT$$ to var2 . otherwise , assign var7 to var2 . 
given integers var0 , var1 , var2 . assign the string representations of var1 and var2 to var5 and var6 , respectively . add var6 to the end of var5 . if var5 contains the value ' 7 ' then return var3 . add 1 to var3 . update var7 by the value $$CONSTANT$$ - n . 
given integers var0 , var1 , var2 . assign the string representations of var1 and var2 to var5 and var6 , respectively . add var6 to the end of var5 . if var5 contains the value ' 7 ' then return var3 . 
given integers var0 , var1 , var2 . create an integer typed array var8 . assing 0 to var3 . for all var4 $$CONSTANT$$ from 0 to $$CONSTANT$$ * $$CONSTANT$$ - 1 do following operations . assign the string representations of var1 and var2 to var5 and var6 , respectively . add var6 to the end of var5 . if var5 contains the value ' 7 ' then return var3 . add 1 to var3 . update var7 by the value $$CONSTANT$$ - n . if var7 is negative value then substract 1 from var1 and add $$CONSTANT$$ - $$CONSTANT$$ to var2 . otherwise , assign var7 to var2 . when the loop is ended , return var8 . 
given an array of integers var0 , initialize var4 to empty array of integers and var2 to 2 . for each position var3 in var0 set var2 to 3 - var2 if var0 [ var3 ] is even and append var2 to the end of var4 . 
given arrays of integers var0 and var4 and integers var3 and var2 , set var2 to 3 - var2 if var0 [ var3 ] is even and append var2 to the end of var4 . 
given integer array var0 . create integer array var6 . assign 0 to var3 . for each var4 from 1 to var1 , do following operations . if var0 [ var4 ] is even value then erect var3 to the power of 1 . if var3 does not equal 0 then add 1 to the end of var6 , or add 2 to the end of var6 , in other case . 
given integer array var0 . if var0 [ var4 ] is even value then erect var3 to the power of 1 . if var3 does not equal 0 then add 1 to the end of var6 , or add 2 to the end of var6 , in other case . 
given integer array var0 . create integer array var6 . assign 0 to var3 . for each var4 from 1 to var1 , do following operations . if var0 [ var4 ] is even value then erect var3 to the power of 1 . if var3 does not equal 0 then add 1 to the end of var6 , or add 2 to the end of var6 , in other case . return the resultant var6 . 
given integer array var0 . if var0 [ var4 ] is even value then erect var3 to the power of 1 . 
given $$CONSTANT$$ 2d array var1 . for each tow in var1 , return - 1 if the cell containing value 83 comes before the cell containing the value $$CONSTANT$$ , mark the difference between those two cells as found otherwise . return the sum of the differences which where marked previously . 
given integers var0 , var1 , var2 , var3 . assign var1 , var2 and var3 to var4 , var5 and to var6 , respectively . assign 0 to var7 . as long as each of values var5 % 10 , hh / 10 , mm % 10 and mm / 10 does not equal 7 and if mm / 10 does not equal 7 or var7 is not divisible by var4 , do following operations . if var6 equals 0 and var5 equals 0 then assign 23 to it . otherwise , if var6 equals 0 and var5 does not equal 0 then substract 1 from it . if var6 equals 0 then assign $$CONSTANT$$ to var6 . otherwise , substract 1 from it . add 1 to var7 . when the loop is ended , return ct / x . 
given integers var0 , var1 , var2 . if var3 equals var1 then add to the end of var6 the values " ( " , var3 , " ) " , or in other case , add to the end of var6 the value var3 . if var3 equals var0 then exit from the loop . add 1 to var3 . 
given integers var0 , var1 , var2 . if var3 equals var1 then add to the end of var6 the values " ( " , var3 , " ) " , or in other case , add to the end of var6 the value var3 . if var3 equals var0 then exit from the loop . 
given an integer var0 , $$CONSTANT$$ string var1 , count the number of 0 - based positions var5 such that var5 is divisible by var0 , var5 > = 3 and var1 [ var5 - 3 ] , var1 [ var5 - 2 ] and var1 [ var5 - 1 ] are equal to each other . store the result in var4 . 
given an integer var0 , $$CONSTANT$$ string var1 , count the number of 0 - based positions var5 such that var5 is divisible by var0 , var5 > = 3 and var1 [ var5 - 3 ] , var1 [ var5 - 2 ] and var1 [ var5 - 1 ] are equal to each other . return the result . 
you are given $$CONSTANT$$ number var0 , an array of strings var1 . you have to create $$CONSTANT$$ sorted set of numbers var2 and $$CONSTANT$$ sorted set of numbers var3 . set var4 to the length of var1 . for each var6 between 0 and var4 - 1 and each var7 between 0 and var0 - 1 , if var1 [ var6 ] [ var7 ] is equal to 83 insert var6 to var2 and insert var7 to var3 . 
given integers var0 , var1 and arrays var2 , var3 , var4 of length var5 . initialize $$CONSTANT$$ to an empty array . for each var6 from 1 to var5 , perform the following operations . initialize var7 to var2 [ var6 ] , var8 to var3 [ var6 ] , var9 to var4 [ var6 ] , var10 to var0 + ( var7 - 1 ) * var1 , var11 to var7 , var12 to var8 , var13 to 0 . while var11 is not greater than var12 , perform the following operations . initialize var14 to ( var11 + var12 ) / 2 , var15 to ( var0 + ( var14 - 1 ) * var1 ) , var16 to ( var14 - var7 + 1 * ( var10 + var15 ) ) / 2 . if var15 is not greater than var8 and var16 is not greater than var8 * var9 , set var13 to var14 and var11 to var14 + 1 ; else set var12 to var14 - 1 . push var13 into $$CONSTANT$$ . return $$CONSTANT$$ . 
you are given $$CONSTANT$$ number var0 , an array of strings var1 . you have to create $$CONSTANT$$ sorted set of numbers var2 and $$CONSTANT$$ sorted set of numbers var3 . set var4 to the length of var1 . for each var6 between 0 and var4 - 1 and each var7 between 0 and var0 - 1 , if var1 [ var6 ] [ var7 ] is equal to 83 insert var6 to var2 and insert var7 to var3 . you have to return var4 * var0 - ( the length of var2 multiplied by the length of var3 ) . 
you are given $$CONSTANT$$ number var2 . you have to set string var3 to " $$CONSTANT$$ " and character var4 to " $$CONSTANT$$ " . while var2 is greater than zero you have to store in var5 the least number greater than or equal to zero in such $$CONSTANT$$ way the function func0 at argument var5 is greater than var2 , you have to subtract 1 to var5 and subtract func0 at var5 to var2 , you have to concatenate var5 copies of var4 to var3 , you have to add 1 to the ascii code of var4 and store it character in var4 . 
you are given $$CONSTANT$$ number var2 , $$CONSTANT$$ string var3 and $$CONSTANT$$ character var4 . you have to store in var5 the least number greater than or equal to zero in such $$CONSTANT$$ way the function func0 at argument var5 is greater than var2 . you have to subtract 1 to var5 and subtract func0 at var5 to var2 . you have to concatenate var5 copies of var4 to var3 . you have to add 1 to the ascii code of var4 and store it in var4 . 
you are given $$CONSTANT$$ number var2 , $$CONSTANT$$ string var3 and $$CONSTANT$$ character var4 . you have to store in var5 the least number greater than or equal to zero in such $$CONSTANT$$ way the function func0 at argument var5 is greater than var2 . you have to subtract 1 to var5 and subtract func0 at var5 to var2 . you have to concatenate var5 copies of var4 to var3 . 
given var2 . using 0 - indexation , given an array var1 . set var3 to the length of var1 . set var5 to the number of ones in var1 between var1 [ var2 ] and var1 [ var2 + var3 - 1 ] and set var6 to the number of twos in var1 between var1 [ var2 ] and var1 [ var2 + var3 - 1 ] . while var6 and var5 are both greater than 1 , add 1 to var8 and decrease both var6 and var5 by 1 . 
given var2 . using 0 - indexation , given an array var1 . set var3 to the length of var1 . set var5 to the number of ones in var1 between var1 [ var2 ] and var1 [ var2 + var3 - 1 ] and set var6 to the number of twos in var1 between var1 [ var2 ] and var1 [ var2 + var3 - 1 ] . 
given var2 . using 0 - indexation , given an array var1 . set var3 to the length of var1 . set var5 to the number of ones in var1 between var1 [ var2 ] and var1 [ var2 + var3 - 1 ] and set var6 to the number of twos in var1 between var1 [ var2 ] and var1 [ var2 + var3 - 1 ] . 
given var1 and var2 . check if var1 [ var2 ] is equal to 1 . if this is equal to 1 , then increment var5 by 1 . else , var6 is incremented by 1 . 
given char typed array var0 . assign var1 [ var3 ] to var4 . if the integer representation of var4 is in the range from 48 to 57 and it is even value or if it equals one of values 97 , 105 , 111 , $$CONSTANT$$ , 117 then add 1 to var2 . 
you are given $$CONSTANT$$ string var0 . initialize var1 to 0 . iterate over all elements in var0 , in each iteration let var3 be the current element , if var3 is equal to any of ' $$CONSTANT$$ ' , ' e ' , ' $$CONSTANT$$ ' , ' o ' or ' u ' , or is an odd digit , increment var1 . 
given var2 . using 0 - indexation , given an array var1 . set var3 to the length of var1 . set var5 to the number of ones in var1 between var1 [ var2 ] and var1 [ var2 + var3 - 1 ] and set var6 to the number of twos in var1 between var1 [ var2 ] and var1 [ var2 + var3 - 1 ] . while var6 and var5 are both greater than 1 , add 1 to var8 and decrease both var6 and var5 by 1 . add the result of an integer division of var5 by 3 to var8 . return var8 . 
you are given $$CONSTANT$$ number var2 . you have to store in var5 the least number greater than or equal to zero in such $$CONSTANT$$ way the function func0 at argument var5 is greater than var2 . you have to subtract 1 to var5 and subtract func0 at var5 to var2 . 
you are given $$CONSTANT$$ number var2 . you have to store in var5 the least number greater than or equal to zero in such $$CONSTANT$$ way the function func0 at argument var5 is greater than var2 . you have to subtract 1 to var5 and subtract func0 at var5 to var2 . 
you are given $$CONSTANT$$ number var2 . you have to store in var5 the least number greater than or equal to zero in such $$CONSTANT$$ way the function func0 at argument var5 is greater than var2 . 
given integers var0 , var1 , var2 , var3 , var4 . assign the values ( 2 * var3 ) + ( var0 * var1 ) , ( 2 * var4 ) + ( var0 * var2 ) to var9 and to var10 . if var9 is less than var10 then return " $$CONSTANT$$ " . if var10 is less than var9 then return " $$CONSTANT$$ " . if these values are equal then return " $$CONSTANT$$ " . 
given integers var0 , var1 , var2 , var3 , var4 . assign the values ( 2 * var3 ) + ( var0 * var1 ) , ( 2 * var4 ) + ( var0 * var2 ) to var9 and to var10 . if var9 is less than var10 then return " $$CONSTANT$$ " . if var10 is less than var9 then return " $$CONSTANT$$ " . if these values are equal then return " $$CONSTANT$$ " . 
given char typed array var0 . return the number of elements in var0 with position var3 such that integer representation of var0 [ var3 ] is in the range from 48 to 57 and it is even value or it equals one of values 97 , 105 , 111 , $$CONSTANT$$ , 117 . 
given integers var0 , var1 , var2 , var3 , var4 . assign the values ( 2 * var3 ) + ( var0 * var1 ) , ( 2 * var4 ) + ( var0 * var2 ) to var9 and to var10 . if var9 is less than var10 then return " $$CONSTANT$$ " . if var10 is less than var9 then return " $$CONSTANT$$ " . 
given integers var0 , var1 , var2 , var3 , var4 . assign the values ( 2 * var3 ) + ( var0 * var1 ) , ( 2 * var4 ) + ( var0 * var2 ) to var9 and to var10 . 
given array var0 . set var3 : = var0 [ 1 ] - var0 [ 0 ] and var4 : = true . for var5 from 2 to var1 ( exclusive ) , if var0 [ var5 ] - var0 [ var5 - 1 ] does not equal var3 , set var4 : = false and break from the loop . 
given array var0 . set var3 : = var0 [ 1 ] - var0 [ 0 ] . 
given array var0 . set var1 : = len ( var0 ) and var2 : = var1 ( essentially ) . 
you are given $$CONSTANT$$ string var0 . initialize var1 to 0 . iterate over all elements in var0 , in each iteration let var3 be the current element , if var3 is equal to any of ' $$CONSTANT$$ ' , ' e ' , ' $$CONSTANT$$ ' , ' o ' or ' u ' , or is an odd digit , increment var1 . return var1 . 
you are given $$CONSTANT$$ string var0 and integers var2 , var1 . if var0 [ var2 ] is equal to any of ' $$CONSTANT$$ ' , ' e ' , ' $$CONSTANT$$ ' , ' o ' or ' u ' , increment var1 . 
given char array var1 . initialize var2 to total number of occurences of 97 , $$CONSTANT$$ , 105 , 111 , 117 in var1 plus number of appearances of odd digits in var1 . 
given array var0 . set var3 : = var0 [ 1 ] - var0 [ 0 ] . if var0 forms an arithmetic sequence , return var3 plus the last element of var0 . otherwise , return the last element of var0 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to zero . if var0 is less than 2 * var2 , add 2 * var2 - var0 to var5 and set var0 to zero , otherwise subtract 2 * var2 to var0 . if var0 is less than var3 , add var3 - var0 to var5 and set var0 to zero , otherwise subtract var3 to var0 . if var1 is less than var3 , add var3 - var1 to var5 and set var1 to zero , otherwise subtract var3 to var1 . if var1 is less than 3 * var4 , add 3 * var4 - var1 to var5 and set var1 to zero , otherwise subtract 3 * var4 to var1 . you have to return var5 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to zero . if var0 is less than 2 * var2 , add 2 * var2 - var0 to var5 and set var0 to zero , otherwise subtract 2 * var2 to var0 . if var0 is less than var3 , add var3 - var0 to var5 and set var0 to zero , otherwise subtract var3 to var0 . if var1 is less than var3 , add var3 - var1 to var5 and set var1 to zero , otherwise subtract var3 to var1 . if var1 is less than 3 * var4 , add 3 * var4 - var1 to var5 and set var1 to zero , otherwise subtract 3 * var4 to var1 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to zero . if var0 is less than 2 * var2 , add 2 * var2 - var0 to var5 and set var0 to zero , otherwise subtract 2 * var2 to var0 . if var0 is less than var3 , add var3 - var0 to var5 and set var0 to zero , otherwise subtract var3 to var0 . if var1 is less than var3 , add var3 - var1 to var5 and set var1 to zero , otherwise subtract var3 to var1 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to zero . if var0 is less than 2 * var2 , add 2 * var2 - var0 to var5 and set var0 to zero , otherwise subtract 2 * var2 to var0 . if var0 is less than var3 , add var3 - var0 to var5 and set var0 to zero , otherwise subtract var3 to var0 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to zero . if var0 is less than 2 * var2 , add 2 * var2 - var0 to var5 and set var0 to zero , otherwise subtract 2 * var2 to var0 . 
given char array var1 . return the total number of occurences of 97 , $$CONSTANT$$ , 105 , 111 , 117 in var1 plus number of appearances of odd digits in var1 . 
given $$CONSTANT$$ string var4 [ ] and integers var7 , var8 , and var9 . cyclic shift the $$CONSTANT$$ var4 [ var7 . . . var8 ] var9 times to the $$CONSTANT$$ . 
given $$CONSTANT$$ string var4 [ ] and integers var7 , var8 , and var9 . set var10 [ ] ( 0 - based ) to be the $$CONSTANT$$ var4 [ var7 . . . var8 ] and cyclic shift var10 [ ] var9 times to the $$CONSTANT$$ . set var13 = var7 . 
given $$CONSTANT$$ string var4 [ ] and integers var7 , var8 , and var9 . set var10 [ ] ( 0 - based ) to be the $$CONSTANT$$ var4 [ var7 . . . var8 ] and cyclic shift var10 [ ] var9 times to the $$CONSTANT$$ . 
given var11 , var9 , var7 , var8 . set var12 = var11 + var9 . if var12 > var8 , subtract ( var8 - var7 + 1 ) from var12 . set var10 [ ( var12 - var7 ) ] = var4 [ var11 ] . 
given integer array var0 . let var4 be the sum of all values in var0 decreased by first value in var0 . assign first value in var0 to var3 . for all var2 $$CONSTANT$$ from 0 to n - 2 do following operations . if var3 equals var4 then add 1 to var5 . add 1 to var1 and to var2 . if var2 equals to last position in var0 then exit from the loop . add var0 [ var1 ] to var3 . substract var0 [ var2 ] from var4 . 
given integer array var0 . if var3 equals var4 then add 1 to var5 . add 1 to var1 and to var2 . if var2 equals to last position in var0 then exit from the loop . add var0 [ var1 ] to var3 . substract var0 [ var2 ] from var4 . 
given integer array var0 . if var3 equals var4 then add 1 to var5 . add 1 to var1 and to var2 . if var2 equals to last position in var0 then exit from the loop . 
given integer array var0 . let var4 be the sum of all values in var0 decreased by first value in var0 . assign first value in var0 to var3 . 
given integer array var0 . let var4 be the sum of all values in var0 . 
given integer array var0 . if var3 equals var4 then add 1 to var5 . add 1 to var1 and to var2 . 
you are given an array of strings var1 ( indexing is 0 - based ) , an array of strings var2 ( indexing is 0 - based ) . you have to create an array of numbers var8 of length $$CONSTANT$$ . for each position var9 in var1 add 1 to var8 [ var1 [ var9 ] ] , subtract 1 to var8 [ var2 [ var9 ] ] . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to store in var2 the number of elements 1 in var0 . you have to store in var3 the number of elements 2 in var0 . you have to set var4 to zero . if var2 is greater than 0 you have to , if var3 is greater than zero add the minimum between var3 and var2 to var4 , add var2 - var4 divided by 3 ( rounded down ) to var4 , otherwise set var4 to var2 divided by 3 ( rounded down ) . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to store in var2 the number of elements 1 in var0 . you have to store in var3 the number of elements 2 in var0 . 
you are given an array of numbers var0 , $$CONSTANT$$ number var3 , $$CONSTANT$$ number var2 , an index var7 . you have to set var6 to var0 [ var7 ] and add 1 to var7 . if var6 is equal to 2 you have to add 1 to var3 , otherwise you have to add 1 to var2 . 
given $$CONSTANT$$ string var0 , initialize var1 to " $$CONSTANT$$ " . count the number of characters var3 in var0 , which appear in var1 , and store the result in var2 . 
given integers var0 , var1 , var2 , var3 , var4 . if ( var2 * 2 ) + ( var3 * 1 ) is larger than or equal to var0 then assign ( var2 * 2 ) + ( var3 * 1 ) - var0 to var7 . otherwise , var7 is 0 . if ( var3 * 1 ) + ( 3 * var4 ) is larger than or equal to var1 then increment var7 by ( var3 * 1 ) + ( 3 * var4 ) - var1 . return var7 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to store in var2 the number of elements 1 in var0 . you have to store in var3 the number of elements 2 in var0 . you have to set var4 to zero . if var2 is greater than 0 you have to , if var3 is greater than zero add the minimum between var3 and var2 to var4 , add var2 - var4 divided by 3 ( rounded down ) to var4 , otherwise set var4 to var2 divided by 3 ( rounded down ) . you have to return var4 . 
given integers var0 , var1 , var2 , var3 , var4 . if ( var2 * 2 ) + ( var3 * 1 ) is larger than or equal to var0 then assign ( var2 * 2 ) + ( var3 * 1 ) - var0 to var7 . otherwise , var7 is 0 . if ( var3 * 1 ) + ( 3 * var4 ) is larger than or equal to var1 then increment var7 by ( var3 * 1 ) + ( 3 * var4 ) - var1 . 
given integers var0 , var1 , var2 , var3 , var4 . if ( var2 * 2 ) + ( var3 * 1 ) is larger than var0 then assign ( var2 * 2 ) + ( var3 * 1 ) - var0 to var7 . 
given integers var2 , var3 , var4 . create integer array var8 . assign to var5 the value ( var3 * $$CONSTANT$$ ) + var4 . assign 0 to var6 . until func0 ( var0 ) is true or func0 ( var7 ) is true , do following operations . assign to var0 and to var7 the values mins / $$CONSTANT$$ , mins % $$CONSTANT$$ . if func0 ( var0 ) is true or func0 ( var7 ) is true then add var6 to the end of var8 and exit from the loop . assign to var5 the value ( ( ( var5 - var2 ) % 1440 ) + 1440 ) % 1440 . add 1 to var6 . 
given integers var2 , var3 , var4 . assign to var0 and to var7 the values mins / $$CONSTANT$$ , mins % $$CONSTANT$$ . if func0 ( var0 ) is true or func0 ( var7 ) is true then add var6 to the end of var8 and exit from the loop . assign to var5 the value ( ( ( var5 - var2 ) % 1440 ) + 1440 ) % 1440 . add 1 to var6 . 
given integer array var0 . let var4 be the sum of all values in var0 decreased by first value in var0 . assign first value in var0 to var3 . for all var2 $$CONSTANT$$ from 0 to n - 2 do following operations . if var3 equals var4 then add 1 to var5 . add 1 to var1 and to var2 . if var2 equals to last position in var0 then exit from the loop . add var0 [ var1 ] to var3 . substract var0 [ var2 ] from var4 . when the loop is ended , return var5 . 
given integers var2 , var3 , var4 . assign to var0 and to var7 the values mins / $$CONSTANT$$ , mins % $$CONSTANT$$ . if func0 ( var0 ) is true or func0 ( var7 ) is true then add var6 to the end of var8 and exit from the loop . 
given integer var0 . while var0 exceeds 0 do following operations . assign to var1 the value $$CONSTANT$$ % 10 . if var1 equals 7 then return true . divide var0 by 10 . 
given integers var2 , var3 , var4 . create integer array var8 . assign to var5 the value ( var3 * $$CONSTANT$$ ) + var4 . assign 0 to var6 . until func0 ( var0 ) is true or func0 ( var7 ) is true , do following operations . assign to var0 and to var7 the values mins / $$CONSTANT$$ , mins % $$CONSTANT$$ . if func0 ( var0 ) is true or func0 ( var7 ) is true then add var6 to the end of var8 and exit from the loop . assign to var5 the value ( ( ( var5 - var2 ) % 1440 ) + 1440 ) % 1440 . add 1 to var6 . when the loop is ended , return resultant var8 . 
you are given $$CONSTANT$$ number var0 , an array of strings var1 , $$CONSTANT$$ number var2 . you have to create an array of numbers var4 of the length of var1 plus 1 . you have to set var5 to 1 and var4 [ 0 ] to 1 . for each position var6 in var1 you have to set var7 to var1 [ var2 ] [ 0 ] and add 1 to var2 , if var7 is equal to $$CONSTANT$$ you have to add 1 to var5 , otherwise you have to set var4 [ var8 ] to the sum of the elements in var4 at positions less than or equal to var8 and greater than zero modulo $$CONSTANT$$ , for each var8 between 1 and var5 - 1 . 
you are given an array of numbers var4 , an index var2 , an array of strings var1 and $$CONSTANT$$ number var5 . you have to set var7 to var1 [ var2 ] [ 0 ] and add 1 to var2 . if var7 is equal to $$CONSTANT$$ you have to add 1 to var5 , otherwise you have to set var4 [ var5 - 1 ] to the sum of the elements in var4 at positions less than var5 and greater than zero modulo $$CONSTANT$$ . 
you are given an array of numbers var4 and $$CONSTANT$$ number var5 . you have to set var4 [ var5 - 1 ] to the sum of the elements in var4 at positions less than var5 and greater than zero modulo $$CONSTANT$$ . 
given an real var0 , integer array var1 , integers var2 , var5 , var7 , real var3 , var6 , var8 , string array var9 . assign var2 to length of var1 . length of var3 is equal to var2 . for var5 in range from 0 to var2 - 1 : assign var6 to var0 ; for var7 in range from 0 to var5 : if | var1 [ var7 ] - var1 [ var5 ] | is greater than 2 * var0 then assign var8 to var0 , else assign var8 to ( var3 [ var7 ] + $$CONSTANT$$ ( ( ( ( 4 * var0 ) * var0 ) - ( ( var1 [ var7 ] - var1 [ var5 ] ) * ( var1 [ var7 ] - var1 [ var5 ] ) ) ) ) ) ; assign var6 to max ( var6 , var8 ) ; assign var3 [ var5 ] to var6 . add var3 [ var5 ] to var9 . 
given an real var0 , integer array var1 , integers var2 , var5 , var7 , real var3 , var6 , var8 , string array var9 . assign var2 to length of var1 . length of var3 is equal to var2 . for var5 in range from 0 to var2 - 1 : assign var6 to var0 ; for var7 in range from 0 to var5 : if | var1 [ var7 ] - var1 [ var5 ] | is greater than 2 * var0 then assign var8 to var0 , else assign var8 to ( var3 [ var7 ] + $$CONSTANT$$ ( ( ( ( 4 * var0 ) * var0 ) - ( ( var1 [ var7 ] - var1 [ var5 ] ) * ( var1 [ var7 ] - var1 [ var5 ] ) ) ) ) ) ; assign var6 to max ( var6 , var8 ) ; assign var3 [ var5 ] to var6 . add var3 [ var5 ] to var9 . 
given an real var0 , integer array var1 , integers var2 , var5 , var7 , real var3 , var6 , var8 , string array var9 . assign var2 to length of var1 . length of var3 is equal to var2 . for var5 in range from 0 to var2 - 1 : assign var6 to var0 ; for var7 in range from 0 to var5 : if | var1 [ var7 ] - var1 [ var5 ] | is greater than 2 * var0 then assign var8 to var0 , else assign var8 to ( var3 [ var7 ] + $$CONSTANT$$ ( ( ( ( 4 * var0 ) * var0 ) - ( ( var1 [ var7 ] - var1 [ var5 ] ) * ( var1 [ var7 ] - var1 [ var5 ] ) ) ) ) ) ; assign var6 to max ( var6 , var8 ) ; assign var3 [ var5 ] to var6 . add var3 [ var5 ] to var9 . return var9 . 
given an real var0 , integer array var1 , integers var2 , var5 , var7 , real var3 , var6 , var8 , string array var9 . assign var2 to length of var1 . length of var3 is equal to var2 . for var5 in range from 0 to var2 - 1 : assign var6 to var0 ; for var7 in range from 0 to var5 : if | var1 [ var7 ] - var1 [ var5 ] | is greater than 2 * var0 then assign var8 to var0 , else assign var8 to ( var3 [ var7 ] + $$CONSTANT$$ ( ( ( ( 4 * var0 ) * var0 ) - ( ( var1 [ var7 ] - var1 [ var5 ] ) * ( var1 [ var7 ] - var1 [ var5 ] ) ) ) ) ) ; assign var6 to max ( var6 , var8 ) . 
given an real var0 , integer array var1 , integers var2 , var5 , var7 , real var3 , var6 , var8 , string array var9 . assign var2 to length of var1 . length of var3 is equal to var2 . for var5 in range from 0 to var2 - 1 : assign var6 to var0 ; for var7 in range from 0 to var5 : if | var1 [ var7 ] - var1 [ var5 ] | is greater than 2 * var0 then assign var8 to var0 , else assign var8 to ( var3 [ var7 ] + $$CONSTANT$$ ( ( ( ( 4 * var0 ) * var0 ) - ( ( var1 [ var7 ] - var1 [ var5 ] ) * ( var1 [ var7 ] - var1 [ var5 ] ) ) ) ) ) ; assign var6 to max ( var6 , var8 ) . 
given an real var0 , integer array var1 , integers var2 , var5 , var7 , real var3 , var6 , var8 , string array var9 . assign var2 to length of var1 . length of var3 is equal to var2 . 
given an real var0 , integer array var1 , integers var2 , var5 , var7 , real var3 , var6 , var8 , string array var9 . assign var2 to length of var1 . length of var3 is equal to var2 . 
given $$CONSTANT$$ string var0 . set the value of var1 to the number of values in string var0 which are equal to ' $$CONSTANT$$ ' , ' e ' , ' $$CONSTANT$$ ' , ' o ' , ' u ' , ' 0 ' , ' 2 ' , ' 4 ' , ' 6 ' or ' 8 ' . 
given $$CONSTANT$$ string var1 , count the number of characters of var1 , which are present in string " $$CONSTANT$$ " . store the result in var4 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var0 . set var3 to zero . you have to iterate , in each iteration you have to , if the last digit in the decimal representation of var1 is equal to 7 or the last digit in the decimal representation of var2 is equal to 7 , you have to break from the enclosing loop , add 1 to var3 , subtarct var0 to var2 , while var2 is less than zero you have to , add $$CONSTANT$$ to var2 , subtract 1 to var1 ; while var1 is less than zero you have to add $$CONSTANT$$ to var1 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var0 and $$CONSTANT$$ number var3 . if the last digit in the decimal representation of var1 is equal to 7 or the last digit in the decimal representation of var2 is equal to 7 , you have to break from the enclosing loop . you have to add 1 to var3 . subtarct var0 to var2 . while var2 is less than zero you have to , add $$CONSTANT$$ to var2 , subtract 1 to var1 . while var1 is less than zero you have to add $$CONSTANT$$ to var1 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var0 and $$CONSTANT$$ number var3 . if the last digit in the decimal representation of var1 is equal to 7 or the last digit in the decimal representation of var2 is equal to 7 , you have to break from the enclosing loop . you have to add 1 to var3 . subtarct var0 to var2 . while var2 is less than zero you have to , add $$CONSTANT$$ to var2 , subtract 1 to var1 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 and $$CONSTANT$$ number var3 . if the last digit in the decimal representation of var1 is equal to 7 or the last digit in the decimal representation of var2 is equal to 7 , you have to break from the enclosing loop . you have to add 1 to var3 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var0 . set var3 to zero . you have to iterate , in each iteration you have to , if the last digit in the decimal representation of var1 is equal to 7 or the last digit in the decimal representation of var2 is equal to 7 , you have to break from the enclosing loop , add 1 to var3 , subtarct var0 to var2 , while var2 is less than zero you have to , add $$CONSTANT$$ to var2 , subtract 1 to var1 ; while var1 is less than zero you have to add $$CONSTANT$$ to var1 . you have to return var3 . 
given $$CONSTANT$$ 2d array var1 . for each tow in var1 , return - 1 if the cell containing value 83 comes before the cell containing the value $$CONSTANT$$ , mark the difference between those two cells as found otherwise . set the value of var8 to the sum of the differences which where marked previously . 
given an integer var6 , an integer var4 , an integer var5 , and $$CONSTANT$$ 2d array var1 . set the value of var4 to the number of the last $$CONSTANT$$ that contains the value 83 in the var6 - th row of array var1 . set the value of var5 to the number of the last $$CONSTANT$$ that contains the value $$CONSTANT$$ in the var6 - th row of array var1 . then , return - 1 if ( var5 > var4 ) . then , mark the difference between the two columns as found . 
given an integer var6 , an integer var4 , an integer var5 , and $$CONSTANT$$ 2d array var1 . set the value of var4 to the number of the last $$CONSTANT$$ that contains the value 83 in the var6 - th row of array var1 . set the value of var5 to the number of the last $$CONSTANT$$ that contains the value $$CONSTANT$$ in the var6 - th row of array var1 . then , return - 1 if ( var5 > var4 ) . 
given an integer var6 , an integer var4 , an integer var5 , and $$CONSTANT$$ 2d array var1 . set the value of var4 to the number of the last $$CONSTANT$$ that contains the value 83 in the var6 - th row of array var1 . set the value of var5 to the number of the last $$CONSTANT$$ that contains the value $$CONSTANT$$ in the var6 - th row of array var1 . 
given $$CONSTANT$$ string var1 , count the number of characters of var1 , which are present in string " $$CONSTANT$$ " . return the result . 
given integers var0 , var1 and arrays var2 , var3 , var4 of length var5 . initialize $$CONSTANT$$ to an empty array . for each var6 from 1 to var5 , perform the following operations . initialize var7 to var2 [ var6 ] , var8 to var3 [ var6 ] , var9 to var4 [ var6 ] , var10 to var0 + ( var7 - 1 ) * var1 , var11 to var7 , var12 to var8 , var13 to 0 . while var11 is not greater than var12 , perform the following operations . initialize var14 to ( var11 + var12 ) / 2 , var15 to ( var0 + ( var14 - 1 ) * var1 ) , var16 to ( var14 - var7 + 1 * ( var10 + var15 ) ) / 2 . if var15 is not greater than var8 and var16 is not greater than var8 * var9 , set var13 to var14 and var11 to var14 + 1 ; else set var12 to var14 - 1 . push var13 into $$CONSTANT$$ . 
given integers var0 , var1 and arrays var2 , var3 , var4 of length var5 . for each var6 from 1 to var5 , perform the following operations . initialize var7 to var2 [ var6 ] , var8 to var3 [ var6 ] , var9 to var4 [ var6 ] , var10 to var0 + ( var7 - 1 ) * var1 , var11 to var7 , var12 to var8 , var13 to 0 . while var11 is not greater than var12 , perform the following operations . initialize var14 to ( var11 + var12 ) / 2 , var15 to ( var0 + ( var14 - 1 ) * var1 ) , var16 to ( var14 - var7 + 1 * ( var10 + var15 ) ) / 2 . if var15 is not greater than var8 and var16 is not greater than var8 * var9 , set var13 to var14 and var11 to var14 + 1 ; else set var12 to var14 - 1 . push var13 into $$CONSTANT$$ . 
given integers var0 , var1 and arrays var2 , var3 , var4 of length var5 . for each var6 from 1 to var5 , perform the following operations . initialize var7 to var2 [ var6 ] , var8 to var3 [ var6 ] , var9 to var4 [ var6 ] , var10 to var0 + ( var7 - 1 ) * var1 , var11 to var7 , var12 to var8 , var13 to 0 . while var11 is not greater than var12 , perform the following operations . initialize var14 to ( var11 + var12 ) / 2 , var15 to ( var0 + ( var14 - 1 ) * var1 ) , var16 to ( var14 - var7 + 1 * ( var10 + var15 ) ) / 2 . if var15 is not greater than var8 and var16 is not greater than var8 * var9 , set var13 to var14 and var11 to var14 + 1 ; else set var12 to var14 - 1 . 
given integers var0 , var1 , var11 , var12 , var7 , var8 , var9 . initialize var14 to ( var11 + var12 ) / 2 , var15 to ( var0 + ( var14 - 1 ) * var1 ) , var16 to ( var14 - var7 + 1 * ( var10 + var15 ) ) / 2 . if var15 is not greater than var8 and var16 is not greater than var8 * var9 , set var13 to var14 and var11 to var14 + 1 ; else set var12 to var14 - 1 . 
you are given $$CONSTANT$$ number var0 , an array of strings var1 , an index var6 , $$CONSTANT$$ sorted set of numbers var2 , $$CONSTANT$$ sorted set of numbers var3 . for each var7 between 0 and var0 - 1 , if var1 [ var6 ] [ var7 ] is equal to 83 insert var6 to var2 and insert var7 to var3 . 
given an array of integers var0 , initialize var1 to length of var0 , var2 to 1 and var4 to array of $$CONSTANT$$ of length var1 + 1 , filled with false . for each position var6 in var0 add 1 to var2 if var4 [ var0 [ var6 ] ] = true , set var4 [ var0 [ var6 ] ] to true otherwise . 
given an array of integers var0 , initialize var1 to length of var0 , var2 to 1 and var4 to array of $$CONSTANT$$ of length var1 + 1 , filled with false . 
given an array of integers var0 , initialize var1 to length of var0 , var2 to 1 and var4 to array of $$CONSTANT$$ of length var1 + 1 , filled with false . 
given an array of integers var0 , initialize var1 to length of var0 and var2 to 1 . 
you are given $$CONSTANT$$ number var0 , an array of strings var1 , $$CONSTANT$$ number var2 . you have to create an array of numbers var4 of the length of var1 plus 1 . you have to set var5 to 1 and var4 [ 0 ] to 1 . for each position var6 in var1 you have to set var7 to var1 [ var2 ] [ 0 ] and add 1 to var2 , if var7 is equal to $$CONSTANT$$ you have to add 1 to var5 , otherwise you have to set var4 [ var8 ] to the sum of the elements in var4 at positions less than or equal to var8 and greater than zero modulo $$CONSTANT$$ , for each var8 between 1 and var5 - 1 . you have to return var4 [ var5 - 1 ] . 
given an array of integers var0 , initialize var1 to length of var0 , var2 to 1 and var4 to array of $$CONSTANT$$ of length var1 + 1 , filled with false . for each position var6 in var0 add 1 to var2 if var4 [ var0 [ var6 ] ] = true , set var4 [ var0 [ var6 ] ] to true otherwise . return var2 . 
given an integer var0 . initialize var1 to var0 , var2 to 0 , var3 to 1 . while var1 is not less than the value of ( ( ( ( 3 * ( 1 + var3 ) ) * var3 ) / 2 ) - var3 ) , perform the following operations . initialize var4 to var1 - ( ( ( ( 3 * ( 1 + var3 ) ) * var3 ) / 2 ) - var3 ) . if var4 is divisible by 3 , increase var2 by 1 . increase var3 by 1 . 
given integers var3 , var2 , var1 . initialize var4 to ( var1 - ( ( ( ( 3 * ( 1 + var3 ) ) * var3 ) / 2 ) - var3 ) ) . if var4 is divisible by 3 , increase var2 by 1 . increase var3 by 1 . 
given integers var3 , var2 , var1 . initialize var4 to ( var1 - ( ( ( ( 3 * ( 1 + var3 ) ) * var3 ) / 2 ) - var3 ) ) . if var4 is divisible by 3 , increase var2 by 1 . 
given an integer var0 . initialize var1 to var0 , var2 to 0 , var3 to 1 . while var1 is not less than the value of ( ( ( ( 3 * ( 1 + var3 ) ) * var3 ) / 2 ) - var3 ) , perform the following operations . initialize var4 to var1 - ( ( ( ( 3 * ( 1 + var3 ) ) * var3 ) / 2 ) - var3 ) . if var4 is divisible by 3 , increase var2 by 1 . increase var3 by 1 . return var2 . 
given string var0 you need to split string into substrings divided by " , " and save all numbers into array var2 
given an array of integers var0 , initialize var1 to length of var0 , var3 to true and var4 to 0 . for each position var5 in var0 continue the loop if var0 [ var5 ] = 0 and var3 = true , if var0 [ var5 ] = 0 , then set var3 to true if var5 = var1 - 1 or var0 [ var5 + 1 ] = 0 , add 1 to var4 otherwise , otherwise set var3 to false and add 1 to var4 . 
given an array of integers var0 , $$CONSTANT$$ boolean var3 and integers var1 , var5 and var4 , continue the enclosing loop if var0 [ var5 ] = 0 and var3 = true , if var0 [ var5 ] = 0 , then set var3 to true if var5 = var1 - 1 or var0 [ var5 + 1 ] = 0 , add 1 to var4 otherwise , otherwise set var3 to false and add 1 to var4 . 
given an array of integers var0 , initialize var1 to length of var0 . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) , an array of numbers var2 ( indexing is 0 - based ) . you have to set var6 to zero . for each position var7 in var1 you have to , if var1 [ var7 ] is greater than var6 you have to continue the enclosing loop , set var6 to the maximum between var6 and var2 [ var7 ] , if var6 is greater than or equal to var0 return " YES " . 
you are given $$CONSTANT$$ matrix of numbers var4 , $$CONSTANT$$ number var6 , an index var7 , $$CONSTANT$$ number var0 . if var4 [ var7 ] [ 0 ] is greater than var6 you have to continue the enclosing loop . you have to set var6 to the maximum between var6 and var4 [ var7 ] [ 1 ] . if var6 is greater than or equal to var0 you have to return " YES " . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 , an array of numbers var2 . you have to create $$CONSTANT$$ var3 * 2 matrix of numbers var4 . you have to store in $$CONSTANT$$ zero of var4 the array var1 . you have to store in $$CONSTANT$$ 1 of var4 the array var2 . 
given integers var0 , var1 . initialize var5 to an array consisting of two values 100003 , 100003 , var4 to 100003 . for each var2 from 1 to var0 - 2 , concatenate var5 with var2 and var2 + 1 and decrease var4 by 1 . concatenate var5 with var0 - 1 and var0 . set var4 to var1 - var0 + 1 . for each var2 from 1 to var0 , perform the following operations . initialize var3 to var2 + 2 . while var3 is not greater than var0 and var4 is greater than 0 , concatenate var5 with var2 , var3 , and $$CONSTANT$$ , decrease var4 by 1 , increase var3 by 1 . 
given integers var0 , var1 . initialize var5 to an array consisting of two values 100003 , 100003 , var4 to 100003 . for each var2 from 1 to var0 - 2 , concatenate var5 with var2 and var2 + 1 and decrease var4 by 1 . concatenate var5 with var0 - 1 and var0 . set var4 to var1 - var0 + 1 . for each var2 from 1 to var0 , perform the following operations . initialize var3 to var2 + 2 . while var3 is not greater than var0 and var4 is greater than 0 , concatenate var5 with var2 , var3 , and $$CONSTANT$$ , decrease var4 by 1 , increase var3 by 1 . return var5 . 
given integers var0 , var1 . initialize var5 to an array consisting of two values 100003 , 100003 , var4 to 100003 . for each var2 from 1 to var0 - 2 , concatenate var5 with var2 and var2 + 1 and decrease var4 by 1 . concatenate var5 with var0 - 1 and var0 . set var4 to var1 - var0 + 1 . 
given string var0 you need to split string into substrings divided by " , " and save all numbers into array var2 you need to sort this array and save first element into var5 and var4 
given integers var0 , var1 . initialize var5 to an array consisting of two values 100003 , 100003 , var4 to 100003 . for each var2 from 1 to var0 - 2 , concatenate var5 with var2 and var2 + 1 and decrease var4 by 1 . concatenate var5 with var0 - 1 and var0 . set var4 to var1 - var0 + 1 . 
given integers var0 , var1 . initialize var5 to an array consisting of two values 100003 , 100003 , var4 to 100003 . for each var2 from 1 to var0 - 2 , concatenate var5 with var2 and var2 + 1 and decrease var4 by 1 . 
given an array var5 and integers var2 , var0 , var4 . initialize var3 to var2 + 2 . while var3 is not greater than var0 and var4 is greater than 0 , concatenate var5 with var2 , var3 , and $$CONSTANT$$ , decrease var4 by 1 , increase var3 by 1 . 
given integers var2 , var0 , var1 . assign 0 to var3 . as long as the result of function func0 ( hh , var1 ) is false do following operations . add 1 to var3 . if var1 - var2 is negative value then assign to var0 the value ( ( var0 - 1 ) + $$CONSTANT$$ ) % $$CONSTANT$$ . assign ( ( var1 - var2 ) + $$CONSTANT$$ ) % $$CONSTANT$$ to var1 . 
given integers var2 , var0 , var1 . assign 0 to var3 . as long as the result of function func0 ( hh , var1 ) is false do following operations . add 1 to var3 . if var1 - var2 is negative value then assign to var0 the value ( ( var0 - 1 ) + $$CONSTANT$$ ) % $$CONSTANT$$ . assign ( ( var1 - var2 ) + $$CONSTANT$$ ) % $$CONSTANT$$ to var1 . when the loop is ended , return var3 . 
given $$CONSTANT$$ string array var0 . initialize var7 to an empty array , var2 to $$CONSTANT$$ map . for each string var3 in var0 , perform the following operations . if var2 contains var3 as $$CONSTANT$$ key , put the concatenation of var3 and var2 [ var3 ] + 1 into var7 and increase var2 [ var3 ] by 1 ; else put " OK " into var7 and set var2 [ var3 ] to 0 . 
given $$CONSTANT$$ string array var0 , an array var7 and $$CONSTANT$$ map var2 . for each string var3 in var0 , perform the following operations . if var2 contains var3 as $$CONSTANT$$ key , put the concatenation of var3 and var2 [ var3 ] + 1 into var7 and increase var2 [ var3 ] by 1 ; else put " OK " into var7 and set var2 [ var3 ] to 0 . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to true and var4 to 0 . for each position var5 in var0 continue the loop if var0 [ var5 ] = 0 and var3 = true , if var0 [ var5 ] = 0 , then set var3 to true if var5 = var1 - 1 or var0 [ var5 + 1 ] = 0 , add 1 to var4 otherwise , otherwise set var3 to false and add 1 to var4 . return var4 . 
given integers var0 , var1 , var2 , var3 . assign var1 , var2 and var3 to var4 , var5 and to var6 , respectively . assign 0 to var7 . as long as each of values var5 % 10 , hh / 10 , mm % 10 and mm / 10 does not equal 7 and if mm / 10 does not equal 7 or var7 is not divisible by var4 , do following operations . if var6 equals 0 and var5 equals 0 then assign 23 to it . otherwise , if var6 equals 0 and var5 does not equal 0 then substract 1 from it . if var6 equals 0 then assign $$CONSTANT$$ to var6 . otherwise , substract 1 from it . add 1 to var7 . 
given integers var0 , var1 , var2 , var3 . if var6 equals 0 and var5 equals 0 then assign 23 to it . otherwise , if var6 equals 0 and var5 does not equal 0 then substract 1 from it . if var6 equals 0 then assign $$CONSTANT$$ to var6 . otherwise , substract 1 from it . add 1 to var7 . 
given $$CONSTANT$$ string array var0 . initialize var7 to an empty array , var2 to $$CONSTANT$$ map . for each string var3 in var0 , perform the following operations . if var2 contains var3 as $$CONSTANT$$ key , put the concatenation of var3 and var2 [ var3 ] + 1 into var7 and increase var2 [ var3 ] by 1 ; else put " OK " into var7 and set var2 [ var3 ] to 0 . return var7 . 
given integers var0 , var1 , var2 , var3 . if var5 equals 0 then assign 23 to it . otherwise , substract 1 from it . assign $$CONSTANT$$ to var6 . 
you are given $$CONSTANT$$ number var0 , an array of numbers var1 ( indexing is 0 - based ) , an array of numbers var2 ( indexing is 0 - based ) . you have to set var6 to zero . for each position var7 in var1 you have to , if var1 [ var7 ] is greater than var6 you have to continue the enclosing loop , set var6 to the maximum between var6 and var2 [ var7 ] , if var6 is greater than or equal to var0 return " YES " . you have to return " NO " . 
you are given $$CONSTANT$$ number var2 . you have to set string var3 to " $$CONSTANT$$ " and character var4 to " $$CONSTANT$$ " . while var2 is greater than zero you have to store in var5 the least number greater than or equal to zero in such $$CONSTANT$$ way the function func0 at argument var5 is greater than var2 , you have to subtract 1 to var5 and subtract func0 at var5 to var2 , you have to concatenate var5 copies of var4 to var3 , you have to add 1 to the ascii code of var4 and store it character in var4 . after the loop ends you have to return var3 . 
given an array of integers var2 and integers var0 and var1 , initialize var4 and var5 to 0 . for each position var6 in var2 add var2 [ var6 ] to var5 if var5 + var2 [ var6 ] < = var0 , add 1 to var4 and set var5 to var2 [ var6 ] otherwise , add var5 / var1 ( rounded down ) to var4 and set var5 to var5 % var1 . add 1 to var4 if var5 > 0 . 
given an array of integers var2 and integers var0 and var1 , initialize var4 and var5 to 0 . for each position var6 in var2 add var2 [ var6 ] to var5 if var5 + var2 [ var6 ] < = var0 , add 1 to var4 and set var5 to var2 [ var6 ] otherwise , add var5 / var1 ( rounded down ) to var4 and set var5 to var5 % var1 . 
given an array of integers var2 and integers var0 and var1 , initialize var4 and var5 to 0 . for each position var6 in var2 add var2 [ var6 ] to var5 if var5 + var2 [ var6 ] < = var0 , add 1 to var4 and set var5 to var2 [ var6 ] otherwise , add var5 / var1 ( rounded down ) to var4 and set var5 to var5 % var1 . add 1 to var4 if var5 > 0 . return var4 . 
given $$CONSTANT$$ string $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb and integers $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ and var2 , initialize var3 and var4 to 0 , var5 to var2 - th ( 0 - based ) letter of english alphabet . append var5 to the end of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb . for as long as var4 + var3 < $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ , append var5 to the end of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb , increase var3 by 1 and add var3 to var4 . 
given an integer var6 , initialize $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ to var6 and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb to empty string . for each integer var2 from 0 to $$CONSTANT$$ ( both inclusive ) initialize var3 and var4 to 0 , var5 to var2 - th ( 0 - based ) letter of english alphabet , append var5 to the end of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb , for as long as var4 + var3 < $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ , append var5 to the end of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb , increase var3 by 1 and add var3 to var4 , after the cycle substract var4 from $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ . return $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb . 
given an integer var6 , initialize $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ to var6 and $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb to empty string . for each integer var2 from 0 to $$CONSTANT$$ ( both inclusive ) initialize var3 and var4 to 0 , var5 to var2 - th ( 0 - based ) letter of english alphabet , append var5 to the end of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb , for as long as var4 + var3 < $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ , append var5 to the end of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb , increase var3 by 1 and add var3 to var4 , after the cycle substract var4 from $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ . 
given $$CONSTANT$$ string $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb and integers $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ and var2 , initialize var3 and var4 to 0 , var5 to var2 - th ( 0 - based ) letter of english alphabet . append var5 to the end of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb . for as long as var4 + var3 < $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ , append var5 to the end of $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . sb , increase var3 by 1 and add var3 to var4 . substract var4 from $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . maximus . $$CONSTANT$$ . 
given $$CONSTANT$$ two - dimensional array var0 and $$CONSTANT$$ map var2 . initialize var8 to an empty array . iterate through elements of var0 and initialize var3 to the current element . if var2 contains var3 as $$CONSTANT$$ key , increase value of this key by 1 and push the concatenation of var3 and this increased value into var8 . otherwise , push " OK " into var8 and put the pair with key var3 and value 0 into var2 . 
given $$CONSTANT$$ two - dimensional array var0 and $$CONSTANT$$ map var2 . initialize var8 to an empty array . iterate through elements of var0 and initialize var3 to the current element . if var2 contains var3 as $$CONSTANT$$ key , increase value of this key by 1 and push the concatenation of var3 and this increased value into var8 . otherwise , push " OK " into var8 and put the pair with key var3 and value 0 into var2 . 
given $$CONSTANT$$ two - dimensional array var0 and $$CONSTANT$$ map var2 . initialize var8 to an empty array . iterate through elements of var0 and initialize var3 to the current element . if var2 contains var3 as $$CONSTANT$$ key , increase value of this key by 1 and push the concatenation of var3 and this increased value into var8 . otherwise , push " OK " into var8 and put the pair with key var3 and value 0 into var2 . return var8 . 
given char typed arrays var0 , var1 . create integer typed arrays var2 , var3 of sizes $$CONSTANT$$ . add 1 to elements of var2 at positions stored in var0 . add 1 to elements of arr1 at positions stored in var1 . if there is such position var4 that var3 [ var4 ] exceeds 0 and var2 [ var4 ] equals 0 then assign true to var7 . otherwise , let var6 be the sum of minimums of pairwise values from var3 and var2 . 
given char typed arrays var0 , var1 . create integer typed arrays var2 , var3 of sizes $$CONSTANT$$ . add 1 to elements of var2 at positions stored in var0 . add 1 to elements of arr1 at positions stored in var1 . 
given char typed arrays var0 , var1 . create integer typed arrays var2 , var3 of sizes $$CONSTANT$$ . add 1 to elements of var2 at positions stored in var0 . 
given char typed arrays var0 , var1 . create integer typed arrays var2 , var3 of sizes $$CONSTANT$$ . add 1 to elements of var2 at positions stored in var0 . 
you are given $$CONSTANT$$ number var10 , $$CONSTANT$$ number var11 , $$CONSTANT$$ number var0 , $$CONSTANT$$ number var8 . you have to set var13 to var10 + var11 divided by 2 . you have to set var14 to var13 plus $$CONSTANT$$ of var13 , and multiplicate var14 by 2 * var0 . if var14 is less than var8 you have to set var10 to var13 , otherwise you have to set var11 to var13 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var2 to zero , var3 to zero and var4 to zero . for each position var5 in var0 you have to , set var6 to var0 [ var5 ] , if var6 is equal to 1 you have to , add 1 to var2 , add 1 to var4 , if var3 is equal to 1 add 1 to var2 , set var3 to zero ; otherwise if var4 is equal to 0 you have to continue in the enclosing loop ; otherwise add 1 to var3 . 
you are given an array of numbers var0 , an index var7 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var4 , $$CONSTANT$$ number var3 . you have to set var6 to var0 [ var7 ] and add 1 to var7 . if var6 is equal to 1 you have to , add 1 to var2 , add 1 to var4 , if var3 is equal to 1 add 1 to var2 , set var3 to zero ; otherwise if var4 is equal to 0 you have to continue in the enclosing loop ; otherwise add 1 to var3 . 
you are given $$CONSTANT$$ number var2 , $$CONSTANT$$ number var4 , $$CONSTANT$$ number var3 . you have to add 1 to var2 and add 1 to var4 . if var3 is equal to 1 add 1 to var2 . you have to set var3 to zero . 
you are given $$CONSTANT$$ number var2 , $$CONSTANT$$ number var4 , $$CONSTANT$$ number var3 . you have to add 1 to var2 and add 1 to var4 . if var3 is equal to 1 add 1 to var2 . 
given integer array var0 . add 1 to var4 the value var0 [ var5 ] . decrease var3 by var0 [ var5 ] . if var3 equals var4 then increment var2 . for each var5 from 0 to $$CONSTANT$$ - 2 , do following operations . add 1 to var4 the value var0 [ var5 ] . decrease var3 by var0 [ var5 ] . if var3 equals var4 then increment var2 . 
given integer array var0 . add 1 to var4 the value var0 [ var5 ] . decrease var3 by var0 [ var5 ] . if var3 equals var4 then increment var2 . 
given integer array var0 . initialize var3 to the sum of all elements of var0 . 
given integer array var0 . initialize var3 to the sum of all elements of var0 . 
you are given $$CONSTANT$$ number var1 . you have to create an array of numbers var2 of length 10 . for each var3 between 1 and var1 modulo 10 you have to set var2 [ var3 ] to var1 divided by 9 ( rounded down ) plus 1 . for each var4 between ( var1 modulo 9 ) plus 1 , and 9 , set var2 [ var4 ] to var1 divided by 9 ( rounded down ) . you have to store in var5 the sum of var2 [ var6 ] * var2 [ var7 ] * var2 [ the value of the function func0 at the argument var6 * var7 ] , for each var6 between 1 and 9 and each var7 between 1 and 9 . for each var8 between 1 and var1 , subtract var1 divided by var8 ( rounded down ) to var5 . 
you are given $$CONSTANT$$ number var1 . you have to create an array of numbers var2 of length 10 . for each var3 between 1 and var1 modulo 10 you have to set var2 [ var3 ] to var1 divided by 9 ( rounded down ) plus 1 . for each var4 between ( var1 modulo 9 ) plus 1 , and 9 , set var2 [ var4 ] to var1 divided by 9 ( rounded down ) . you have to store in var5 the sum of var2 [ var6 ] * var2 [ var7 ] * var2 [ the value of the function func0 at the argument var6 * var7 ] , for each var6 between 1 and 9 and each var7 between 1 and 9 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var2 to zero , var3 to zero and var4 to zero . for each position var5 in var0 you have to , set var6 to var0 [ var5 ] , if var6 is equal to 1 you have to , add 1 to var2 , add 1 to var4 , if var3 is equal to 1 add 1 to var2 , set var3 to zero ; otherwise if var4 is equal to 0 you have to continue in the enclosing loop ; otherwise add 1 to var3 . you have to return var2 . 
given char typed arrays var0 , var1 . create integer typed arrays var2 , var3 of sizes $$CONSTANT$$ . add 1 to elements of var2 at positions stored in var0 . add 1 to elements of arr1 at positions stored in var1 . if there is such position var4 that var3 [ var4 ] exceeds 0 and var2 [ var4 ] equals 0 then return " - 1 " . otherwise , return the sum of minimums of pairwise values from var3 and var2 . 
given integer array var0 . add 1 to var4 the value var0 [ var5 ] . decrease var3 by var0 [ var5 ] . if var3 equals var4 then increment var2 . for each var5 from 0 to $$CONSTANT$$ - 2 , do following operations . add 1 to var4 the value var0 [ var5 ] . decrease var3 by var0 [ var5 ] . if var3 equals var4 then increment var2 . when the loop is ended , return var2 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var5 to zero . you have to create an array of $$CONSTANT$$ var3 of the length of var0 . for each position var6 in var3 in $$CONSTANT$$ $$CONSTANT$$ , if var3 [ var6 ] is equal to false you have to , set var7 to var6 , add 1 to var5 , while var7 is greater than or equal to zero and var3 [ var7 ] is equal to false you have to , set var3 [ var7 ] to true , set var7 to var0 [ var7 ] - 1 . 
you are given an array of numbers var0 ( indexing is 0 - based ) , $$CONSTANT$$ number var5 , an index var6 , an array of $$CONSTANT$$ var3 ( indexing is 0 - based ) . set var7 to var6 and add 1 to var5 . while var7 is greater than or equal to zero and var3 [ var7 ] is equal to false you have to , set var3 [ var7 ] to true , set var7 to var0 [ var7 ] - 1 . 
you are given integers var0 , var1 , var2 , var3 , var4 . decrease var0 by var2 * 2 + var3 . decrease var1 by var4 * 3 + var3 . return abs of sum of negative numbers from var0 and var1 . if var0 and var1 are non - negative , return 0 . 
given integers var0 , var1 , var2 . substract var0 from var2 . if var2 is negative then do following operations . add $$CONSTANT$$ to var2 . substract 1 from var1 . if var1 is negative then add $$CONSTANT$$ to var1 . after this , add 1 to var3 . 
given integers var0 , var1 , var2 . substract var0 from var2 . if var2 is negative then do following operations . add $$CONSTANT$$ to var2 . substract 1 from var1 . if var1 is negative then add $$CONSTANT$$ to var1 . 
given integers var0 , var1 , var2 . add $$CONSTANT$$ to var2 . substract 1 from var1 . if var1 is negative then add $$CONSTANT$$ to var1 . 
given integers var0 , var1 , var2 . assign 0 to var3 . as long as $$CONSTANT$$ of values var1 % 10 , ( var1 / 10 ) , var2 % 10 , var2 / 10 does not equal 7 do following operations . substract var0 from var2 . if var2 is negative then do following operations . add $$CONSTANT$$ to var2 . substract 1 from var1 . if var1 is negative then add $$CONSTANT$$ to var1 . after this , add 1 to var3 . 
given integers var2 , var3 , var4 . initialize var5 to 0 . while var5 does not contain 4 or 7 as $$CONSTANT$$ digit , perform the following operations . decrease var4 by var2 . if var4 is less than 0 , add $$CONSTANT$$ to var4 , decrease var3 by 1 . if var3 is less than 0 , set var3 to 23 . increase var5 by 1 . 
given integers var2 , var3 , var4 , var5 . decrease var4 by var2 . if var4 is less than 0 , add $$CONSTANT$$ to var4 , decrease var3 by 1 . if var3 is less than 0 , set var3 to 23 . increase var5 by 1 . 
given integers var2 , var3 , var4 . decrease var4 by var2 . if var4 is less than 0 , add $$CONSTANT$$ to var4 , decrease var3 by 1 . if var3 is less than 0 , set var3 to 23 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . set var5 to zero . you have to create an array of $$CONSTANT$$ var3 of the length of var0 . for each position var6 in var3 in $$CONSTANT$$ $$CONSTANT$$ , if var3 [ var6 ] is equal to false you have to , set var7 to var6 , add 1 to var5 , while var7 is greater than or equal to zero and var3 [ var7 ] is equal to false you have to , set var3 [ var7 ] to true , set var7 to var0 [ var7 ] - 1 . you have to return var5 . 
given integers var3 , var4 . add $$CONSTANT$$ to var4 , decrease var3 by 1 . if var3 is less than 0 , set var3 to 23 . 
given integers var2 , var3 , var4 . initialize var5 to 0 . while var5 does not contain 4 or 7 as $$CONSTANT$$ digit , perform the following operations . decrease var4 by var2 . if var4 is less than 0 , add $$CONSTANT$$ to var4 , decrease var3 by 1 . if var3 is less than 0 , set var3 to 23 . increase var5 by 1 . return var5 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and $$CONSTANT$$ number var2 . you have to set var3 to var1 * $$CONSTANT$$ + var2 . you have to iterate var4 from 0 , and if var3 divided by $$CONSTANT$$ ( rounded down ) is equal to 7 or var3 divided by $$CONSTANT$$ ( rounded down ) is equal to $$CONSTANT$$ or var3 modulo 10 is equal to 7 , you have to return var4 ; you have to subtract var0 to var3 , if var3 is less than zero you have to add 1440 to var3 . 
you are given $$CONSTANT$$ number var3 , $$CONSTANT$$ number var4 , $$CONSTANT$$ number var0 , an array of numbers var5 . if var3 divided by $$CONSTANT$$ ( rounded down ) is equal to 7 or var3 divided by $$CONSTANT$$ ( rounded down ) is equal to $$CONSTANT$$ or var3 modulo 10 is equal to 7 , you have to insert var4 to var5 and return var5 . you have to subtract var0 to var3 . if var3 is less than zero you have to add 1440 to var3 . 
given integer var2 and integer arrays var3 , var4 . assign 0 to var5 . iterating over var3 and var4 , in each case , when var5 is not less than var3 [ var7 ] , update var5 by its current value and var4 [ var7 ] . if resultant var5 is not less than var2 then return " YES " . otherwise , return " NO " . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and $$CONSTANT$$ number var2 . you have to set var3 to var1 * $$CONSTANT$$ + var2 . you have to iterate var4 from 0 , and if var3 divided by $$CONSTANT$$ ( rounded down ) is equal to 7 or var3 divided by $$CONSTANT$$ ( rounded down ) is equal to $$CONSTANT$$ or var3 modulo 10 is equal to 7 , you have to return var4 ; you have to subtract var0 to var3 , if var3 is less than zero you have to add 1440 to var3 . 
you are given $$CONSTANT$$ number var3 , $$CONSTANT$$ number var4 , $$CONSTANT$$ number var0 , an array of numbers var5 . if var3 divided by $$CONSTANT$$ ( rounded down ) is equal to 7 or var3 divided by $$CONSTANT$$ ( rounded down ) is equal to $$CONSTANT$$ or var3 modulo 10 is equal to 7 , you have to insert var4 to var5 and return var5 . you have to subtract var0 to var3 . 
given an array of strings var0 , initialize var7 to empty array of strings and var1 to empty string to integer map . for each position var3 in var0 initialize var4 to var0 [ var3 ] , if var1 has key var4 , then set var5 to the value of var1 at var4 , append to the end of var7 $$CONSTANT$$ string , obtained by concatenation of var4 and var5 , and increase the value of var1 at var4 by 1 , otherwise , set the value of var1 at var4 to 1 and append to the end of var7 $$CONSTANT$$ string " OK " . 
given string to integer map var1 , an integer var3 and an array of strings var7 , initialize var4 to var0 [ var3 ] . if var1 has key var4 , then set var5 to the value of var1 at var4 , append to the end of var7 $$CONSTANT$$ string , obtained by concatenation of var4 and var5 , and increase the value of var1 at var4 by 1 , otherwise , set the value of var1 at var4 to 1 and append to the end of var7 $$CONSTANT$$ string " OK " . 
given an array of strings var0 , initialize var7 to empty array of strings and var1 to empty string to integer map . for each position var3 in var0 initialize var4 to var0 [ var3 ] , if var1 has key var4 , then set var5 to the value of var1 at var4 , append to the end of var7 $$CONSTANT$$ string , obtained by concatenation of var4 and var5 , and increase the value of var1 at var4 by 1 , otherwise , set the value of var1 at var4 to 1 and append to the end of var7 $$CONSTANT$$ string " OK " . return var7 . 
given char matrix var0 . create char matrix var8 . create map var2 of key type of char typed array and value type of integer . for each var3 from 0 to last position of var0 , do following operations . assign var0 [ var3 ] to var4 . if var2 has key var4 then assign var2 [ var4 ] + 1 to var5 , initialize var6 to array consisting of var4 and string value of var5 , add var6 to the end of var8 , assign var5 tp var2 [ var4 ] , otherwise , assign 0 to var2 [ var4 ] , add " OK " to the end of var8 . 
given char matrix var0 . assign var0 [ var3 ] to var4 . if var2 has key var4 then assign var2 [ var4 ] + 1 to var5 , initialize var6 to array consisting of var4 and string value of var5 , add var6 to the end of var8 , assign var5 tp var2 [ var4 ] , otherwise , assign 0 to var2 [ var4 ] , add " OK " to the end of var8 . 
given char matrix var0 . create char matrix var8 . create map var2 of key type of char typed array and value type of integer . for each var3 from 0 to last position of var0 , do following operations . assign var0 [ var3 ] to var4 . if var2 has key var4 then assign var2 [ var4 ] + 1 to var5 , initialize var6 to array consisting of var4 and string value of var5 , add var6 to the end of var8 , assign var5 tp var2 [ var4 ] , otherwise , assign 0 to var2 [ var4 ] , add " OK " to the end of var8 . when the loop is ended , return var8 . 
you are given $$CONSTANT$$ number var6 and $$CONSTANT$$ number var3 . set var7 to 1 , var8 to 2 and subtract 1 to var3 . for each var9 between $$CONSTANT$$ and 0 , if the value of the function func0 at the arguments var9 and var3 is less than var6 you have to , add the var9 power of var8 to var7 , subtract the value of the function func0 at the arguments var9 and var3 to var6 , subtract 1 to var3 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . set var2 to 1 . for each var3 between 0 and var1 - 1 set var2 to ( var2 * ( var0 - var3 ) ) divided by ( var3 + 1 ) ( rounded down ) . you have to return var2 . 
you are given $$CONSTANT$$ matrix of numbers var4 , $$CONSTANT$$ number var6 , an index var7 . if var4 [ var7 ] [ 0 ] is greater than var6 you have to continue the enclosing loop . you have to set var6 to the maximum between var6 and var4 [ var7 ] [ 1 ] . 
you are given $$CONSTANT$$ number var1 . you have to create an array of numbers var2 of length 10 . for each var3 between 1 and var1 modulo 10 you have to set var2 [ var3 ] to var1 divided by 9 ( rounded down ) plus 1 . for each var4 between ( var1 modulo 9 ) plus 1 , and 9 , set var2 [ var4 ] to var1 divided by 9 ( rounded down ) . you have to store in var5 the sum of var2 [ var6 ] * var2 [ var7 ] * var2 [ the value of the function func0 at the argument var6 * var7 ] , for each var6 between 1 and 9 and each var7 between 1 and 9 . for each var8 between 1 and var1 , subtract var1 divided by var8 ( rounded down ) to var5 . you have to return var5 . 
you are given $$CONSTANT$$ string var1 . you have to store in var3 the number of vowels in var1 plus the number of odd digits in var1 . 
you are given $$CONSTANT$$ string var1 , $$CONSTANT$$ number var3 and an index var4 . if var1 [ var4 ] is $$CONSTANT$$ vowel you have to add 1 to var3 . you have to set var6 to the numerical value of character var1 [ var4 ] . if var6 is an odd natural number less than 10 you have to add 1 to var3 . 
you are given $$CONSTANT$$ string var1 , $$CONSTANT$$ number var3 and an index var4 . if var1 [ var4 ] is $$CONSTANT$$ vowel you have to add 1 to var3 . you have to set var6 to the numerical value of character var1 [ var4 ] . 
you are given $$CONSTANT$$ string var1 , $$CONSTANT$$ number var3 and an index var4 . if var1 [ var4 ] is $$CONSTANT$$ vowel you have to add 1 to var3 . 
given $$CONSTANT$$ string var0 . return the number of vowels and digits in the given string . 
given $$CONSTANT$$ string var0 . return the number of vowels and digits in the given string . 
given char typed array var0 . let var2 be the total number of appearances of values $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ , 57 , 97 , $$CONSTANT$$ , 105 , 111 , 117 in var0 . 
given $$CONSTANT$$ string var0 , compute number of characters in it that are either vowels ( ' $$CONSTANT$$ ' , ' e ' , ' $$CONSTANT$$ ' , ' o ' or ' u ' ) or odd digits ( ' 1 ' , ' 3 ' , ' 5 ' , ' 7 ' or ' 9 ' ) and store it into var1 . 
given integers var0 , var1 . assign var0 to var2 . assign 0 to var3 . while var0 does not equal 0 , update var0 by var0 > > 1 and increment var3 . initialize var4 to ( 1 < < var3 ) - 1 . if var1 equals 1 then assign var2 to var4 . 
given integers var0 , var1 . assign var0 to var2 . assign 0 to var3 . while var0 does not equal 0 , update var0 by var0 > > 1 and increment var3 . initialize var4 to ( 1 < < var3 ) - 1 . 
given integers var0 , var1 . assign var0 to var2 . assign 0 to var3 . while var0 does not equal 0 , update var0 by var0 > > 1 and increment var3 . 
given integers var0 , var1 . assign var0 to var2 . assign 0 to var3 . while var0 does not equal 0 , update var0 by var0 > > 1 and increment var3 . initialize var4 to ( 1 < < var3 ) - 1 . if var1 equals 1 then assign var2 to var4 . return var4 . 
you are given an array of strings var2 and $$CONSTANT$$ string var0 . you have to create an array of numbers var5 of length $$CONSTANT$$ initializated with zeros . you have to create an array of numbers var6 of length $$CONSTANT$$ initializated with zeros . set var7 to false . for each position var8 in var2 , add 1 to var5 [ var2 [ var8 ] [ 0 ] - 97 ] , add 1 to var6 [ var2 [ var8 ] [ 1 ] - 97 ] , if the value of the function func0 at the arguments var0 and var2 [ var8 ] is equal to zero you have to set var7 to true . 
you are given an array of strings var2 , an index var8 , an array of numbers var5 , an array of numbers var6 , $$CONSTANT$$ number var3 . add 1 to var5 [ var2 [ var8 ] [ 0 ] - 97 ] , add 1 to var6 [ var2 [ var8 ] [ 1 ] - 97 ] . if the value of the function func0 at the arguments var3 and var2 [ var8 ] is equal to zero you have to set var7 to true . 
given $$CONSTANT$$ string , compute number of characters in it that are either vowels ( ' $$CONSTANT$$ ' , ' e ' , ' $$CONSTANT$$ ' , ' o ' or ' u ' ) or odd digits ( ' 1 ' , ' 3 ' , ' 5 ' , ' 7 ' or ' 9 ' ) . 
you are given the string var0 ( indexing is 0 - based ) . you have to set var2 to zero and var1 to the index of the first character " 1 " in var0 if it exist , otherwise you have to set var1 to the length of var0 . for each character " 0 " in var0 with index greater than or equal to var1 you have to add 1 to var2 , but if var2 becomes greater than or equal to 6 you have to break from the enclosing loop . 
you are given the string var0 ( indexing is 0 - based ) , $$CONSTANT$$ number var1 and $$CONSTANT$$ number var2 . if var0 [ var1 ] is equal to " 0 " you have to add 1 to var2 . if var2 is greater than or equal to 6 you have to break from the enclosing loop . 
you are given the string var0 ( indexing is 0 - based ) . you have to set var2 to zero and var1 to the index of the first character " 1 " in var0 if it exist , otherwise you have to set var1 to the length of var0 . 
given $$CONSTANT$$ string var0 . return the number of vowels and digits in the given string . 
you are given an array of numbers var0 . you have to set var2 to the length of var0 . you have to create an array of numbers var3 of length var2 + 1 initializated with - 1 . you have to create an array of numbers var4 of length var2 + 1 initializated with - 1 . you have to set var3 [ 0 ] to zero and var4 [ 0 ] to zero . you have to set var5 to 1 . for each var6 between 1 and var2 , you have to set var7 to var0 [ var6 - 1 ] , if var3 [ var4 [ var7 ] ] is different to var7 you have to , set var3 [ var5 ] to var6 , add 1 to var5 , set var4 [ var6 ] to var5 - 1 ; otherwise you have to , set var3 [ var4 [ var7 ] ] to var6 , set var4 [ var6 ] to var4 [ var7 ] . 
you are given an array of numbers var0 , an index var1 , an index var6 , an array of numbers var3 , $$CONSTANT$$ number var5 , an array of numbers var4 . you have to set var7 to var0 [ var1 ] and add 1 to var1 . if var3 [ var4 [ var7 ] ] is different to var7 you have to , set var3 [ var5 ] to var6 , add 1 to var5 , set var4 [ var6 ] to var5 - 1 ; otherwise you have to , set var3 [ var4 [ var7 ] ] to var6 , set var4 [ var6 ] to var4 [ var7 ] . 
you are given the string var0 ( indexing is 0 - based ) . store in var2 how many characters " 0 " there exist after the first character " 1 " in var0 . if var2 is greater than or equal to 6 you have to return " $$CONSTANT$$ " , otherwise , you have to return " $$CONSTANT$$ " . 
you are given an array of strings var2 and $$CONSTANT$$ string var0 . you have to create an array of numbers var5 of length $$CONSTANT$$ initializated with zeros . you have to create an array of numbers var6 of length $$CONSTANT$$ initializated with zeros . set var7 to false . for each position var8 in var2 , add 1 to var5 [ var2 [ var8 ] [ 0 ] - 97 ] , add 1 to var6 [ var2 [ var8 ] [ 1 ] - 97 ] , if the value of the function func0 at the arguments var0 and var2 [ var8 ] is equal to zero you have to set var7 to true . if var7 is equal to true return " YES " , otherwise if var6 [ var0 [ 0 ] - 97 ] is greater than zero and var5 [ var0 [ 1 ] - 97 ] is greater than zero return " YES " , otherwise return " NO " . 
you are given $$CONSTANT$$ string var1 . you have to return the number of vowels in var1 plus the number of odd digits in var1 . 
given integer var0 , integer arrays var1 , var2 . assign 0 , true to var4 , var5 . for each var6 from 0 to n - 1 , if var1 [ var6 ] exceeds var4 then assign 0 to var5 and exit from the loop , then assign the larger of var2 [ var6 ] and var4 to var4 . when the loop is ended , if var4 is less than var0 then assign false to var5 . 
given integer var0 , integer arrays var1 , var2 . assign 0 , true to var4 , var5 . for each var6 from 0 to n - 1 , if var1 [ var6 ] exceeds var4 then assign 0 to var5 and exit from the loop , then assign the larger of var2 [ var6 ] and var4 to var4 . 
given integer var0 , integer arrays var1 , var2 . if var1 [ var6 ] exceeds var4 then assign 0 to var5 and exit from the loop . assign the larger of var2 [ var6 ] and var4 to var4 . 
given integer var0 , integer arrays var1 , var2 . if var1 [ var6 ] exceeds var4 then assign 0 to var5 and exit from the loop . assign var2 [ var6 ] to var8 . 
given integer var0 , integer arrays var1 , var2 . if var1 [ var6 ] exceeds var4 then assign 0 to var5 and exit from the loop . 
you are given an array of numbers var0 . you have to set var2 to the length of var0 . you have to create an array of numbers var3 of length var2 + 1 initializated with - 1 . you have to create an array of numbers var4 of length var2 + 1 initializated with - 1 . you have to set var3 [ 0 ] to zero and var4 [ 0 ] to zero . you have to set var5 to 1 . for each var6 between 1 and var2 , you have to set var7 to var0 [ var6 - 1 ] , if var3 [ var4 [ var7 ] ] is different to var7 you have to , set var3 [ var5 ] to var6 , add 1 to var5 , set var4 [ var6 ] to var5 - 1 ; otherwise you have to , set var3 [ var4 [ var7 ] ] to var6 , set var4 [ var6 ] to var4 [ var7 ] . you have to return var5 . 
given an integer var0 and an array var1 . initialize var10 , var3 to empty arrays . for each var5 from 0 to the length of var1 exclusive , perform the following operations . set var3 [ var5 ] to var0 . for each var6 from 0 to var5 exclusive , perform the following operations . initialize var7 to the absolute value of var1 [ var5 ] - var1 [ var6 ] . if var7 is not greater than 2 * var0 , set var3 [ var5 ] to the maximum between its value and var3 [ var6 ] + square root of ( 4 * var0 * var0 - var7 * var7 ) . set var10 to elements of var3 splitted by spaces . 
given an integer var0 and an array var1 . initialize var10 , var3 to empty arrays . for each var5 from 0 to the length of var1 exclusive , perform the following operations . set var3 [ var5 ] to var0 . for each var6 from 0 to var5 exclusive , perform the following operations . initialize var7 to the absolute value of var1 [ var5 ] - var1 [ var6 ] . if var7 is not greater than 2 * var0 , set var3 [ var5 ] to the maximum between its value and var3 [ var6 ] + square root of ( 4 * var0 * var0 - var7 * var7 ) . set var10 to elements of var3 splitted by spaces . return var10 . 
given integer var0 , integer arrays var1 , var2 . assign 0 , true to var4 , var5 . for each var6 from 0 to n - 1 , if var1 [ var6 ] exceeds var4 then assign 0 to var5 and exit from the loop , then assign the larger of var2 [ var6 ] and var4 to var4 . when the loop is ended , if var4 is less than var0 then assign false to var5 . if var5 is true then return " YES " . return " No " . 
given an integer var0 and an array var1 . initialize var10 , var3 to empty arrays . for each var5 from 0 to the length of var1 exclusive , perform the following operations . set var3 [ var5 ] to var0 . for each var6 from 0 to var5 exclusive , perform the following operations . initialize var7 to the absolute value of var1 [ var5 ] - var1 [ var6 ] . if var7 is not greater than 2 * var0 , set var3 [ var5 ] to the maximum between its value and var3 [ var6 ] + square root of ( 4 * var0 * var0 - var7 * var7 ) . 
given an integer var0 and an array var1 . initialize var10 , var3 to empty arrays . for each var5 from 0 to the length of var1 exclusive , perform the following operations . set var3 [ var5 ] to var0 . for each var6 from 0 to var5 exclusive , perform the following operations . initialize var7 to the absolute value of var1 [ var5 ] - var1 [ var6 ] . if var7 is not greater than 2 * var0 , set var3 [ var5 ] to the maximum between its value and var3 [ var6 ] + square root of ( 4 * var0 * var0 - var7 * var7 ) . 
given char typed array var0 . return the total number of appearances of values $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ , 57 , 97 , $$CONSTANT$$ , 105 , 111 , 117 in var0 . 
given integers var5 , var0 and arrays var1 , var3 . set var3 [ var5 ] to var0 . for each var6 from 0 to var5 exclusive , perform the following operations . initialize var7 to the absolute value of var1 [ var5 ] - var1 [ var6 ] . if var7 is not greater than 2 * var0 , set var3 [ var5 ] to the maximum between its value and var3 [ var6 ] + square root of ( 4 * var0 * var0 - var7 * var7 ) . 
given integers var0 , var5 , var6 and arrays var1 , var3 . initialize var7 to the absolute value of var1 [ var5 ] - var1 [ var6 ] . if var7 is not greater than 2 * var0 , set var3 [ var5 ] to the maximum between its value and var3 [ var6 ] + square root of ( 4 * var0 * var0 - var7 * var7 ) . 
you are given $$CONSTANT$$ number var1 . you have to create an array of numbers var2 of length 10 . for each var3 between 1 and var1 modulo 10 you have to set var2 [ var3 ] to var1 divided by 9 ( rounded down ) plus 1 . for each var4 between ( var1 modulo 9 ) plus 1 , and 9 , set var2 [ var4 ] to var1 divided by 9 ( rounded down ) . you have to store in var5 the sum of var2 [ var6 ] * var2 [ var7 ] * var2 [ the value of the function func0 at the argument var6 * var7 ] , for each var6 between 1 and 9 and each var7 between 1 and 9 . 
you are given $$CONSTANT$$ number var1 . you have to create an array of numbers var2 of length 10 . for each var3 between 1 and var1 modulo 10 you have to set var2 [ var3 ] to var1 divided by 9 ( rounded down ) plus 1 . for each var4 between ( var1 modulo 9 ) plus 1 , and 9 , set var2 [ var4 ] to var1 divided by 9 ( rounded down ) . 
you are given an array of numbers var2 , $$CONSTANT$$ number var6 , $$CONSTANT$$ number var5 . for each var7 between 1 and 9 you have to , add var2 [ var6 ] * var2 [ var7 ] * var2 [ the value of the function func0 at the argument var6 * var7 ] , to var5 . 
you are given $$CONSTANT$$ number var1 . you have to create an array of numbers var2 of length 10 . for each var3 between 1 and var1 modulo 10 you have to set var2 [ var3 ] to var1 divided by 9 ( rounded down ) plus 1 . 
you are given $$CONSTANT$$ number var1 . you have to create an array of numbers var2 of length 10 . for each var3 between 1 and var1 modulo 10 you have to set var2 [ var3 ] to var1 divided by 9 ( rounded down ) plus 1 . 
given integers var0 , var1 , var3 , var4 and an array var2 of integer type . let var5 be the length of var2 . assign 0 to var6 , var8 . set var4 to its positive value . assign values $$CONSTANT$$ , 1 to var9 and var10 , respectively . for all var11 $$CONSTANT$$ from 1 to var11 < var5 do following operations . assign var5 - 1 to var7 . set var12 to the square root of the sum of values var3 - var2 [ var11 ] erected to the power of 2 and var4 erected to the power of 2 . assign the sum of real value of var2 [ var11 ] / var0 and var12 / var1 to var13 . if var13 is less than var9 then assign var13 to var9 and set var10 to var11 + 1 . otherwise , if var13 equals var9 and var2 [ var11 ] equals var3 then set var10 to $$CONSTANT$$ $$CONSTANT$$ 1 + 1 and set var9 to var13 . 
given integers var0 , var1 , var3 , var4 and an array var2 of integer type . set var12 to the square root of the sum of values var3 - var2 [ var11 ] erected to the power of 2 and var4 erected to the power of 2 . assign the sum of real value of var2 [ var11 ] / var0 and var12 / var1 to var13 . if var13 is less than var9 then assign var13 to var9 and set var10 to var11 + 1 . otherwise , if var13 equals var9 and var2 [ var11 ] equals var3 then set var10 to $$CONSTANT$$ $$CONSTANT$$ 1 + 1 and set var9 to var13 . 
given an array of strings var0 , initialize var7 to empty array of strings , var1 to empty string to integer map . for each position var3 in var0 if var1 has not key var0 [ var3 ] , set the value of var1 at var0 [ var3 ] to 0 and append " OK " to the end of var7 , otherwise set var5 to the value of var1 at var0 [ var3 ] plus 1 , append $$CONSTANT$$ concatenation of var0 [ var3 ] and var5 , converted to string , to the end of var7 and set the value of var1 at var0 [ var3 ] to var5 . return var7 . 
given array var0 and matrix var1 both types char . create matrix var10 of char type . assign 0 to var9 . create arrays var2 , var3 , var5 , var6 of char types . add var0 [ 0 ] to the end of var5 . add var0 [ 1 ] to the end of var6 . let var7 be the length of var1 . for all var8 $$CONSTANT$$ from 0 to var8 < var7 do following operations . assign the next value in var1 to var4 . if var4 equals var0 then add " YES " to the end of var10 and return var10 . add var4 [ 0 ] to the end of var2 . add var4 [ 1 ] to the end of var3 . 
given array var0 and matrix var1 both types char . assign the next value in var1 to var4 . if var4 equals var0 then add " YES " to the end of var10 and return var10 . add var4 [ 0 ] to the end of var2 . add var4 [ 1 ] to the end of var3 . 
given array var0 and matrix var1 both types char . create matrix var10 of char type . assign 0 to var9 . create arrays var2 , var3 , var5 , var6 of char types . add var0 [ 0 ] to the end of var5 . add var0 [ 1 ] to the end of var6 . let var7 be the length of var1 . for all var8 $$CONSTANT$$ from 0 to var8 < var7 do following operations . assign the next value in var1 to var4 . if var4 equals var0 then add " YES " to the end of var10 and return var10 . add var4 [ 0 ] to the end of var2 . add var4 [ 1 ] to the end of var3 . after the loop is ended , if var3 contains var5 and var2 contains var6 then add " YES " to the end of var10 . otherwise , add " NO " to the end of var10 . return var10 . 
given array var0 and matrix var1 both types char . assign the next value in var1 to var4 . if var4 equals var0 then add " YES " to the end of var10 and return var10 . 
you are given an array of numbers var1 , an array of numbers var2 ( indexing is 0 - based ) and $$CONSTANT$$ number var0 . you have to create an array of strings var10 . you have to set var4 to zero . for each var5 in var1 if var4 is less than var1 [ var5 ] you have to return " NO " , you have to store in var4 the maximum between var4 and var2 [ var5 ] . after the loop ends , if var4 is equal to var0 you have to insert string " YES " to var10 , and you have to insert string " NO " otherwise . 
given an array of strings var0 , initialize var7 to empty array of strings , var1 to empty string to integer map . for each position var3 in var0 if var1 has not key var0 [ var3 ] , set the value of var1 at var0 [ var3 ] to 0 and append " OK " to the end of var7 , otherwise set var5 to the value of var1 at var0 [ var3 ] plus 1 , append $$CONSTANT$$ concatenation of var0 [ var3 ] and var5 , converted to string , to the end of var7 and set the value of var1 at var0 [ var3 ] to var5 . 
given arrays of strings var0 and var7 , $$CONSTANT$$ string to integer map var1 and an integer var3 , if var1 has not key var0 [ var3 ] , set the value of var1 at var0 [ var3 ] to 0 and append " OK " to the end of var7 , otherwise set var5 to the value of var1 at var0 [ var3 ] plus 1 , append $$CONSTANT$$ concatenation of var0 [ var3 ] and var5 , converted to string , to the end of var7 and set the value of var1 at var0 [ var3 ] to var5 . 
given integers var0 , var1 , var3 , var4 and an array var2 of integer type . let var5 be the length of var2 . assign 0 to var6 , var8 . set var4 to its positive value . assign values $$CONSTANT$$ , 1 to var9 and var10 , respectively . for all var11 $$CONSTANT$$ from 1 to var11 < var5 do following operations . assign var5 - 1 to var7 . set var12 to the square root of the sum of values var3 - var2 [ var11 ] erected to the power of 2 and var4 erected to the power of 2 . assign the sum of real value of var2 [ var11 ] / var0 and var12 / var1 to var13 . if var13 is less than var9 then assign var13 to var9 and set var10 to var11 + 1 . otherwise , if var13 equals var9 and var2 [ var11 ] equals var3 then set var10 to $$CONSTANT$$ $$CONSTANT$$ 1 + 1 and set var9 to var13 . after the loop is ended , return var10 . 
you are given an array of strings var0 . you have to create an array of strings var7 initially empty . for each position var3 in var0 if string var0 [ var3 ] does not exist at some position less than var3 in var0 you have to add string " OK " to var7 , otherwise you have to add string var0 [ $$CONSTANT$$ ] plus the decimal representation of the number of positions less than var3 with the string var0 [ var3 ] in it to var7 . 
you are given an array of strings var0 , an array of strings var7 , an index var6 and an associative container var2 . you have to set var4 to var0 [ var6 ] and add 1 to var6 . if var2 contains to var4 as key you have to set var5 to the value of the key var4 in var2 , insert string var4 plus the decimal representation of var5 in var7 , set the value of key var4 to var5 + 1 in var2 , otherwise you have to insert the key var4 with the value 1 in var2 , insert the string " OK " to var7 . 
given char typed matrix var0 . create char typed matrix var6 . create the map var1 of key type of array of char type and the value type of integer . for all var3 $$CONSTANT$$ from 0 to length of var0 minus 1 do following operations . if the map var1 does not contain the key var0 [ var3 ] then add " OK " to the end of var6 and insert the value 1 with key var0 [ var3 ] into var1 . otherwise , add to the end of var6 the value var0 [ var3 ] and the value standing with key var0 [ var3 ] , and add 1 to the value standing with key var0 [ var3 ] in var1 . 
you are given an array of strings var0 . you have to create an array of strings var7 initially empty . for each position var3 in var0 if string var0 [ var3 ] does not exist at some position less than var3 in var0 you have to add string " OK " to var7 , otherwise you have to add string var0 [ $$CONSTANT$$ ] plus the decimal representation of the number of positions less than var3 with the string var0 [ var3 ] in it to var7 . you have to return var7 . 
given char typed matrix var0 . if the map var1 does not contain the key var0 [ var3 ] then add " OK " to the end of var6 and insert the value 1 with key var0 [ var3 ] into var1 . otherwise , add to the end of var6 the value var0 [ var3 ] and the value standing with key var0 [ var3 ] , and add 1 to the value standing with key var0 [ var3 ] in var1 . 
given char typed matrix var0 . create char typed matrix var6 . create the map var1 of key type of array of char type and the value type of integer . for all var3 $$CONSTANT$$ from 0 to length of var0 minus 1 do following operations . if the map var1 does not contain the key var0 [ var3 ] then add " OK " to the end of var6 and insert the value 1 with key var0 [ var3 ] into var1 . otherwise , add to the end of var6 the value var0 [ var3 ] and the value standing with key var0 [ var3 ] , and add 1 to the value standing with key var0 [ var3 ] in var1 . when the loop is ended , return var6 . 
given $$CONSTANT$$ map var2 with key of type string and value of type integer , an string array var1 , an integer var7 is equal in range from 0 to var0 - 1 , $$CONSTANT$$ string var3 is equal to var1 [ var7 ] . if var3 is not in var2 , than add into map var2 pair with key var3 and value 1 and assign string var4 to var4 concatenated with " OK \ n " . else an integer var5 is equal to minimal positive integer than var3 concatenated with integer var5 turned into string is not presented in map var2 . $$CONSTANT$$ string var6 is equal to var3 concatenated with integer var5 turned into string . add into map var2 pair with key var6 and value var5 + 1 . assign string var4 to var4 concatenated with var6 and " \ n " . 
given $$CONSTANT$$ map var2 with key of type string and value of type integer , an string array var1 , an integer var7 is equal in range from 0 to var0 - 1 , $$CONSTANT$$ string var3 is equal to var1 [ var7 ] . if var3 is not in var2 , than add into map var2 pair with key var3 and value 1 and assign string var4 to var4 concatenated with " OK \ n " . else an integer var5 is equal to minimal positive integer than var3 concatenated with integer var5 turned into string is not presented in map var2 . $$CONSTANT$$ string var6 is equal to var3 concatenated with integer var5 turned into string . add into map var2 pair with key var6 and value var5 + 1 . assign string var4 to var4 concatenated with var6 and " \ n " . 
you are given an array of numbers var1 , an array of numbers var2 ( indexing is 0 - based ) and $$CONSTANT$$ number var0 . you have to set var4 to zero . for each var5 in var1 if var4 is less than var1 [ var5 ] you have to return " NO " , you have to store in var4 the maximum between var4 and var2 [ var5 ] . after the loop ends , if var4 is equal to var0 you have to return " YES " and " NO " otherwise . 
you are given an array of numbers var1 and an array of numbers var2 ( indexing is 0 - based ) . you have to create an array of strings var10 and you have to set var4 to zero . for each var5 in var1 if var4 is less than var1 [ var5 ] you have to insert string " NO " to var10 and return var10 , you have to store in var4 the maximum between var4 and var2 [ var5 ] . 
given $$CONSTANT$$ map var2 with key of type string and value of type integer , an string array var1 , an integer var7 is equal in range from 0 to var0 - 1 , $$CONSTANT$$ string var3 is equal to var1 [ var7 ] . if var3 is not in var2 , than add into map var2 pair with key var3 and value 1 and assign string var4 to var4 concatenated with " OK \ n " . else an integer var5 is equal to minimal positive integer than var3 concatenated with integer var5 turned into string is not presented in map var2 . $$CONSTANT$$ string var6 is equal to var3 concatenated with integer var5 turned into string . add into map var2 pair with key var6 and value var5 + 1 . assign string var4 to var4 concatenated with var6 and " \ n " . return var4 . 
you are given an array of numbers var1 , an array of numbers var2 , an array of strings var10 , an index var8 , an index var9 and $$CONSTANT$$ number var4 . if var4 is less than var1 [ var8 ] you have to insert string " NO " to var10 and return var10 . you have to add 1 to var8 . you have to set var7 to var2 [ var9 ] and add 1 to var9 . you have to store in var4 the maximum between var4 and var7 . 
you are given an array of numbers var1 , an array of numbers var2 , an array of strings var10 , an index var8 , an index var9 and $$CONSTANT$$ number var4 . if var4 is less than var1 [ var8 ] you have to insert string " NO " to var10 and return var10 . you have to add 1 to var8 . you have to set var7 to var2 [ var9 ] and add 1 to var9 . 
you are given an array of numbers var1 , an array of strings var10 , an index var8 and $$CONSTANT$$ number var4 . if var4 is less than var1 [ var8 ] you have to insert string " NO " to var10 and return var10 . you have to add 1 to var8 . 
given arrays var1 , var2 and an integer var0 . initialize var4 to an array . for each var6 in var1 and var7 in var2 , perform the following operations . initialize var8 to var6 + 1 . while var8 is not greater than var7 and var0 , set var4 [ var8 ] to true and increase var8 by 1 . if at least one element of var4 is false , return " NO " ; else return " YES " . 
given arrays var1 , var2 and an integer var0 . initialize var4 to an array . for each var6 in var1 and var7 in var2 , perform the following operations . initialize var8 to var6 + 1 . while var8 is not greater than var7 and var0 , set var4 [ var8 ] to true and increase var8 by 1 . 
given arrays var1 , var2 , var4 and integers var5 , var0 , var11 , var12 . initialize var6 to var1 [ var11 ] , var2 [ var12 ] , var8 to var6 + 1 . while var8 is not greater than var7 and var0 , set var4 [ var8 ] to true and increase var8 by 1 . 
given integers var0 , var1 , var2 , var3 , var4 . assign the values ( 2 * var2 ) + var3 to var5 , ( 3 * var4 ) + var3 to var6 , 0 to var7 . if var5 exceeds var0 then add ( ( 2 * var2 ) + var3 ) - var0 to var7 . if var6 exceeds var1 then add ( ( 3 * var4 ) + var3 ) - var1 to var7 . return var7 . 
given integers var0 , var1 , var2 , var3 , var4 . assign the values ( 2 * var2 ) + var3 to var5 , ( 3 * var4 ) + var3 to var6 , 0 to var7 . if var5 exceeds var0 then add ( ( 2 * var2 ) + var3 ) - var0 to var7 . if var6 exceeds var1 then add ( ( 3 * var4 ) + var3 ) - var1 to var7 . 
given integers var0 , var1 , var2 , var3 , var4 . assign the values ( 2 * var2 ) + var3 to var5 , ( 3 * var4 ) + var3 to var6 , 0 to var7 . if var5 exceeds var0 then add ( ( 2 * var2 ) + var3 ) - var0 to var7 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to 2 * var2 + var3 . set var6 to 3 * var4 + var3 . set var7 to zero . if var0 is less than var5 set var7 to var5 - var0 . if var1 is less than var6 - var1 add var6 - var1 to var7 . you have to return var7 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to 2 * var2 + var3 . set var6 to 3 * var4 + var3 . set var7 to zero . if var0 is less than var5 set var7 to var5 - var0 . if var1 is less than var6 - var1 add var6 - var1 to var7 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to 2 * var2 + var3 . set var6 to 3 * var4 + var3 . set var7 to zero . if var0 is less than var5 set var7 to var5 - var0 . 
given integers var0 , var1 . assign the values var0 / $$CONSTANT$$ , min % $$CONSTANT$$ to var2 and to var3 , respectively . add 1 to var4 . assign 0 var4 . as long as each of values var2 % 10 , var3 % 10 does not equal 7 , do following operations . if after substracting var1 from var0 , var0 will exceed 0 then substract var1 from var0 . otherwise , assign to var0 the value 1440 - ( var1 - var0 ) . assign the values var0 / $$CONSTANT$$ , min % $$CONSTANT$$ to var2 and to var3 , respectively . add 1 to var4 . 
given integers var0 , var1 . if after substracting var1 from var0 , var0 will exceed 0 then substract var1 from var0 . otherwise , assign to var0 the value 1440 - ( var1 - var0 ) . assign the values var0 / $$CONSTANT$$ , min % $$CONSTANT$$ to var2 and to var3 , respectively . add 1 to var4 . 
given integers var0 , var1 . assign the values var0 / $$CONSTANT$$ , min % $$CONSTANT$$ to var2 and to var3 , respectively . add 1 to var4 . assign 0 var4 . as long as each of values var2 % 10 , var3 % 10 does not equal 7 , do following operations . if after substracting var1 from var0 , var0 will exceed 0 then substract var1 from var0 . otherwise , assign to var0 the value 1440 - ( var1 - var0 ) . assign the values var0 / $$CONSTANT$$ , min % $$CONSTANT$$ to var2 and to var3 , respectively . add 1 to var4 . when the loop is ended , return var4 . 
given integer var0 , array of integers var1 . create an empty array of string var8 , initialize var2 to length of var1 , initialize var3 to 0 , create array of real numbers var4 having length $$CONSTANT$$ , for all var5 from 0 to var2 exclusive do following : initialize var6 to var0 , for all var7 from max ( 1 , var1 [ var5 ] - 2 * var0 ) to min ( $$CONSTANT$$ , var1 [ var5 ] + 2 * var0 ) inclusive if var4 [ var7 ] is greater than 0 then if $$CONSTANT$$ ( ( 4 * var0 * var0 ) - ( var7 - var1 [ var5 ] ) * ( var7 - var1 [ var5 ] ) ) + var4 [ var7 ] is greater then var6 then update var6 with this value , append var6 converted to string to the end of var8 , assign var6 to var4 [ var1 [ var5 ] ] . 
given integer var0 , array of integers var1 , its index var5 , array of real numbers var4 , array of strings var8 . initialize var6 to var0 , for all var7 from max ( 1 , var1 [ var5 ] - 2 * var0 ) to min ( $$CONSTANT$$ , var1 [ var5 ] + 2 * var0 ) inclusive if var4 [ var7 ] is greater than 0 then if $$CONSTANT$$ ( ( 4 * var0 * var0 ) - ( var7 - var1 [ var5 ] ) * ( var7 - var1 [ var5 ] ) ) + var4 [ var7 ] is greater then var6 then update var6 with this value , append var6 converted to string to the end of var8 , assign var6 to var4 [ var1 [ var5 ] ] . 
given integer var0 , array of integers var1 , its index var5 , array of real numbers var4 . initialize var6 to var0 , for all var7 from max ( 1 , var1 [ var5 ] - 2 * var0 ) to min ( $$CONSTANT$$ , var1 [ var5 ] + 2 * var0 ) inclusive if var4 [ var7 ] is greater than 0 then if $$CONSTANT$$ ( ( 4 * var0 * var0 ) - ( var7 - var1 [ var5 ] ) * ( var7 - var1 [ var5 ] ) ) + var4 [ var7 ] is greater then var6 then update var6 with this value . 
given array var2 of char type . assign 0 to var3 . let var3 be the number of positions var4 in var2 such that var2 [ var4 ] equals one of values 97 , $$CONSTANT$$ , 105 , 111 , 117 or var2 [ var4 ] is odd digit less than 10 . 
given integer var0 and char typed array var1 . assign var1 to var2 . let var4 be the number of elements from var2 which appear in the string " $$CONSTANT$$ " . 
you are given $$CONSTANT$$ string var0 . you have to create an object var1 . you have to set var2 to zero . for each position var3 in var0 you have to , set var4 to var0 [ var3 ] , if var4 is greater than or equal to 48 and var4 is less than or equal 57 you have to , set number var5 to var4 - 48 , if var5 is not divisible by 2 , add 1 to var2 and insert var4 to var1 ; if var4 is equal to 97 or var4 is equal to $$CONSTANT$$ or var4 is equal to 105 or var4 is equal to 111 or var4 is equal to 117 , add 1 to var2 . 
you are given $$CONSTANT$$ string var0 , $$CONSTANT$$ number var2 , an object var1 , an index var3 . set var4 to var0 [ var3 ] . if var4 is greater than or equal to 48 and var4 is less than or equal 57 you have to , set number var5 to var4 - 48 , if var5 is not divisible by 2 , add 1 to var2 and insert var4 to var1 . if var4 is equal to 97 or var4 is equal to $$CONSTANT$$ or var4 is equal to 105 or var4 is equal to 111 or var4 is equal to 117 , add 1 to var2 . 
you are given $$CONSTANT$$ string var0 , $$CONSTANT$$ number var2 , an object var1 , an index var3 . set var4 to var0 [ var3 ] . if var4 is greater than or equal to 48 and var4 is less than or equal 57 you have to , set number var5 to var4 - 48 , if var5 is not divisible by 2 , add 1 to var2 and insert var4 to var1 . 
you are given $$CONSTANT$$ character var4 , $$CONSTANT$$ number var2 , an object var1 . you have to set number var5 to var4 - 48 . if var5 is not divisible by 2 , add 1 to var2 and insert var4 to var1 . 
you are given $$CONSTANT$$ string var0 . you have to set string var1 to characters with asci code 97 , $$CONSTANT$$ , 105 , 111 , 117 , $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ , 57 . you have to store in var3 the number of positions in var0 with $$CONSTANT$$ character also present in var1 . 
given integer var0 and char typed array var1 . assign var1 to var2 . return the number of elements from var2 which appear in the string " $$CONSTANT$$ " . 
you are given $$CONSTANT$$ string var2 , $$CONSTANT$$ string var1 , $$CONSTANT$$ number var3 and an index var4 . you have to set var5 to var2 [ var4 ] . for each character var6 in var1 if var6 is equal to var5 you have to add 1 to var3 and break from the enclosing loop . 
given integers var0 , var1 . initialize var2 to 0 , var3 to var0 , var4 to 1 . while var0 is greater than 0 , add 1 to var2 and divide var0 by 2 . 
you are given an integer var0 . assign the values var0 % $$CONSTANT$$ , var0 / $$CONSTANT$$ to var1 and var2 , respectively . if var1 is negative value then increment var1 by $$CONSTANT$$ and decrement var2 . otherwise , do nothing . if var2 is negative value then increase var2 by $$CONSTANT$$ . otherwise , do nothing . 
you are given integers var6 , var7 , var8 . initialize var9 with value var7 * $$CONSTANT$$ + mm . assign 0 to var10 . while the result of function func0 ( var9 ) is false , increment var10 and decrease var9 by var6 . when func0 ( var9 ) is true , exit from the loop and return var10 . 
you are given integers var6 , var7 , var8 . initialize var9 with value var7 * $$CONSTANT$$ + mm . assign 0 to var10 . while the result of function func0 ( var9 ) is false , increment var10 and decrease var9 by var6 . 
you are given an integer var0 . assign the values var0 % $$CONSTANT$$ , var0 / $$CONSTANT$$ to var1 and var2 , respectively . if var1 is negative value then increment var1 by $$CONSTANT$$ and decrement var2 . otherwise , do nothing . if var2 is negative value then increase var2 by $$CONSTANT$$ . otherwise , do nothing . if at least one of the values var2 % 10 , var1 % 10 equal to 7 then return true . otherwise , return false . 
you are given an integer var0 . assign the values var0 % $$CONSTANT$$ , var0 / $$CONSTANT$$ to var1 and var2 , respectively . if var1 is negative value then increment var1 by $$CONSTANT$$ and decrement var2 . otherwise , do nothing . 
given integers var0 , var1 . initialize var2 to 0 , var3 to var0 , var4 to 1 . while var0 is greater than 0 , add 1 to var2 and divide var0 by 2 . if var1 equals 1 , return var3 ; else shift last var2 bits of var4 to the $$CONSTANT$$ and return var2 - 1 . 
given an array of integers var2 and integers var0 , var1 , var6 , var5 and var4 , add var2 [ var6 ] to var5 if var5 + var2 [ var6 ] < = var0 , add 1 to var4 and set var5 to var2 [ var6 ] otherwise , add var5 / var1 ( rounded down ) to var4 and set var5 to var5 % var1 . 
given an array of integers var2 and integers var0 , var6 , var5 and var4 , add var2 [ var6 ] to var5 if var5 + var2 [ var6 ] < = var0 , add 1 to var4 and set var5 to var2 [ var6 ] otherwise . 
given array var2 of char type . assign 0 to var3 . return the number of positions var4 in var2 such that var2 [ var4 ] equals one of values 97 , $$CONSTANT$$ , 105 , 111 , 117 or var2 [ var4 ] is odd digit less than 10 . 
you are given $$CONSTANT$$ number var6 and $$CONSTANT$$ number var3 . set var7 to 1 , var8 to 2 and subtract 1 to var3 . for each var9 between $$CONSTANT$$ and 0 , if the value of the function func0 at the arguments var9 and var3 is less than var6 you have to , add the var9 power of var8 to var7 , subtract the value of the function func0 at the arguments var9 and var3 to var6 , subtract 1 to var3 . you have to return var7 . 
you are given $$CONSTANT$$ string var0 . you have to set var2 to zero . for each position var3 in var0 you have to , set var4 to var0 [ var3 ] , if var4 is greater than or equal to 48 and var4 is less than or equal 57 you have to , set number var5 to var4 - 48 , if var5 is not divisible by 2 , add 1 to var2 ; if var4 is equal to 97 or var4 is equal to $$CONSTANT$$ or var4 is equal to 105 or var4 is equal to 111 or var4 is equal to 117 , add 1 to var2 . you have to return var2 . 
given integers var0 , var1 . initialize var2 to var0 , var3 to var1 , var4 to $$CONSTANT$$ two - dimensional array . initialize var5 to 0 . set var4 [ 0 ] [ 0 ] to var3 . for each var6 from 0 to var2 exclusive and var7 from 0 to var6 , if var4 [ var6 ] [ var7 ] is not less than 1 , perform the following operations . increase var5 by 1 . add ( var4 [ var6 ] [ var7 ] - 1 ) * 0 . 5 to var4 [ $$CONSTANT$$ + 1 ] [ var7 ] and var4 [ $$CONSTANT$$ + 1 ] [ $$CONSTANT$$ + 1 ] . 
given an array var4 and integers var6 , var5 . for each var7 from 0 to var6 , if var4 [ var6 ] [ var7 ] is not less than 1 , perform the following operations . increase var5 by 1 . add ( var4 [ var6 ] [ var7 ] - 1 ) * 0 . 5 to var4 [ $$CONSTANT$$ + 1 ] [ var7 ] and var4 [ $$CONSTANT$$ + 1 ] [ $$CONSTANT$$ + 1 ] . 
you are given an array of numbers var1 , an array of numbers var2 , and $$CONSTANT$$ number var0 . you have to set var4 to 1 and var5 to var0 . for each position var6 in var1 , you have to store in var5 the minimum between var5 and the maximum between var1 [ var6 ] and var2 [ var6 ] . you have to store in var4 the maximum between var4 and the minimum between var1 [ var6 ] and var2 [ var6 ] . 
you are given an array of numbers var1 , an array of numbers var2 , and $$CONSTANT$$ number var0 . you have to set var4 to 1 and var5 to var0 . for each position var6 in var1 , you have to store in var5 the minimum between var5 and the maximum between var1 [ var6 ] and var2 [ var6 ] . you have to store in var4 the maximum between var4 and the minimum between var1 [ var6 ] and var2 [ var6 ] . you have to return the maximum between 0 and var5 - var4 . 
given arrays var1 , var2 and an integer var0 . initialize var4 to an array . for each var6 in var1 and var7 in var2 , perform the following operations . initialize var8 to var6 + 1 . while var8 is not greater than var7 and var0 , set var4 [ var8 ] to true and increase var8 by 1 . if at least one element of var4 is false , return " NO " ; else return " YES " . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . set var2 to 1 . for each var3 between 0 and var1 - 1 set var2 to ( var2 * ( var0 - var3 ) ) divided by ( var3 + 1 ) ( rounded down ) . 
given integers var0 , var1 . initialize var2 to var0 , var3 to var1 , var4 to $$CONSTANT$$ two - dimensional array . initialize var5 to 0 . set var4 [ 0 ] [ 0 ] to var3 . for each var6 from 0 to var2 exclusive and var7 from 0 to var6 , if var4 [ var6 ] [ var7 ] is not less than 1 , perform the following operations . increase var5 by 1 . add ( var4 [ var6 ] [ var7 ] - 1 ) * 0 . 5 to var4 [ $$CONSTANT$$ + 1 ] [ var7 ] and var4 [ $$CONSTANT$$ + 1 ] [ $$CONSTANT$$ + 1 ] . return var5 . 
you are given $$CONSTANT$$ matrix of characters var0 . you have to set var4 to " " . for each $$CONSTANT$$ var5 in var0 you have to set var6 to " X " , and for each row var7 in var0 if var0 [ var7 ] [ var5 ] is different to " ? " ; if var6 is equal to " X " you have to set var6 to var0 [ var7 ] [ var5 ] , otherwise if var6 is different to var0 [ var7 ] [ var5 ] you have to set var6 to " ? " and break from the enclosing loop . if var6 is equal to " X " you have to concatenate $$CONSTANT$$ character " $$CONSTANT$$ " to var4 , otherwise you have to concatenate character var6 to var4 . 
you are given $$CONSTANT$$ matrix of characters var0 . you have to set var4 to " " . for each $$CONSTANT$$ var5 in var0 you have to set var6 to " X " , and for each row var7 in var0 if var0 [ var7 ] [ var5 ] is different to " ? " ; if var6 is equal to " X " you have to set var6 to var0 [ var7 ] [ var5 ] , otherwise if var6 is different to var0 [ var7 ] [ var5 ] you have to set var6 to " ? " and break from the enclosing loop . if var6 is equal to " X " you have to concatenate $$CONSTANT$$ character " $$CONSTANT$$ " to var4 , otherwise you have to concatenate character var6 to var4 . you have to return var4 . 
you are given an array of strings var0 , an index var5 , $$CONSTANT$$ var4 string and $$CONSTANT$$ number var1 . you have to set var6 to " X " . for each var7 between 0 and var1 - 1 if var0 [ var7 ] [ var5 ] is different to " ? " ; if var6 is equal to " X " you have to set var6 to var0 [ var7 ] [ var5 ] , otherwise if var6 is different to var0 [ var7 ] [ var5 ] you have to set var6 to " ? " and break from the enclosing loop . if var6 is equal to " X " you have to concatenate $$CONSTANT$$ character " $$CONSTANT$$ " to var4 , otherwise you have to concatenate character var6 to var4 . 
you are given an array of strings var0 , an index var5 and $$CONSTANT$$ number var1 . you have to set var6 to " X " . for each var7 between 0 and var1 - 1 if var0 [ var7 ] [ var5 ] is different to " ? " ; if var6 is equal to " X " you have to set var6 to var0 [ var7 ] [ var5 ] , otherwise if var6 is different to var0 [ var7 ] [ var5 ] you have to set var6 to " ? " and break from the enclosing loop . 
you are given an array of strings var0 , an index var7 , an index var5 , $$CONSTANT$$ character var6 . if var0 [ var7 ] [ var5 ] is different to " ? " ; if var6 is equal to " X " you have to set var6 to var0 [ var7 ] [ var5 ] , otherwise if var6 is different to var0 [ var7 ] [ var5 ] you have to set var6 to " ? " and break from the enclosing loop . 
you are given an array of strings var0 . you have to set var1 to the length of var0 . you have to set var3 to the length of var0 [ 0 ] . 
you are given an array of strings var0 . you have to set var1 to the length of var0 . 
you are given an array of strings var0 . you have to set var4 to 7 . for each position ( var5 , var6 ) in var0 with var6 greater than var6 you have to set var3 to zero , for each var7 between 0 and 5 if var0 [ var5 ] [ var7 ] is different to var0 [ var6 ] [ var7 ] you have to add 1 to var3 , you have to store in var4 the minimum between var4 and var3 . 
given array of integer var0 . initialize var3 to the number of different values in var0 . create set of integers var6 , iterate over var0 from back to front and for each element if var3 equals to 1 and this element is not present in var6 return it . otherwise if this element is not present in var6 put it into var6 and decrease var3 by 1 . 
given array of integer var0 . initialize var3 to 0 , create array var2 equal to var0 , create set of integers var4 , for each element in var2 if it is not present in var4 put it into var4 and increase var3 by 1 . create set of integers var6 , initialize var7 to length of var0 minus 1 . 
given array of integer var0 . initialize var1 to length of var0 , initialize var3 to 0 , create array var2 equal to var0 , create set of integers var4 , for each element in var2 if it is not present in var4 put it into var4 and increase var3 by 1 . 
given array of integers var2 , its index var7 , set of integers var6 , integer var3 . if var3 equals to 1 and var2 [ var7 ] is not present in var6 return var2 [ var7 ] . otherwise if var2 [ var7 ] is not present in var6 put it into var6 and decrease var3 by 1 . 
given arrays of integers var0 and var2 , indexes var9 and var5 , set of integers var4 , integer var3 . initialize var2 [ var5 ] to var0 [ var9 ] , increase var9 by 1 , if var2 [ var5 ] is not present in var4 put it into var4 and increase var3 by 1 . 
given $$CONSTANT$$ string var0 . initialize var1 to the number of vowels and odd digits in var0 . 
given integers var0 and var1 , initialize var3 to empty array of integers . append var0 to the end of var3 and return var3 if var1 = 1 . append 1 to the end of var3 and return var3 if var0 = 1 . find the $$CONSTANT$$ power of 2 , which is greater than var0 and store the result in var2 . 
given integers var0 and var1 , initialize var3 to empty array of integers . append var0 to the end of var3 and return var3 if var1 = 1 , append 1 to the end of var3 and return var3 if var0 = 1 . 
given integers var0 and var1 , initialize var3 to empty array of integers . append var0 to the end of var3 and return var3 if var1 = 1 , append 1 to the end of var3 and return var3 if var0 = 1 . 
given integers var0 and var1 , initialize var3 to empty array of integers . append var0 to the end of var3 and return var3 if var1 = 1 . 
given integers var0 and var1 , initialize var3 to empty array of integers . append var0 to the end of var3 and return var3 if var1 = 1 . append 1 to the end of var3 and return var3 if var0 = 1 . find the $$CONSTANT$$ power of 2 , which is greater than var0 and store the result in var2 . append var2 - 1 to the end of var3 and return var3 . 
given var0 , var1 , var2 , var3 and var4 with var5 and var6 defined as : var5 = var2 * 2 + var3 var6 = var4 * 3 + var3 what is the minimum integer x to be added to ( var0 + var1 ) such that it is greater than or equal to ( var5 + var6 ) ? return the answer . 
given var0 , var1 , var2 , var3 and var4 with var5 and var6 defined as : var5 = var2 * 2 + var3 var6 = var4 * 3 + var3 what is the minimum integer x to be added to ( var0 + var1 ) such that it is greater than or equal to ( var5 + var6 ) ? 
given var0 , var1 , var2 , var3 and var4 with var5 and var6 defined as : var5 = var2 * 2 + var3 var6 = var4 * 3 + var3 what is the minimum integer to be added to var0 such that it is greater than or equal to var5 ? 
given integers var0 , var1 , var2 . initialize var3 to 0 . while true , perform the following operations . initialize var4 to var2 modulo 10 . if var4 equals 7 , break the loop . set var4 to var1 modulo 10 . if var4 equals 7 , break the loop . subtract var0 from var2 . increase var3 by 1 . if var2 is less than 0 , perform the following operations . add $$CONSTANT$$ to var2 . decrease var1 by 1 . if var1 is less than 0 , add $$CONSTANT$$ to var1 . 
given integers var0 , var1 , var2 , var3 . initialize var4 to var2 modulo 10 . if var4 equals 7 , break the loop . set var4 to var1 modulo 10 . if var4 equals 7 , break the loop . subtract var0 from var2 . increase var3 by 1 . if var2 is less than 0 , perform the following operations . add $$CONSTANT$$ to var2 . decrease var1 by 1 . if var1 is less than 0 , add $$CONSTANT$$ to var1 . 
given integers var0 , var1 , var2 , var3 . initialize var4 to var2 modulo 10 . if var4 equals 7 , break the loop . set var4 to var1 modulo 10 . if var4 equals 7 , break the loop . subtract var0 from var2 . increase var3 by 1 . 
given integers var0 , var1 , var2 . initialize var4 to var2 modulo 10 . if var4 equals 7 , break the loop . set var4 to var1 modulo 10 . if var4 equals 7 , break the loop . 
given integers var0 , var1 , var2 . initialize var3 to 0 . while true , perform the following operations . initialize var4 to var2 modulo 10 . if var4 equals 7 , break the loop . set var4 to var1 modulo 10 . if var4 equals 7 , break the loop . subtract var0 from var2 . increase var3 by 1 . if var2 is less than 0 , perform the following operations . add $$CONSTANT$$ to var2 . decrease var1 by 1 . if var1 is less than 0 , add $$CONSTANT$$ to var1 . return var3 . 
given integers var0 , var1 , var2 . initialize var4 to var2 modulo 10 . if var4 equals 7 , break the loop . set var4 to var1 modulo 10 . 
given integers var0 , var1 , var2 , var3 . add $$CONSTANT$$ to var2 . decrease var1 by 1 . if var1 is less than 0 , add $$CONSTANT$$ to var1 . 
given integers var0 , var1 , var2 . initialize var4 to var2 modulo 10 . if var4 equals 7 , break the loop . 
given an integer var0 , find the $$CONSTANT$$ power of 2 , which is greater than var0 . store the result in var2 . 
given number var0 . store the $$CONSTANT$$ power of two bigger than var0 into var2 . 
given an integer var0 , find the $$CONSTANT$$ power of 2 , which is greater than var0 . return the result , decreased by 1 . 
given integer var0 , array of integers var1 . create an empty array of string var8 , initialize var2 to length of var1 , initialize var3 to 0 , create array of real numbers var4 having length $$CONSTANT$$ , for all var5 from 0 to var2 exclusive do following : initialize var6 to var0 , for all var7 from max ( 1 , var1 [ var5 ] - 2 * var0 ) to min ( $$CONSTANT$$ , var1 [ var5 ] + 2 * var0 ) inclusive if var4 [ var7 ] is greater than 0 then if $$CONSTANT$$ ( ( 4 * var0 * var0 ) - ( var7 - var1 [ var5 ] ) * ( var7 - var1 [ var5 ] ) ) + var4 [ var7 ] is greater then var6 then update var6 with this value , append var6 converted to string to the end of var8 , assign var6 to var4 [ var1 [ var5 ] ] . return var8 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . you have to , set var5 to var2 * 2 , set var6 to var4 * 3 , add var3 to var5 , add var3 to var6 , set var7 to zero . if var5 is greater than var0 set var7 to var5 - var0 . you have to return var7 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . you have to , set var5 to var2 * 2 , set var6 to var4 * 3 , add var3 to var5 , add var3 to var6 , set var7 to zero . if var5 is greater than var0 set var7 to var5 - var0 . if var6 is greater than var1 add var6 - var1 to var7 . 
given $$CONSTANT$$ string var0 . initialize var1 to the number of vowels and odd digits in var0 . return var1 . 
given integers var0 and var1 . if var1 is not smaller than two return $$CONSTANT$$ power of two bigger than var0 minus one , otherwise return var0 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . you have to , set var5 to var2 * 2 , set var6 to var4 * 3 , add var3 to var5 , add var3 to var6 , set var7 to zero . if var5 is greater than var0 set var7 to var5 - var0 . 
given integers var0 , var1 , var2 , var3 , var4 . initialize result to 0 . if var0 is less than var2 * 2 + y then add var2 * 2 + y - var0 to result . if var1 is less than y + 3 * $$CONSTANT$$ then add the value y + 3 * $$CONSTANT$$ - var1 to result . return the result . 
given integers var0 , var1 , var2 , var3 , var4 . initialize result to 0 . if var0 is less than var2 * 2 + y then add var2 * 2 + y - var0 to result . if var1 is less than y + 3 * $$CONSTANT$$ then add the value y + 3 * $$CONSTANT$$ - var1 to result . 
given integers var0 , var1 , var2 , var3 , var4 . initialize result to 0 . if var0 is less than var2 * 2 + y then add var2 * 2 + y - var0 to result . 
given integers var0 , var1 and var2 , initialize var7 to empty array of integers , var3 to 0 , var4 to concatenation of string representation of var1 and string representation of var2 . append 0 to the end of var7 if there is at least one occurrence of " 7 " in var6 , otherwise initialize var5 to 1 , for as long as var5 > 0 , if var2 - var0 > = 0 , then substract var0 from var2 , otherwise set var2 to var2 - var0 + $$CONSTANT$$ , decrease var1 by 1 if var1 > = 1 , set var1 to 23 otherwise ; increase var3 by 1 and set var6 to concatenation of string representation of var1 and string representation of var2 ; push var3 to the end of var7 and set var5 to 0 if there is at least one occurrence of " 7 " in var6 . 
given $$CONSTANT$$ map var2 with key of type string and value of type integer , an string array var1 , an integer var7 is equal in range from 0 to var0 - 1 , $$CONSTANT$$ string var3 is equal to var1 [ var7 ] . an integer var5 is equal to minimal positive integer than var3 concatenated with integer var5 turned into string is not presented in map var2 . $$CONSTANT$$ string var6 is equal to var3 concatenated with integer var5 turned into string . insert into map var2 pair with key var6 and value var5 + 1 . assign string var4 to var4 concatenated with var6 and " \ n " . 
given $$CONSTANT$$ map var2 with key of type string and value of type integer , an string array var1 , an integer var7 is equal in range from 0 to var0 - 1 , $$CONSTANT$$ string var3 is equal to var1 [ var7 ] . an integer var5 is equal to minimal positive integer than var3 concatenated with integer var5 turned into string is not presented in map var2 . 
given integers var0 , var1 and var2 , initialize var7 to empty array of integers , var3 to 0 , var4 to concatenation of string representation of var1 and string representation of var2 . append 0 to the end of var7 if there is at least one occurrence of " 7 " in var6 , otherwise initialize var5 to 1 , for as long as var5 > 0 , if var2 - var0 > = 0 , then substract var0 from var2 , otherwise set var2 to var2 - var0 + $$CONSTANT$$ , decrease var1 by 1 if var1 > = 1 , set var1 to 23 otherwise ; increase var3 by 1 and set var6 to concatenation of string representation of var1 and string representation of var2 ; push var3 to the end of var7 and set var5 to 0 if there is at least one occurrence of " 7 " in var6 . return var7 . 
given an array var1 and an integer var0 . initialize var3 to an empty array of length var0 . for each var4 from 0 to the length of var1 - 1 , add var1 [ var4 ] to var3 [ var4 modulo var0 ] . initialize var6 to the minimum element in var3 and var5 to the index of this minumum . 
given an array var1 and an integer var0 . initialize var3 to an empty array of length var0 . for each var4 from 0 to the length of var1 - 1 , add var1 [ var4 ] to var3 [ var4 modulo var0 ] . initialize var5 to - 1 . 
given an array var1 and an integer var0 . initialize var3 to an empty array of length var0 . for each var4 from 0 to the length of var1 - 1 , add var1 [ var4 ] to var3 [ var4 modulo var0 ] . 
given integer var2 and 0 - based , integer typed array var1 . create an integer typed array var3 of size var0 . assign 0 to result . for all var6 $$CONSTANT$$ from 0 to n - 1 , add var1 [ var6 ] to var3 [ $$CONSTANT$$ % $$CONSTANT$$ ] . let the result be the $$CONSTANT$$ position containing the minimum value in var3 . 
given integer var2 and 0 - based , integer typed array var1 . create an integer typed array var3 of size var0 . assign 0 to result . for all var6 $$CONSTANT$$ from 0 to n - 1 , add var1 [ var6 ] to var3 [ $$CONSTANT$$ % $$CONSTANT$$ ] . assign var3 [ 0 ] to var7 . 
given integer var2 and 0 - based , integer typed array var1 . create an integer typed array var3 of size var0 . assign 0 to result . for all var6 $$CONSTANT$$ from 0 to n - 1 , add var1 [ var6 ] to var3 [ $$CONSTANT$$ % $$CONSTANT$$ ] . assign var3 [ 0 ] to var7 . 
given an array var1 and an integer var0 . initialize var3 to an empty array of length var0 . for each var4 from 0 to the length of var1 - 1 , add var1 [ var4 ] to var3 [ var4 modulo var0 ] . initialize var6 to the minimum element in var3 and var5 to the index of this minumum . return var5 + 1 . 
given integer var2 and 0 - based , integer typed array var1 . create an integer typed array var3 of size var0 . assign 0 to result . for all var6 $$CONSTANT$$ from 0 to n - 1 , add var1 [ var6 ] to var3 [ $$CONSTANT$$ % $$CONSTANT$$ ] . 
given integer var2 and 0 - based , integer typed array var1 . create an integer typed array var3 of size var0 . assign 0 to result . for all var6 $$CONSTANT$$ from 0 to n - 1 , add var1 [ var6 ] to var3 [ $$CONSTANT$$ % $$CONSTANT$$ ] . let the result be the $$CONSTANT$$ position containing the minimum value in var3 . return the result increased by 1 . 
you are given an array of strings var0 , an index var5 , $$CONSTANT$$ number var4 , $$CONSTANT$$ number var1 . for each var6 between var5 + 1 and var1 - 1 , you have to set var3 to zero , for each var7 between 0 and 5 if var0 [ var5 ] [ var7 ] is different to var0 [ var6 ] [ var7 ] you have to add 1 to var3 , you have to store in var4 the minimum between var4 and var3 . 
you are given an array of strings var0 , an index var5 , an index var6 , $$CONSTANT$$ number var4 . you have to set var3 to zero . for each var7 between 0 and 5 if var0 [ var5 ] [ var7 ] is different to var0 [ var6 ] [ var7 ] you have to add 1 to var3 . you have to store in var4 the minimum between var4 and var3 . 
you are given an array of strings var0 , an index var5 , an index var6 . you have to set var3 to zero . for each var7 between 0 and 5 if var0 [ var5 ] [ var7 ] is different to var0 [ var6 ] [ var7 ] you have to add 1 to var3 . 
given an integer var0 and an array of strings var1 . initialize var2 to the length of var1 , var4 to 1 , var5 to var0 / 2 . for each var6 from var2 - 2 to 0 , perform the following operations . if var1 [ var6 ] equals " half " , add var4 * var0 to var5 and multiply var4 by 2 ; else add ( var4 * var0 + var0 / 2 ) to var5 , multiply var4 by 2 and increase var4 by 1 . 
given an integer var0 and an array of strings var1 . initialize var2 to the length of var1 , var4 to 1 , var5 to var0 / 2 . for each var6 from var2 - 2 to 0 , perform the following operations . if var1 [ var6 ] equals " half " , add var4 * var0 to var5 and multiply var4 by 2 ; else add ( var4 * var0 + var0 / 2 ) to var5 , multiply var4 by 2 and increase var4 by 1 . return var5 . 
you are given an array of strings var0 . you have to set var4 to 7 . for each position ( var5 , var6 ) in var0 with var6 greater than var6 you have to set var3 to zero , for each var7 between 0 and 5 if var0 [ var5 ] [ var7 ] is different to var0 [ var6 ] [ var7 ] you have to add 1 to var3 , you have to store in var4 the minimum between var4 and var3 . if the length of var0 is equal to 1 you have to return 6 . if var4 is divisible by 2 you have to return ( var4 divided by 2 ) - 1 , otherwise you have to return ( var4 - 1 ) divided by 2 . 
given integers var1 and var2 . initialize var3 to 0 , for each $$CONSTANT$$ from 1 to var1 inclusive add ( ( ( ( var4 * var2 ) + 1 ) % $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main2 . mod ) * ( ( ( var2 * ( var2 - 1 ) ) / 2 ) % $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main2 . mod ) ) % $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main2 . mod to var3 and replace the value of var3 with var3 % $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main2 . mod , return var3 . 
given integers var1 and var2 . initialize var3 to 0 , for each var4 from 1 to var1 inclusive add ( ( ( ( var4 * var2 ) + 1 ) % $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main2 . mod ) * ( ( ( var2 * ( var2 - 1 ) ) / 2 ) % $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main2 . mod ) ) % $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main2 . mod to var3 and replace the value of var3 with var3 % $$CONSTANT$$ $$CONSTANT$$ globals $$CONSTANT$$ $$CONSTANT$$ . main2 . mod . 
given integers var2 and var3 . initialize var6 to zero . initialize var7 to ( var3 - 1 ) times var5 divided by two rounded down modulo $$CONSTANT$$ . for each var8 between 1 and var2 inclusive , starting from 1 , add ( var7 * ( ( ( var5 * var8 ) + 1 ) modulo $$CONSTANT$$ ) ) to var6 . take modulo of var6 by $$CONSTANT$$ . 
given array var0 , find the number of elements with value 1 and value 2 and store the count in var2 and var3 respectively . 
given array var0 and integer var7 , initialize var6 to var0 [ var7 ] and increment var7 by one . then , if var6 is 1 , increment var2 by one and if var6 is 2 , increment var3 by one . 
given integers var1 , var2 , var3 . initialize var4 to var1 , var5 to var2 , var6 to var3 , var7 to 0 , var8 and var10 to $$CONSTANT$$ . while var7 is less than var8 , perform the following operations . initialize var9 to ( var7 + var8 ) / 2 , var11 to 0 . for each var13 from 1 to var4 , perform the following operations . initialize var12 to var9 . divide var12 by var13 . add the minimum between var12 and var5 to var11 . if var11 is greater than var6 , set var8 to var9 ; else if var11 is less than var6 , set var7 to var9 + 1 ; else set var10 to the minimum between var10 , var9 and set var8 to var9 . 
given integers var7 , var8 , var4 , var10 , var6 . initialize var9 to ( var7 + var8 ) / 2 , var11 to 0 . for each var13 from 1 to var4 , perform the following operations . initialize var12 to var9 . divide var12 by var13 . add the minimum between var12 and var5 to var11 . if var11 is greater than var6 , set var8 to var9 ; else if var11 is less than var6 , set var7 to var9 + 1 ; else set var10 to the minimum between var10 , var9 and set var8 to var9 . 
given integers var7 , var8 , var4 . initialize var9 to ( var7 + var8 ) / 2 , var11 to 0 . for each var13 from 1 to var4 , perform the following operations . initialize var12 to var9 . divide var12 by var13 . add the minimum between var12 and var5 to var11 . 
given integers var13 , var9 , var5 , var11 . initialize var12 to var9 . divide var12 by var13 . add the minimum between var12 and var5 to var11 . 
given an array var1 , and an integer var0 . create an array var4 . then , for every integer var3 ( in $$CONSTANT$$ from 0 to | var1 | ) , find the $$CONSTANT$$ possible number var4 [ var3 ] such that every circle with radius var0 , var1 [ var3 ] x - coordinate , and y - coordinate equals to any number from the interval [ var4 [ var3 ] , positive infinity ] , 1 - shares $$CONSTANT$$ more than one point with the circle of radius var0 and which has its center at point ( var1 [ var7 ] , var4 [ var7 ] ) where ( 0 < = var7 < var3 ) , 2 - and shares $$CONSTANT$$ more than one point with the $$CONSTANT$$ y = 0 . then , set the answer for the var3 - th ( 0 < = var3 < = | var1 | ) circle to be var4 [ var3 ] . 
given an array var1 , and an integer var0 . create an array var4 . then , for every integer var3 ( in $$CONSTANT$$ from 0 to | var1 | ) , find the $$CONSTANT$$ possible number var4 [ var3 ] such that every circle with radius var0 , var1 [ var3 ] x - coordinate , and y - coordinate equals to any number from the interval [ var4 [ var3 ] , positive infinity ] , 1 - shares $$CONSTANT$$ more than one point with the circle of radius var0 and which has its center at point ( var1 [ var7 ] , var4 [ var7 ] ) where ( 0 < = var7 < var3 ) , 2 - and shares $$CONSTANT$$ more than one point with the $$CONSTANT$$ y = 0 . 
given an array var1 , and an integer var0 . create an array var4 . then , for every integer var3 ( in $$CONSTANT$$ from 0 to | var1 | ) , find the $$CONSTANT$$ possible number var4 [ var3 ] such that every circle with radius var0 , var1 [ var3 ] x - coordinate , and y - coordinate equals to any number from the interval [ var4 [ var3 ] , positive infinity ] , 1 - shares $$CONSTANT$$ more than one point with the circle of radius var0 and which has its center at point ( var1 [ var7 ] , var4 [ var7 ] ) where ( 0 < = var7 < var3 ) , 2 - and shares $$CONSTANT$$ more than one point with the $$CONSTANT$$ y = 0 . return $$CONSTANT$$ list of numbers of size | var1 | where the var3 - th number is equal to var4 [ var3 ] . 
given an array var1 , and an integer var0 . create an array var4 . then , for every integer var3 ( in $$CONSTANT$$ from 0 to | var1 | ) , find the $$CONSTANT$$ possible number var4 [ var3 ] such that every circle with radius var0 , var1 [ var3 ] x - coordinate , and y - coordinate equals to any number from the interval [ var4 [ var3 ] , positive infinity ] , 1 - shares $$CONSTANT$$ more than one point with the circle of radius var0 and which has its center at point ( var1 [ var7 ] , var4 [ var7 ] ) where ( 0 < = var7 < var3 ) , 2 - and shares $$CONSTANT$$ more than one point with the $$CONSTANT$$ y = 0 . 
you are given $$CONSTANT$$ string var0 . store in var2 the number of odd digits plus the number of vowels in var0 . 
given an array var1 of char type . let var2 be the number of characters in var1 which are either odd numbers or $$CONSTANT$$ $$CONSTANT$$ case letters ' $$CONSTANT$$ ' , ' e ' , ' o ' , ' $$CONSTANT$$ ' , ' u ' . 
given an array var1 of char type . assign the numeric value of var1 [ var3 ] to var4 . if var4 is not divisible by 2 then increment var2 . 
given integers var1 , var2 , var5 . assign 1 to var6 . assign the value ( ( var1 * 1 ) * var2 ) + 1 to var7 . while var6 is less than var7 , assign to var8 the value ( var6 + var7 ) > > 1 and if func0 ( mid , n , var2 ) is less than var5 then assign mid + 1 to var6 , or assign var8 to var7 , in other case . 
given integers var1 , var2 , var5 . assign to var8 the value ( var6 + var7 ) > > 1 . if func0 ( mid , n , var2 ) is less than var5 then assign mid + 1 to var6 , or assign var8 to var7 , in other case . 
given integers var0 , var1 , var2 . substract 1 from var0 . return the sum of all minimums between x / $$CONSTANT$$ and var2 where var4 obtains values from 1 to var1 . 
given integers var0 , var1 , var2 . substract 1 from var0 . let var3 be the sum of all minimums between x / $$CONSTANT$$ and var2 where var4 obtains values from 1 to var1 . 
given char typed array var0 . return the number of occurences of values 97 , $$CONSTANT$$ , 105 , 111 , 117 , $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ , 57 in var0 . 
you are given $$CONSTANT$$ string var0 . store in var2 the number of odd digits plus the number of vowels in var0 . you have to return var2 . 
given an array var1 of char type . return the number of characters in var1 which are either odd numbers or $$CONSTANT$$ $$CONSTANT$$ case letters ' $$CONSTANT$$ ' , ' e ' , ' o ' , ' $$CONSTANT$$ ' , ' u ' . 
you are given an array of numbers var1 , an array of numbers var2 , an index var10 , an index var11 , $$CONSTANT$$ number var5 and $$CONSTANT$$ number var4 . you have to set var7 to var1 [ var10 ] and add 1 to var10 . you have to set var8 to var2 [ var11 ] and add 1 to var11 . if var8 is greater than var7 you have to swap var7 and var8 . you have to store in var5 the minimum between var5 and var7 . you have to store in var4 the maximum between var4 and var8 . 
you are given an array of numbers var1 , an array of numbers var2 , an index var10 , an index var11 . you have to set var7 to var1 [ var10 ] and add 1 to var10 . you have to set var8 to var2 [ var11 ] and add 1 to var11 . if var8 is greater than var7 you have to swap var7 and var8 . 
given integers var2 and var3 . initialize var6 to zero . initialize var7 to ( var3 - 1 ) times var5 divided by two rounded down modulo $$CONSTANT$$ . for each var8 between 1 and var2 inclusive , starting from 1 , add ( var7 * ( ( ( var5 * var8 ) + 1 ) modulo $$CONSTANT$$ ) ) to var6 . take modulo of var6 by $$CONSTANT$$ . return var6 . 
given an integer var0 and arrays var1 , var2 . initialize var3 to the length of var1 , var4 to var0 . initialize var7 , var8 , var9 to 0 . for each var10 from 0 to var3 exclusive , add var2 [ var10 ] to var9 , the maximum between 0 and var1 [ var10 ] - var4 * var9 to var7 . set var9 to 0 . for each var11 from var3 - 1 to 0 , add var2 [ var11 ] to var9 , the maximum between 0 and var1 [ var11 ] - var4 * var9 to var8 . 
given an integer var0 and arrays var1 , var2 . initialize var3 to the length of var1 , var4 to var0 . initialize var7 , var8 , var9 to 0 . for each var10 from 0 to var3 exclusive , add var2 [ var10 ] to var9 , the maximum between 0 and var1 [ var10 ] - var4 * var9 to var7 . 
given an integer var0 and an array var1 . initialize var3 to the length of var1 , var4 to var0 . 
given an integer var0 and an array var1 . initialize var3 to the length of var1 , var4 to var0 . 
given an integer var0 and an array var1 . initialize var3 to the length of var1 , var4 to var0 . 
given an array of integers var7 , integers var0 , var1 , var2 and var3 and $$CONSTANT$$ string var6 , initialize var5 to 1 . for as long as var5 > 0 , if var2 - var0 > = 0 , then substract var0 from var2 , otherwise set var2 to var2 - var0 + $$CONSTANT$$ , decrease var1 by 1 if var1 > = 1 , set var1 to 23 otherwise ; increase var3 by 1 and set var6 to concatenation of string representation of var1 and string representation of var2 ; push var3 to the end of var7 and set var5 to 0 if there is at least one occurrence of " 7 " in var6 . 
given an array of integers var7 , integers var0 , var1 , var2 and var3 and $$CONSTANT$$ string var6 , if var2 - var0 > = 0 , then substract var0 from var2 , otherwise set var2 to var2 - var0 + $$CONSTANT$$ , decrease var1 by 1 if var1 > = 1 , set var1 to 23 otherwise ; increase var3 by 1 and set var6 to concatenation of string representation of var1 and string representation of var2 . push var3 to the end of var7 and set var5 to 0 if there is at least one occurrence of " 7 " in var6 . 
given integers var0 , var1 , var2 and var3 and $$CONSTANT$$ string var6 , if var2 - var0 > = 0 , then substract var0 from var2 , otherwise set var2 to var2 - var0 + $$CONSTANT$$ , decrease var1 by 1 if var1 > = 1 , set var1 to 23 otherwise ; increase var3 by 1 and set var6 to concatenation of string representation of var1 and string representation of var2 . 
given integers var2 , var0 and var1 , set var2 to var2 - var0 + $$CONSTANT$$ ; decrease var1 by 1 if var1 > = 1 , set var1 to 23 otherwise . 
given an integer var0 and arrays var1 , var2 . initialize var3 to the length of var1 , var4 to var0 . initialize var7 , var8 , var9 to 0 . for each var10 from 0 to var3 exclusive , add var2 [ var10 ] to var9 , the maximum between 0 and var1 [ var10 ] - var4 * var9 to var7 . set var9 to 0 . for each var11 from var3 - 1 to 0 , add var2 [ var11 ] to var9 , the maximum between 0 and var1 [ var11 ] - var4 * var9 to var8 . if var7 is greater than var8 , return " Limak " ; else if var7 is less than var8 , return " Radewoosh " ; else return " $$CONSTANT$$ " . 
given integers var0 , var1 , var2 . assign 0 to var4 . while var3 contains the character " 7 " do following operations . if mm - x is less than 0 then substract 1 from var1 and add to var2 the value $$CONSTANT$$ - x . otherwise , substract var0 from var2 . if var1 is less than 0 then assign 23 to var1 . add 1 to var4 . assign to var3 $$CONSTANT$$ string consisting of var1 and var2 . 
given integers var0 , var1 , var2 . if mm - x is less than 0 then substract 1 from var1 and add to var2 the value $$CONSTANT$$ - x . otherwise , substract var0 from var2 . if var1 is less than 0 then assign 23 to var1 . add 1 to var4 . assign to var3 $$CONSTANT$$ string consisting of var1 and var2 . 
given integers var0 , var1 , var2 . if mm - x is less than 0 then substract 1 from var1 and add to var2 the value $$CONSTANT$$ - x . otherwise , substract var0 from var2 . if var1 is less than 0 then assign 23 to var1 , 
given integers var0 , var1 , var2 . assign 0 to var4 . while var3 contains the character " 7 " do following operations . if mm - x is less than 0 then substract 1 from var1 and add to var2 the value $$CONSTANT$$ - x . otherwise , substract var0 from var2 . if var1 is less than 0 then assign 23 to var1 . add 1 to var4 . assign to var3 $$CONSTANT$$ string consisting of var1 and var2 . when the loop is ended , return var4 . 
given char typed array var0 . let var2 be the number of occurences of values 97 , $$CONSTANT$$ , 105 , 111 , 117 , $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ , 57 in var0 . 
given char typed array var0 . add 1 to var2 if var0 [ var4 ] equals one of values 97 , $$CONSTANT$$ , 105 , 111 , 117 , $$CONSTANT$$ , 51 , $$CONSTANT$$ , $$CONSTANT$$ , 57 . 
given $$CONSTANT$$ string var0 , count the number of characters which are either $$CONSTANT$$ vowel or an odd digit . store the count in var1 . 
given $$CONSTANT$$ string var0 . return the number of vowels and odd digits in var0 . 
you are given string var0 . initialize var1 to the number of characters inside var0 that are also inside the array of characters { ' 0 ' , ' 2 ' , ' 4 ' , ' 6 ' , ' 8 ' , ' $$CONSTANT$$ ' , ' e ' , ' $$CONSTANT$$ ' , ' o ' , ' u ' } . 
given var1 , var2 , var3 , var4 , var5 . initialize var6 to var1 , var7 to var2 , var8 to var3 , var9 to var4 , var10 to var5 , var11 to ( 2 * var8 + var9 ) , var12 to ( 3 * var10 + var9 ) and var13 to 0 . if var11 is greater than var6 , add the difference between var11 and var6 to var13 . if var12 is greater than var7 , add the difference between var12 and var7 to var13 . return var13 . 
given var1 , var2 , var3 , var4 , var5 . initialize var6 to var1 , var7 to var2 , var8 to var3 , var9 to var4 , var10 to var5 , var11 to ( 2 * var8 + var9 ) , var12 to ( 3 * var10 + var9 ) and var13 to 0 . if var11 is greater than var6 , add the difference between var11 and var6 to var13 . if var12 is greater than var7 , add the difference between var12 and var7 to var13 . 
you are given string var0 . initialize var1 to the number of characters inside var0 that are also inside the array of characters { ' 0 ' , ' 2 ' , ' 4 ' , ' 6 ' , ' 8 ' , ' $$CONSTANT$$ ' , ' e ' , ' $$CONSTANT$$ ' , ' o ' , ' u ' } . return var1 . 
given var1 , var2 , var3 , var4 , var5 . initialize var6 to var1 , var7 to var2 , var8 to var3 , var9 to var4 , var10 to var5 , var11 to ( 2 * var8 + var9 ) , var12 to ( 3 * var10 + var9 ) and var13 to 0 . if var11 is greater than var6 , add the difference between var11 and var6 to var13 . 
given $$CONSTANT$$ string var0 . return the number of vowels and odd digits in var0 . 
given $$CONSTANT$$ string var0 , count the number of characters which are either $$CONSTANT$$ vowel or an odd digit . store the count in var1 . finally , return the value in var1 . 
given integers var1 , var2 , var3 . initialize var4 to var1 , var5 to var2 , var6 to var3 , var7 to 0 , var8 and var10 to $$CONSTANT$$ . while var7 is less than var8 , perform the following operations . initialize var9 to ( var7 + var8 ) / 2 , var11 to 0 . for each var13 from 1 to var4 , perform the following operations . initialize var12 to var9 . divide var12 by var13 . add the minimum between var12 and var5 to var11 . if var11 is greater than var6 , set var8 to var9 ; else if var11 is less than var6 , set var7 to var9 + 1 ; else set var10 to the minimum between var10 , var9 and set var8 to var9 . return var7 . 
given an array of integers var1 , an array of integers var2 , and an integer var0 . set the value of var3 to the size of array var1 . set the value of var4 to 0 . set the value of var5 to 0 . set the value of var6 to the sum of ( the positive values of ( var1 [ var4 ] - var0 * ( the sum of the first ( var4 + 1 ) values in var2 ) ) ) , where var4 ( 0 < = var4 < var3 ) . set the value of var7 to the sum of ( the positive values of ( var1 [ var4 ] - var0 * ( the sum of the last ( var3 - var4 ) values in var2 ) ) ) , where var4 ( 0 < = var4 < var3 ) . set the value of var8 to the sum of var1 [ var4 ] ( 0 < = var4 < var3 ) . 
given an integer var0 and $$CONSTANT$$ string array var1 . initialize var2 to the length of var1 , var3 to 0 , var4 to 0 . for each var7 from 0 to var2 exclusive , perform the following operations . if var1 [ var7 ] not contains ' $$CONSTANT$$ ' , increase var3 by 1 . otherwise , iterate through elements of var1 [ var7 ] and if the current character equals ' $$CONSTANT$$ ' , set var5 to the concatenation of var5 and index of the current character . initialize var6 to $$CONSTANT$$ concatenation of all integers from 0 to var0 - 1 . initialize var4 to the number of elements in var6 which are not presented in var5 . return the value of var0 * var3 + var4 * ( var2 - var3 ) . 
given an integer var0 and $$CONSTANT$$ string array var1 . initialize var2 to the length of var1 , var3 to 0 , var4 to 0 . for each var7 from 0 to var2 exclusive , perform the following operations . if var1 [ var7 ] not contains ' $$CONSTANT$$ ' , increase var3 by 1 . otherwise , iterate through elements of var1 [ var7 ] and if the current character equals ' $$CONSTANT$$ ' , set var5 to the concatenation of var5 and index of the current character . initialize var6 to $$CONSTANT$$ concatenation of all integers from 0 to var0 - 1 . initialize var4 to the number of elements in var6 which are not presented in var5 . 
given an integer var0 and $$CONSTANT$$ string array var1 . initialize var2 to the length of var1 , var3 to 0 , var4 to 0 . for each var7 from 0 to var2 exclusive , perform the following operations . if var1 [ var7 ] not contains ' $$CONSTANT$$ ' , increase var3 by 1 . otherwise , iterate through elements of var1 [ var7 ] and if the current character equals ' $$CONSTANT$$ ' , set var5 to the concatenation of var5 and index of the current character . initialize var6 to $$CONSTANT$$ concatenation of all integers from 0 to var0 - 1 . 
given an integer var0 and $$CONSTANT$$ string array var1 . initialize var2 to the length of var1 , var3 to 0 , var4 to 0 . for each var7 from 0 to var2 exclusive , perform the following operations . if var1 [ var7 ] not contains ' $$CONSTANT$$ ' , increase var3 by 1 . otherwise , iterate through elements of var1 [ var7 ] and if the current character equals ' $$CONSTANT$$ ' , set var5 to the concatenation of var5 and index of the current character . initialize var6 to $$CONSTANT$$ concatenation of all integers from 0 to var0 - 1 . 
given an integer var0 and $$CONSTANT$$ string array var1 . initialize var2 to the length of var1 , var3 to 0 , var4 to 0 . for each var7 from 0 to var2 exclusive , perform the following operations . if var1 [ var7 ] not contains ' $$CONSTANT$$ ' , increase var3 by 1 . otherwise , iterate through elements of var1 [ var7 ] and if the current character equals ' $$CONSTANT$$ ' , set var5 to the concatenation of var5 and index of the current character . 
given an integer var0 and $$CONSTANT$$ string array var1 . initialize var2 to the length of var1 , var3 to 0 , var4 to 0 . for each var7 from 0 to var2 exclusive , perform the following operations . if var1 [ var7 ] not contains ' $$CONSTANT$$ ' , increase var3 by 1 . otherwise , iterate through elements of var1 [ var7 ] and if the current character equals ' $$CONSTANT$$ ' , set var5 to the concatenation of var5 and index of the current character . 
given $$CONSTANT$$ string array var1 and an integer var7 . iterate through elements of var1 [ var7 ] and if the current character equals ' $$CONSTANT$$ ' , set var5 to the concatenation of var5 and index of the current character . 
given an integer array var0 . var3 is equal to sum of all numbers in var0 . add into array var1 every var4 such that var0 [ var4 ] is equal to 1 . increment var3 if distance between two adjacent elements in var1 if equal to 2 . 
given an integer array var0 . var3 is equal to sum of all numbers in var0 . add into array var1 every var4 such that var0 [ var4 ] is equal to 1 . 
given an integer array var0 . var3 is equal to sum of all numbers in var0 . add into array var1 every var4 such that var0 [ var4 ] is equal to 1 . 
given integer var0 . create char typed matrix var2 . create char typed matrix var1 consisting of values " O - | - OOOO " , " O - | O - OOO " , " O - | OO - OO " , " O - | OOO - O " , " O - | OOOO - " , " - O | - OOOO " , " - O | O - OOO " , " - O | OO - OO " , " - O | OOO - O " , " - O | OOOO - " . if var0 equals 0 then add var1 [ 0 ] to the end of var2 . as long as var0 exceeds 0 , add var1 [ n % 10 ] to the end of var2 and divide var0 by 10 . 
given integer var0 . create char typed matrix var2 . create char typed matrix var1 consisting of values " O - | - OOOO " , " O - | O - OOO " , " O - | OO - OO " , " O - | OOO - O " , " O - | OOOO - " , " - O | - OOOO " , " - O | O - OOO " , " - O | OO - OO " , " - O | OOO - O " , " - O | OOOO - " . if var0 equals 0 then add var1 [ 0 ] to the end of var2 . 
given an integer array var0 . var3 is equal to sum of all numbers in var0 . add into array var1 every var4 such that var0 [ var4 ] is equal to 1 . 
given an integer array var0 . var3 is equal to sum of all numbers in var0 . add into array var1 every var4 such that var0 [ var4 ] is equal to 1 . increment var3 if distance between two adjacent elements in var1 if equal to 2 . return var3 . 
given 0 - based array var0 of integer type . assign to var1 the length of var0 . assign 0 to var2 and false . for all var4 $$CONSTANT$$ from 0 to var4 < var1 do following operations . if var3 is true and var4 exceeds 0 and var0 [ $$CONSTANT$$ - 1 ] equals 0 and var0 [ var4 ] equals 0 then decrease var2 by 1 and assign false to var3 . if var0 [ var4 ] equals 1 then assign true to var3 and increase var2 by 1 . otherwise , if var0 [ var4 ] equals 0 and var3 is true then if var4 is not larger than 0 or var4 does not equal n - 1 then increase var2 by 1 . 
given 0 - based array var0 of integer type . if var3 is true and var4 exceeds 0 and var0 [ $$CONSTANT$$ - 1 ] equals 0 and var0 [ var4 ] equals 0 then decrease var2 by 1 and assign false to var3 . if var0 [ var4 ] equals 1 then assign true to var3 and increase var2 by 1 . otherwise , if var0 [ var4 ] equals 0 and var3 is true then if var4 is not larger than 0 or var4 does not equal n - 1 then increase var2 by 1 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and $$CONSTANT$$ number var2 . you have to performing binary search . for this , set var3 to 1 and var4 to var0 * var1 ; while var3 + 1 is less than var4 you have to set var5 to var3 + var4 divided by 2 ( rounded down ) , set var6 to zero ; for each var7 between 1 and var0 you have to add the minimum between var5 - 1 divided by var7 ( rounded down ) and var1 to var6 ; if var6 is less than var2 you have to set var3 to var5 , otherwise you have to set var4 to var5 . 
you are given integers var7 , var8 , var9 . set var1 to var7 , var2 to var8 and var10 to var9 . perform $$CONSTANT$$ binary search on the range 1 to var1 * var2 . let var0 to the middle of the current search . if function func0 ( var0 , var1 , var2 ) return $$CONSTANT$$ value less than var10 , increase the $$CONSTANT$$ bound , otherwise decrease the $$CONSTANT$$ bound . 
you are given integers var3 , var11 , var1 , var2 , var10 . set var0 to the arithmetic mean between var3 and var11 ( rounded down ) . if function func0 ( var0 , var1 , var2 ) return $$CONSTANT$$ value less than var10 , set var3 to var0 + 1 , otherwise set var11 to var0 . 
you are given integers var1 , var0 , var2 . set var3 to 0 . iterate from 1 to var1 inclusive , in each iteration increase var3 by the minimum between var0 divided by var4 ( rounded down ) , and var2 . after end of iterations , return var3 . 
you are given integers var1 , var0 , var2 . set var3 to 0 . iterate from 1 to var1 inclusive , in each iteration increase var3 by the minimum between var0 divided by var4 ( rounded down ) , and var2 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to store in var1 the greatest common divisor of var0 and var1 . 
given an array of strings var0 . initialize var1 to an empty map . for each var4 in var0 , perform the following operations . if var1 does not contain var4 as $$CONSTANT$$ key , push " OK " into var7 and set var1 [ var4 ] to 0 ; else initialize var5 to var1 [ var4 ] , push var4 and var5 + 1 into var7 and set var1 [ var4 ] to var5 + 1 . 
given 0 - based array var0 of integer type . assign to var1 the length of var0 . assign 0 to var2 and false . for all var4 $$CONSTANT$$ from 0 to var4 < var1 do following operations . if var3 is true and var4 exceeds 0 and var0 [ $$CONSTANT$$ - 1 ] equals 0 and var0 [ var4 ] equals 0 then decrease var2 by 1 and assign false to var3 . if var0 [ var4 ] equals 1 then assign true to var3 and increase var2 by 1 . otherwise , if var0 [ var4 ] equals 0 and var3 is true then if var4 is not larger than 0 or var4 does not equal n - 1 then increase var2 by 1 . after the loop is ended , return var2 . 
given arrays of strings var0 , var7 , $$CONSTANT$$ map var1 and an integer var6 . initialize var4 to var0 [ var6 ] . if var1 does not contain var4 as $$CONSTANT$$ key , push " OK " into var7 and set var1 [ var4 ] to 0 ; else initialize var5 to var1 [ var4 ] , push var4 and var5 + 1 into var7 and set var1 [ var4 ] to var5 + 1 . 
you are given $$CONSTANT$$ number var0 and $$CONSTANT$$ number var1 . you have to return the greatest common divisor of var0 and var1 . 
given an array of strings var0 . initialize var1 to an empty map . for each var4 in var0 , perform the following operations . if var1 does not contain var4 as $$CONSTANT$$ key , push " OK " into var7 and set var1 [ var4 ] to 0 ; else initialize var5 to var1 [ var4 ] , push var4 and var5 + 1 into var7 and set var1 [ var4 ] to var5 + 1 . return var7 . 
given matrix var0 of char type . create $$CONSTANT$$ matrix var7 of char type . let var1 be the length of var0 . create $$CONSTANT$$ map of key type of array $$CONSTANT$$ char type and $$CONSTANT$$ value type of integer . for all var3 $$CONSTANT$$ from 0 to var3 < var1 , do following operations . let var4 be the next value in var0 . if var2 does not contain the key var4 then add " OK " to the end of var7 and add the value 1 with key var4 into var2 . otherwise , add the values var4 , var5 to the end of var7 and insert the value var5 + 1 with key var4 into var2 . 
given matrix var0 of char type . let var4 be the next value in var0 . if var2 does not contain the key var4 then add " OK " to the end of var7 and add the value 1 with key var4 into var2 . otherwise , add the values var4 , var5 to the end of var7 and insert the value var5 + 1 with key var4 into var2 . 
given matrix var0 of char type . create $$CONSTANT$$ matrix var7 of char type . let var1 be the length of var0 . create $$CONSTANT$$ map of key type of array $$CONSTANT$$ char type and $$CONSTANT$$ value type of integer . for all var3 $$CONSTANT$$ from 0 to var3 < var1 , do following operations . let var4 be the next value in var0 . if var2 does not contain the key var4 then add " OK " to the end of var7 and add the value 1 with key var4 into var2 . otherwise , add the values var4 , var5 to the end of var7 and insert the value var5 + 1 with key var4 into var2 . after the loop is ended , return var7 . 
you are given an array of strings var0 . you have to create an array of strings var8 initially empty . for each position var4 in var0 if string var0 [ var4 ] does not exist at some position less than var4 in var0 you have to add string " OK " to var8 , otherwise you have to add string var0 [ var4 ] plus the decimal representation of the number of positions less than var4 with the string var0 [ var4 ] in it to var8 . 
you are given an array of strings var0 , an associative container var1 , an array of strings var8 , an index var7 . you have to set var3 to var0 [ var7 ] and add 1 to var7 . if var1 does not contains the key var3 you have to add string " OK " to var8 and add the key var3 with the value 0 to var1 , otherwise you have to set var6 to the value of the key var3 in var1 , add 1 to var6 , insert string var3 plus the decimal representation of var6 in var8 , set the value of key var3 to var6 in var1 . 
you are given an array of strings var0 . you have to create an array of strings var8 initially empty . for each position var4 in var0 if string var0 [ var4 ] does not exist at some position less than var4 in var0 you have to add string " OK " to var8 , otherwise you have to add string var0 [ var4 ] plus the decimal representation of the number of positions less than var4 with the string var0 [ var4 ] in it to var8 . you have to return var8 . 
given integer var0 and $$CONSTANT$$ matrix var1 of char type . create $$CONSTANT$$ matrix var6 of char type . assign 0 to var7 . create $$CONSTANT$$ map var2 of key type of array of char type and $$CONSTANT$$ value type of integer . while var7 is less than var0 , do following operations . assign var1 [ var7 ] to var3 . if var2 does not contain the key var3 then add " OK " to the end of var6 and insert the valye 1 with key var3 into var2 . otherwise , let var4 be the $$CONSTANT$$ number such that var2 does not contain string consisting of values var3 and var4 , starting from position containing the value var3 . let var5 be $$CONSTANT$$ string consisting of var3 and var4 . add var5 to the end of var6 . add the value 1 with key var5 into var2 . add the value $$CONSTANT$$ + 1 with key var3 into var2 . after the loop is ended , return var6 . 
given arrays var1 , var2 and integers var8 , var9 , var4 . initialize var6 to var1 [ var8 ] , var7 to var2 [ var9 ] . if var6 is not greater than var4 , set var4 to the maximum between var7 and var4 . 
given integer array var0 . create char arrays var2 containing values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ; var3 containing values 31 , $$CONSTANT$$ , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ; var4 containing values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , $$CONSTANT$$ , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ; var5 containing values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , $$CONSTANT$$ , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 . assign var0 to var6 with all elements being splitted by " , " . assign var6 to var8 . 
given integer array var0 . create char arrays var2 containing values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ; var3 containing values 31 , $$CONSTANT$$ , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ; var4 containing values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , $$CONSTANT$$ , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ; var5 containing values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , $$CONSTANT$$ , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 . assign var0 to var6 with all elements being splitted by " , " . assign var6 to var8 . if var2 contains var8 or var3 contains var8 or var4 contains var8 or var5 contains var8 then return " YES " . return " NO " . 
given integer array var0 . create char arrays var2 containing values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ; var3 containing values 31 , $$CONSTANT$$ , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ; var4 containing values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , $$CONSTANT$$ , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ; var5 containing values 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 31 , $$CONSTANT$$ , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 . assign var0 to var6 with all elements being splitted by " , " . 
given an array of integers var0 , initialize var2 to array of integers of length 2 . find the number of elements of var0 , which are equal to 1 , and store the result in var2 [ 0 ] . find the number of elements of var0 , which are not equal to 1 , and store the result in var2 [ 1 ] . initialize var5 to 0 . for as long as var2 [ 0 ] > 0 , substract 1 from var2 [ 0 ] and var2 [ 1 ] and add 1 to var5 . 
given an array of integers var0 , initialize var2 to array of integers of length 2 . find the number of elements of var0 , which are equal to 1 , and store the result in var2 [ 0 ] . find the number of elements of var0 , which are not equal to 1 , and store the result in var2 [ 1 ] . 
given an array of integers var0 , initialize var2 to array of integers of length 2 . find the number of elements of var0 , which are equal to 1 , and store the result in var2 [ 0 ] . find the number of elements of var0 , which are not equal to 1 , and store the result in var2 [ 1 ] . 
given an array of integers var0 , initialize var2 to array of integers of length 2 . find the number of elements of var0 , which are equal to 1 , and store the result in var2 [ 0 ] . find the number of elements of var0 , which are not equal to 1 , and store the result in var2 [ 1 ] . initialize var5 to 0 . for as long as var2 [ 0 ] > 0 , substract 1 from var2 [ 0 ] and var2 [ 1 ] and add 1 to var5 . return var5 + var2 [ 0 ] / 3 ( rounded down ) . 
given arrays var1 , var2 and an integer var0 . initialize var4 to 0 . for each var6 in var1 and var7 in var2 , if var6 is not greater than var4 , set var4 to the maximum between var7 and var4 . 
given arrays of integers var0 and var2 and an integer var3 , add 1 to var2 [ 0 ] if var0 [ var3 ] = 1 , add 1 to var2 [ 1 ] otherwise . 
given an array of integers var1 and an integer var0 , initialize var9 to empty array of strings , var4 to array of reals of length equal to length of var1 . for each position var5 in var1 iterate over all positions var6 from 0 to var5 - 1 ( both inclusive ) : initialize var7 to absolute value of var1 [ var5 ] - var1 [ var6 ] , set var4 [ var5 ] to the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 if var7 < = 2 * var0 and var4 [ var6 ] is less than the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 ; after the inner loop set var4 [ var5 ] to var0 is var4 [ var5 ] = 0 . for each element var8 in var4 append $$CONSTANT$$ string , obtained by concatenation of var8 , converted to string , and " " , to the end of var9 . 
given an array of integers var1 and an integer var0 , initialize var9 to empty array of strings , var4 to array of reals of length equal to length of var1 . for each position var5 in var1 iterate over all positions var6 from 0 to var5 - 1 ( both inclusive ) : initialize var7 to absolute value of var1 [ var5 ] - var1 [ var6 ] , set var4 [ var5 ] to the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 if var7 < = 2 * var0 and var4 [ var6 ] is less than the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 ; after the inner loop set var4 [ var5 ] to var0 is var4 [ var5 ] = 0 . for each element var8 in var4 append $$CONSTANT$$ string , obtained by concatenation of var8 , converted to string , and " " , to the end of var9 . return var9 . 
given an array of integers var1 and an integer var0 , initialize var9 to empty array of strings , var4 to array of reals of length equal to length of var1 . for each position var5 in var1 iterate over all positions var6 from 0 to var5 - 1 ( both inclusive ) : initialize var7 to absolute value of var1 [ var5 ] - var1 [ var6 ] , set var4 [ var5 ] to the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 if var7 < = 2 * var0 and var4 [ var6 ] is less than the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 ; after the inner loop set var4 [ var5 ] to var0 is var4 [ var5 ] = 0 . 
given an array of integers var1 , an array of reals var4 and integers var0 , var5 , for each position var6 from 0 to var5 - 1 ( both inclusive ) initialize var7 to absolute value of var1 [ var5 ] - var1 [ var6 ] , set var4 [ var5 ] to the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 if var7 < = 2 * var0 and var4 [ var6 ] is less than the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 , set var4 [ var5 ] to var0 is var4 [ var5 ] = 0 . 
given an array of integers var1 , an array of reals var4 and integers var0 , var5 , for each position var6 from 0 to var5 - 1 ( both inclusive ) initialize var7 to absolute value of var1 [ var5 ] - var1 [ var6 ] , set var4 [ var5 ] to the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 if var7 < = 2 * var0 and var4 [ var6 ] is less than the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 . 
given an array of integers var1 , an array of reals var4 and integers var0 , var5 and var6 , initialize var7 to absolute value of var1 [ var5 ] - var1 [ var6 ] . set var4 [ var5 ] to the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 if var7 < = 2 * var0 and var4 [ var6 ] is less than the sum of var4 [ var6 ] and square root of 4 * var0 * var0 - var7 * var7 . 
given integer var0 and arrays var1 , var2 of integer types . set 0 to var4 . for all var5 $$CONSTANT$$ from 0 to var5 < var3 , do this . if var4 is larger than or equal to the next value in var1 then set the larger of var4 and the next value in var2 to var4 . 
given integer var0 and arrays var1 , var2 of integer types . if var4 is larger than or equal to the next value in var1 then set the larger of var4 and the next value in var2 to var4 . 
given an array of integers var0 . create an empty string var2 . $$CONSTANT$$ var0 to var2 changing every integer in var0 to $$CONSTANT$$ character . 
given integer array var0 . initialize var2 to the sum of all elements of var0 , var3 to the number of ones in var0 and var4 to the number of twos in var0 . if var4 is not less than var3 then return var3 . otherwise , if var3 exceeds var4 then return y + ( var3 - var4 ) / 3 . otherwise , return 0 . 
given an array of integers var0 . create an empty string var2 . $$CONSTANT$$ var0 to var2 changing every integer in var0 to $$CONSTANT$$ character . check if var2 is $$CONSTANT$$ sub - string of one of the following strings : " $$CONSTANT$$ " , " $$CONSTANT$$ " , " $$CONSTANT$$ " , and " $$CONSTANT$$ " . 
given integer array var0 . initialize var2 to the sum of all elements of var0 , var3 to the number of ones in var0 and var4 to the number of twos in var0 . 
given integer array var0 . add var0 [ var5 ] to var2 . if var0 [ var5 ] equals 1 then increment var3 , otherwise , increment var4 . 
given integer array var0 . initialize var2 to the sum of all elements of var0 , var3 to the number of ones in var0 and var4 to the number of twos in var0 . if var4 is not less than var3 then return var3 . otherwise , if var3 exceeds var4 then return y + ( var3 - var4 ) / 3 . otherwise , return 0 . 
you are given an array var0 . assign the length of var0 to var1 . initialize var2 to the number of ' 1 ' $$CONSTANT$$ in var0 and var3 to the number of other values in var0 . 
you are given an array var0 . initialize var2 to the number of ' 1 ' $$CONSTANT$$ in var0 and var3 to the number of other values in var0 . 
given integer var0 and $$CONSTANT$$ matrix var1 of char type . create $$CONSTANT$$ matrix var6 of char type . assign 0 to var7 . create $$CONSTANT$$ map var2 of key type of array of char type and $$CONSTANT$$ value type of integer . while var7 is less than var0 , do following operations . assign var1 [ var7 ] to var3 . if var2 does not contain the key var3 then add " OK " to the end of var6 and insert the valye 1 with key var3 into var2 . otherwise , let var4 be the $$CONSTANT$$ number such that var2 does not contain string consisting of values var3 and var4 , starting from position containing the value var3 . let var5 be $$CONSTANT$$ string consisting of var3 and var4 . add var5 to the end of var6 . add the value 1 with key var5 into var2 . add the value $$CONSTANT$$ + 1 with key var3 into var2 . 
given integer var0 and $$CONSTANT$$ matrix var1 of char type . assign var1 [ var7 ] to var3 . if var2 does not contain the key var3 then add " OK " to the end of var6 and insert the valye 1 with key var3 into var2 . otherwise , let var4 be the $$CONSTANT$$ number such that var2 does not contain string consisting of values var3 and var4 , starting from position containing the value var3 . let var5 be $$CONSTANT$$ string consisting of var3 and var4 . add var5 to the end of var6 . add the value 1 with key var5 into var2 . add the value $$CONSTANT$$ + 1 with key var3 into var2 . 
given integer var0 and $$CONSTANT$$ matrix var1 of char type . let var4 be the $$CONSTANT$$ number such that var2 does not contain string consisting of values var3 and var4 , starting from position containing the value var3 . let var5 be $$CONSTANT$$ string consisting of var3 and var4 . add var5 to the end of var6 . add the value 1 with key var5 into var2 . add the value $$CONSTANT$$ + 1 with key var3 into var2 . 
you are given an array var0 . assign the length of var0 to var1 . initialize var2 to the number of ' 1 ' $$CONSTANT$$ in var0 and var3 to the number of other values in var0 . assign the minimum of var2 and var3 to var6 . decrease both var2 and var3 by var6 . increase var6 by var2 / 3 . return var6 . 
given integer var0 and $$CONSTANT$$ matrix var1 of char type . let var4 be the $$CONSTANT$$ number such that var2 does not contain string consisting of values var3 and var4 , starting from position containing the value var3 . 
you are given an array of numbers var0 ( indexing is 0 - based ) and $$CONSTANT$$ string var1 . you have to set var5 to zero and var6 to zero . for each position var7 in var0 if character var1 [ var7 ] is equal to " 1 " you have to store in var5 the maximum between var5 + var0 [ var7 ] and var6 , you have to add var0 [ var7 ] to var6 . 
you are given an array of numbers var0 , $$CONSTANT$$ string var1 , $$CONSTANT$$ number var5 , $$CONSTANT$$ number var6 , an index var7 . if character var1 [ var7 ] is equal to " 1 " you have to store in var5 the maximum between var5 + var0 [ var7 ] and var6 . you have to add var0 [ var7 ] to var6 . 
you are given an array of numbers var0 ( indexing is 0 - based ) and $$CONSTANT$$ string var1 . you have to set var5 to zero and var6 to zero . for each position var7 in var0 if character var1 [ var7 ] is equal to " 1 " you have to store in var5 the maximum between var5 + var0 [ var7 ] and var6 , you have to add var0 [ var7 ] to var6 . you have to return var5 . 
given integer var0 and arrays var1 , var2 of integer types . set 0 to var4 . for all var5 $$CONSTANT$$ from 0 to var5 < var3 , do this . if var4 is larger than or equal to the next value in var1 then set the larger of var4 and the next value in var2 to var4 . after the loop is ended , if var4 is larger than or equal to var0 then return " YES " . otherwise , return " NO " . 
given an integer var0 and $$CONSTANT$$ two - dimensional array var1 . initialize var2 to the length of var1 , var3 , var4 to empty arrays . iterate through elements of var1 and if the current element var1 [ var5 ] [ var6 ] equals ' $$CONSTANT$$ ' , push var5 into var4 and var6 into var3 . initialize var7 , var8 to 0 . if length of var4 is less than var2 , add ( var2 - length of var4 ) * var0 to var7 and set var8 to var2 - length of var4 . if length of var3 is less than var0 , add the value of ( ( var0 - length of var3 ) * var2 ) - ( var8 * ( var0 - length of var3 ) ) to var7 . 
given an integer var0 and $$CONSTANT$$ two - dimensional array var1 . initialize var2 to the length of var1 , var3 , var4 to empty arrays . iterate through elements of var1 and if the current element var1 [ var5 ] [ var6 ] equals ' $$CONSTANT$$ ' , push var5 into var4 and var6 into var3 . initialize var7 , var8 to 0 . if length of var4 is less than var2 , add ( var2 - length of var4 ) * var0 to var7 and set var8 to var2 - length of var4 . 
given an integer var0 and $$CONSTANT$$ two - dimensional array var1 . initialize var3 , var4 to empty arrays . iterate through elements of var1 and if the current element var1 [ var5 ] [ var6 ] equals ' $$CONSTANT$$ ' , push var5 into var4 and var6 into var3 . 
given an integer var0 and $$CONSTANT$$ two - dimensional array var1 . initialize var3 , var4 to empty arrays . iterate through elements of var1 and if the current element var1 [ var5 ] [ var6 ] equals ' $$CONSTANT$$ ' , push var5 into var4 and var6 into var3 . 
given $$CONSTANT$$ string var0 , count the number of characters of string var0 , which are present in string " $$CONSTANT$$ " . store the result in var2 . 
given char typed array var0 . create sorted set var1 containing values 97 , $$CONSTANT$$ , 105 , 111 , 117 . assign var0 to var2 . let var3 be the number of such cases that var1 contains the value var2 [ var4 ] or var2 [ var4 ] is odd value from 0 to 9 , inclusive . 
given an integer var0 and $$CONSTANT$$ two - dimensional array var1 . initialize var2 to the length of var1 , var3 , var4 to empty arrays . iterate through elements of var1 and if the current element var1 [ var5 ] [ var6 ] equals ' $$CONSTANT$$ ' , push var5 into var4 and var6 into var3 . initialize var7 , var8 to 0 . if length of var4 is less than var2 , add ( var2 - length of var4 ) * var0 to var7 and set var8 to var2 - length of var4 . if length of var3 is less than var0 , add the value of ( ( var0 - length of var3 ) * var2 ) - ( var8 * ( var0 - length of var3 ) ) to var7 . return var7 . 
given $$CONSTANT$$ string var0 , count the number of characters of string var0 , which are present in string " $$CONSTANT$$ " . return the result . 
given char typed array var0 . create sorted set var1 containing values 97 , $$CONSTANT$$ , 105 , 111 , 117 . assign var0 to var2 . return the number of such cases that var1 contains the value var2 [ var4 ] or var2 [ var4 ] is odd value from 0 to 9 , inclusive . 
given integers var0 , var1 , var2 , var3 , var4 . initialize var10 to var2 * 2 + var3 , var11 to var4 * 3 + var3 , var5 to var0 , var6 to var1 , var12 to 0 . if var10 is greater than var5 , add var10 - var5 to var12 . if var11 is greater than var6 , add var11 - var6 to var12 . 
given integers var0 , var1 , var2 , var3 , var4 . initialize var10 to var2 * 2 + var3 , var11 to var4 * 3 + var3 , var5 to var0 , var6 to var1 , var12 to 0 . if var10 is greater than var5 , add var10 - var5 to var12 . 
given integers var0 , var1 , var2 . assign 0 to var3 , string values of var1 to var4 , var2 to var5 . while var4 or var5 does not contain " 7 " , do following operations . increment var3 . decrease var2 by var0 . if var2 is negative then add $$CONSTANT$$ to it and decrement var1 , otherwise , if var1 is negative then add $$CONSTANT$$ to it . assign the string values of var1 to var4 , var2 to var5 . 
given integers var0 , var1 , var2 . increment var3 . decrease var2 by var0 . if var2 is negative then add $$CONSTANT$$ to it and decrement var1 , otherwise , if var1 is negative then add $$CONSTANT$$ to it . assign the string values of var1 to var4 , var2 to var5 . 
given integers var0 , var1 , var2 . increment var3 . decrease var2 by var0 . if var2 is negative then add $$CONSTANT$$ to it and decrement var1 , otherwise , if var1 is negative then add $$CONSTANT$$ to it . 
given integers var0 , var1 , var2 , var3 , var4 . initialize var10 to var2 * 2 + var3 , var11 to var4 * 3 + var3 , var5 to var0 , var6 to var1 , var12 to 0 . if var10 is greater than var5 , add var10 - var5 to var12 . if var11 is greater than var6 , add var11 - var6 to var12 . return var12 . 
given integers var0 , var1 , var2 . assign 0 to var3 , string values of var1 to var4 , var2 to var5 . while var4 or var5 does not contain " 7 " , do following operations . increment var3 . decrease var2 by var0 . if var2 is negative then add $$CONSTANT$$ to it and decrement var1 , otherwise , if var1 is negative then add $$CONSTANT$$ to it . assign the string values of var1 to var4 , var2 to var5 . when the loop is ended , return var3 . 
given $$CONSTANT$$ string var0 . count the number of characters in var0 that is either $$CONSTANT$$ vowel or an odd digit and store that value to var2 . 
given 2 strings var1 and var0 , 2 integers var3 and var2 . increase var2 by the number occurences of character at index var3 of string var0 in string var1 . 
given integers var3 , var4 . if $$CONSTANT$$ equals 1 then return var3 . let var0 be the number of operations of dividing var3 by 2 are needed for var3 become less than or equal to 0 . 
given integers var3 , var4 . if $$CONSTANT$$ equals 1 then return var3 . 
given integer var0 . return the value 2 erected to the power of var0 . 
given integer var0 . let var1 be the value 2 erected to the power of var0 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to 2 * var2 + var3 , var6 to var3 + 3 * var4 , var7 to zero . if var5 is greater than var0 add var5 - var0 to var7 . if var6 is greater than var1 add var6 - var1 to var7 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to 2 * var2 + var3 , var6 to var3 + 3 * var4 , var7 to zero . if var5 is greater than var0 add var5 - var0 to var7 . 
given integers var0 , var1 , var5 , var3 . decrease var0 and var1 by var3 . if var0 is negative , decrease var5 by var0 . if var1 is negative , decrease var5 by var1 . if var0 is less than 2 * var2 , increase var5 by 2 * var2 - var0 . if var1 is less than 3 * var4 , increase var5 by 3 * var4 - var1 . 
you are given the numbers var0 , var1 , var2 , var3 , var4 . set var5 to 2 * var2 + var3 , var6 to var3 + 3 * var4 , var7 to zero . if var5 is greater than var0 add var5 - var0 to var7 . if var6 is greater than var1 add var6 - var1 to var7 . return var7 . 
given integers var0 , var1 , var5 , var3 . decrease var0 and var1 by var3 . if var0 is negative , decrease var5 by var0 . if var1 is negative , decrease var5 by var1 . if var0 is less than 2 * var2 , increase var5 by 2 * var2 - var0 . if var1 is less than 3 * var4 , increase var5 by 3 * var4 - var1 . return var5 . 
given integers var3 , var4 . if $$CONSTANT$$ equals 1 then return var3 . let var0 be the number of operations of dividing var3 by 2 are needed for var3 become less than or equal to 0 . return the value func0 ( var0 ) - 1 . 
given integers var0 , var1 , var5 , var3 . decrease var0 and var1 by var3 . if var0 is negative , decrease var5 by var0 . if var1 is negative , decrease var5 by var1 . if var0 is less than 2 * var2 , increase var5 by 2 * var2 - var0 . 
given integers var3 , var4 . if $$CONSTANT$$ equals 1 then return var3 . 
given $$CONSTANT$$ string var0 and an array of strings var1 . if var1 contains var0 , return " YES " . initialize var4 , var5 to false . for each var6 from 0 to the length of var1 excluisve , perform the following operations . if var1 [ var6 ] [ 1 ] equals var0 [ 0 ] , set var4 to true . if var1 [ var6 ] [ 0 ] equals var0 [ 1 ] , set var5 to true . if var4 is true and var5 is true , return " YES " ; else return " NO " . 
given integers var0 , var1 , var5 , var3 . decrease var0 and var1 by var3 . if var0 is negative , decrease var5 by var0 . if var1 is negative , decrease var5 by var1 . 
given integers var0 , var1 , var5 , var3 . decrease var0 and var1 by var3 . if var0 is negative , decrease var5 by var0 . 
you are given the numbers var1 , var2 , and var3 . you have to set var4 to var1 , var5 to zero , var6 to var2 and var7 to var3 . while the result of the function func0 at the arguments var6 and var7 is false you have to add 1 to var5 and subtract var4 to var7 ; if var7 is less than zero you have to subtract 1 to var6 , add $$CONSTANT$$ to var6 if var6 is less than zero ; you have to add $$CONSTANT$$ to var7 if var7 is less than 0 . 
you are given $$CONSTANT$$ number var5 , $$CONSTANT$$ number var7 , $$CONSTANT$$ number var6 , $$CONSTANT$$ number var4 . you have to add 1 to var5 and subtract var4 to var7 . if var7 is less than zero you have to subtract 1 to var6 , add $$CONSTANT$$ to var6 if var6 is less than zero . you have to add $$CONSTANT$$ to var7 if var7 is less than 0 . 
you are given $$CONSTANT$$ number var5 , $$CONSTANT$$ number var7 , $$CONSTANT$$ number var6 , $$CONSTANT$$ number var4 . you have to add 1 to var5 and subtract var4 to var7 . if var7 is less than zero you have to subtract 1 to var6 , add $$CONSTANT$$ to var6 if var6 is less than zero . 
you are given the numbers var1 , var2 , and var3 . you have to set var4 to var1 , var5 to zero , var6 to var2 and var7 to var3 . while the result of the function func0 at the arguments var6 and var7 is false you have to add 1 to var5 and subtract var4 to var7 ; if var7 is less than zero you have to subtract 1 to var6 , add $$CONSTANT$$ to var6 if var6 is less than zero ; you have to add $$CONSTANT$$ to var7 if var7 is less than 0 . you have to return var5 . 
given an integers var0 , var1 , var2 , integer array var3 , var4 is equal to var0 , var5 is equal to $$CONSTANT$$ * $$CONSTANT$$ , var6 is equal to var1 * $$CONSTANT$$ + var2 . for $$CONSTANT$$ in range from 0 to infinity if $$CONSTANT$$ is positive then assign var6 to ( var6 - var4 + var5 ) modulo var5 . if var6 divided by $$CONSTANT$$ modulo 10 is equal to 7 or var6 modulo 10 is equal to 7 then add var7 to var3 and return var3 . 
given $$CONSTANT$$ string var0 and an array of strings var1 . if var1 contains var0 , return " YES " . initialize var4 , var5 to false . for each var6 from 0 to the length of var1 excluisve , perform the following operations . if var1 [ var6 ] [ 1 ] equals var0 [ 0 ] , set var4 to true . if var1 [ var6 ] [ 0 ] equals var0 [ 1 ] , set var5 to true . if var4 is true and var5 is true , return " YES " ; else return " NO " . 
given an integers var0 , var1 , var2 , integer array var3 , var4 is equal to var0 , var5 is equal to $$CONSTANT$$ * $$CONSTANT$$ , var6 is equal to var1 * $$CONSTANT$$ + var2 . for $$CONSTANT$$ in range from 0 to infinity if $$CONSTANT$$ is positive then assign var6 to ( var6 - var4 + var5 ) modulo var5 . if var6 divided by $$CONSTANT$$ modulo 10 is equal to 7 or var6 modulo 10 is equal to 7 then add var7 to var3 and return var3 . 
given var1 , var0 , var2 . initialize var3 to 0 . while both var0 and var2 do not contain 7 as digit , perform the following operations . if var2 - var1 is not less than 0 , decrease var2 by var1 ; else if var0 - 1 is less than 0 , set var0 to 23 ; else decrease var0 by 1 . set var2 to ( $$CONSTANT$$ + var2 ) - var1 . increase var3 by 1 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var3 , an array of numbers var4 . set var5 to var1 , var6 to var2 and var7 to var3 . if the decimal representation of var6 contains the digit 7 or the decimal representation of var7 contains the digit 7 insert 0 to var4 and return var4 . 
given var0 . return true if var0 contains 7 as $$CONSTANT$$ digit ; else return false . 
given var1 , var0 , var2 . if var0 - 1 is less than 0 , set var0 to 23 ; else decrease var0 by 1 . set var2 to ( $$CONSTANT$$ + var2 ) - var1 . 
you are given $$CONSTANT$$ number var8 , $$CONSTANT$$ number var5 , $$CONSTANT$$ number var9 . you have to subtract var5 to var8 and add 1 to var9 . if var8 is less than zero add $$CONSTANT$$ * $$CONSTANT$$ to var8 . set var10 to var8 divided by $$CONSTANT$$ ( rounded down ) and var11 to var8 modulo $$CONSTANT$$ . 
you are given $$CONSTANT$$ number var8 , $$CONSTANT$$ number var5 , $$CONSTANT$$ number var9 , an array of numbers var4 . you have to subtract var5 to var8 and add 1 to var9 . if var8 is less than zero add $$CONSTANT$$ * $$CONSTANT$$ to var8 . set var10 to var8 divided by $$CONSTANT$$ ( rounded down ) and var11 to var8 modulo $$CONSTANT$$ . if var10 modulo 10 is equal to 7 or var10 divided by 10 ( rounded down ) is equal to 7 or var11 modulo 10 is equal to 7 or var11 divided by 10 ( rounded down ) is equal to 7 you have to insert var9 in var4 and return var4 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var3 , an array of numbers var4 . set var5 to var1 , var6 to var2 and var7 to var3 . if the decimal representation of var6 contains the digit 7 or the decimal representation of var7 contains the digit 7 insert 0 to var4 and return var4 . set var8 to var6 * $$CONSTANT$$ + var7 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var3 , an array of numbers var4 . set var5 to var1 , var6 to var2 and var7 to var3 . if the decimal representation of var6 contains the digit 7 or the decimal representation of var7 contains the digit 7 insert 0 to var4 and return var4 . set var8 to var6 * $$CONSTANT$$ + var7 and var9 to zero . you have to iterate , inside the loop you have to , subtract var5 to var8 and add 1 to var9 , if var8 is less than zero add $$CONSTANT$$ * $$CONSTANT$$ to var8 , set var10 to var8 divided by $$CONSTANT$$ ( rounded down ) and var11 to var8 modulo $$CONSTANT$$ , if var10 modulo 10 is equal to 7 or var10 divided by 10 ( rounded down ) is equal to 7 or var11 modulo 10 is equal to 7 or var11 divided by 10 ( rounded down ) is equal to 7 you have to insert var9 in var4 and return var4 . 
you are given $$CONSTANT$$ number var1 , $$CONSTANT$$ number var2 , $$CONSTANT$$ number var3 , an array of numbers var4 . set var5 to var1 , var6 to var2 and var7 to var3 . if the decimal representation of var6 contains the digit 7 or the decimal representation of var7 contains the digit 7 insert 0 to var4 and return var4 . set var8 to var6 * $$CONSTANT$$ + var7 . 
given var1 , var0 , var2 . if var2 - var1 is not less than 0 , decrease var2 by var1 ; else if var0 - 1 is less than 0 , set var0 to 23 ; else decrease var0 by 1 . set var2 to ( $$CONSTANT$$ + var2 ) - var1 . 
given var1 , var0 , var2 . initialize var3 to 0 . while both var0 and var2 do not contain 7 as digit , perform the following operations . if var2 - var1 is not less than 0 , decrease var2 by var1 ; else if var0 - 1 is less than 0 , set var0 to 23 ; else decrease var0 by 1 . set var2 to ( $$CONSTANT$$ + var2 ) - var1 . increase var3 by 1 . return var3 . 
you are given $$CONSTANT$$ number var8 , $$CONSTANT$$ number var5 , $$CONSTANT$$ number var9 . you have to subtract var5 to var8 and add 1 to var9 . if var8 is less than zero add $$CONSTANT$$ * $$CONSTANT$$ to var8 . 
given $$CONSTANT$$ string var0 and an array of strings var1 . if var1 contains var0 , return " YES " . initialize var4 , var5 to false . for each var6 from 0 to the length of var1 excluisve , perform the following operations . if var1 [ var6 ] [ 1 ] equals var0 [ 0 ] , set var4 to true . if var1 [ var6 ] [ 0 ] equals var0 [ 1 ] , set var5 to true . 
given $$CONSTANT$$ string var0 and an array of strings var1 . if var1 contains var0 , return " YES " . 
given $$CONSTANT$$ string var0 , an array of strings var1 , $$CONSTANT$$ var4 , var5 and an integer var6 . if var1 [ var6 ] [ 1 ] equals var0 [ 0 ] , set var4 to true . if var1 [ var6 ] [ 0 ] equals var0 [ 1 ] , set var5 to true . 
given char array var0 and char matrix var1 . assign true to var4 if there are such arrays var5 , var6 in var1 that string built of var5 and var6 contains var0 . 
given an array var0 of integer type . assign 0 to var5 . let var1 be the length of var0 . create an array var2 of size 2 and of integer type . iterating over var0 , if current element equals 1 then increment var2 [ 0 ] . otherwise , increment var2 [ 1 ] . 
given an array var0 of integer type . assign the value of next element in var0 to var4 . if var4 equals 1 then increment var2 [ 0 ] . otherwise , increment var2 [ 1 ] . 
given an array of integers var0 , count the number of elements of var0 , which are equal to 1 , and store the result in var3 , count the number of elements of var0 , which are equal to 2 , and store the result in var2 . 
given an array of integers var0 and integers var4 , var3 and var2 , add 1 to var2 if var0 [ var4 ] = 2 , add 1 to var3 if var0 [ var4 ] = 1 . 
you are given an integer array var0 . set var2 and var3 to 0 . iterate over the size of array var0 with an index var7 . in each iteration , if var0 [ var7 ] is equal to 1 , increment var2 , otherwise increment var3 . initialize var6 to 0 . ( end of loop ) while var3 and var2 are both more than 0 , decrement these variables , and increment var6 . while var2 is more than 3 , increment var6 and subtract 3 from var2 . 
given char array var0 and char matrix var1 . if there are such arrays var5 , var6 in var1 that string built of var5 and var6 contains var0 then return " YES " . otherwise , return " NO " . 
you are given an integer array var0 . set var2 and var3 to 0 . iterate over the size of array var0 with an index var7 . in each iteration , if var0 [ var7 ] is equal to 1 , increment var2 , otherwise increment var3 . 
given an array var0 of integer type . assign 0 to var5 . let var1 be the length of var0 . create an array var2 of size 2 and of integer type . iterating over var0 , if current element equals 1 then increment var2 [ 0 ] . otherwise , increment var2 [ 1 ] . if var2 [ 0 ] is larger than or equal to var2 [ 1 ] then return var2 [ 1 ] + ( var2 [ 0 ] - var2 [ 1 ] ) / 3 . otherwise , return var2 [ 0 ] . 
you are given an integer array var0 . set var2 and var3 to 0 . iterate over the size of array var0 with an index var7 . in each iteration , if var0 [ var7 ] is equal to 1 , increment var2 , otherwise increment var3 . 
given an array of integers var0 , count the number of elements of var0 , which are equal to 1 , and store the result in var3 , count the number of elements of var0 , which are equal to 2 , and store the result in var2 . initialize var6 to the smaller of var3 and var2 , initialize var7 to var3 - var6 , initialize var8 to var7 / 3 ( rounded down ) and return var8 + var6 . 
you are given integers var3 , var2 , var7 and an integer array var0 . if var0 [ var7 ] is equal to 1 , increment var2 , otherwise increment var3 . increment var7 . 
you are given an integer array var0 . set var2 and var3 to 0 . iterate over the size of array var0 with an index var7 . in each iteration , if var0 [ var7 ] is equal to 1 , increment var2 , otherwise increment var3 . initialize var6 to 0 . ( end of loop ) while var3 and var2 are both more than 0 , decrement these variables , and increment var6 . while var2 is more than 3 , increment var6 and subtract 3 from var2 . return var6 . 
given an array of strings var1 , initialize var2 to length of var1 , var3 to string of length var2 . for each position var4 in var1 set var3 [ var4 ] to var1 [ var4 ] [ 0 ] . initialize var5 and var6 to 2 - dimensional arrays of integers of dimensions 5001 by 5001 . set var5 [ 0 ] [ 0 ] and var6 [ 0 ] [ 0 ] to 1 . for each integer var7 from 1 to var2 - 1 ( both inclusive ) iterate over all positions var8 from var2 - 1 down to 0 ( both inclusive ) : set var5 [ var7 ] [ var8 ] to var5 [ var7 - 1 ] [ var8 - 1 ] if var3 [ var7 - 1 ] = " $$CONSTANT$$ " and var8 > 0 , set var5 [ var7 ] [ var8 ] to var6 [ var7 - 1 ] [ var8 ] if var3 [ var7 ] = " $$CONSTANT$$ " , and set var6 [ var7 ] [ var8 ] to ( var6 [ var7 ] [ var8 + 1 ] + var5 [ var7 ] [ var8 ] ) % $$CONSTANT$$ . 
given 2 - dimensional arrays of integers var5 and var6 , integers var7 and var2 and $$CONSTANT$$ string var3 , iterate over all positions var8 from var2 - 1 down to 0 ( both inclusive ) : set var5 [ var7 ] [ var8 ] to var5 [ var7 - 1 ] [ var8 - 1 ] if var3 [ var7 - 1 ] = " $$CONSTANT$$ " and var8 > 0 , set var5 [ var7 ] [ var8 ] to var6 [ var7 - 1 ] [ var8 ] if var3 [ var7 ] = " $$CONSTANT$$ " , and set var6 [ var7 ] [ var8 ] to ( var6 [ var7 ] [ var8 + 1 ] + var5 [ var7 ] [ var8 ] ) % $$CONSTANT$$ . 
given 2 - dimensional arrays of integers var5 and var6 , integers var7 and var8 and $$CONSTANT$$ string var3 , set var5 [ var7 ] [ var8 ] to var5 [ var7 - 1 ] [ var8 - 1 ] if var3 [ var7 - 1 ] = " $$CONSTANT$$ " and var8 > 0 , set var5 [ var7 ] [ var8 ] to var6 [ var7 - 1 ] [ var8 ] if var3 [ var7 ] = " $$CONSTANT$$ " , and set var6 [ var7 ] [ var8 ] to ( var6 [ var7 ] [ var8 + 1 ] + var5 [ var7 ] [ var8 ] ) % $$CONSTANT$$ . 
given an array of strings var1 , initialize var2 to length of var1 , var3 to string of length var2 . for each position var4 in var1 set var3 [ var4 ] to var1 [ var4 ] [ 0 ] . initialize var5 and var6 to 2 - dimensional arrays of integers of dimensions 5001 by 5001 . set var5 [ 0 ] [ 0 ] and var6 [ 0 ] [ 0 ] to 1 . 
given an array of strings var1 , initialize var2 to length of var1 , var3 to string of length var2 . for each position var4 in var1 set var3 [ var4 ] to var1 [ var4 ] [ 0 ] . initialize var5 and var6 to 2 - dimensional arrays of integers of dimensions 5001 by 5001 . set var5 [ 0 ] [ 0 ] and var6 [ 0 ] [ 0 ] to 1 . 
given an array of strings var1 , initialize var2 to length of var1 , var3 to string of length var2 . for each position var4 in var1 set var3 [ var4 ] to var1 [ var4 ] [ 0 ] . 
given 0 - based char typed array var0 . create char typed arrays var1 , var2 with values " $$CONSTANT$$ " , " $$CONSTANT$$ " , respectively . assign 0 to var3 . for all var4 $$CONSTANT$$ from 0 to length of var0 minus 1 do following operations . assign true to var5 . increase var3 by the number of entrances of var0 [ var4 ] in var1 . if var2 contains the value var0 [ var4 ] then assign false to var5 . if var5 is true and var0 [ var4 ] is odd value then add 1 to var3 . 
given 0 - based char typed array var0 . assign true to var5 . increase var3 by the number of entrances of var0 [ var4 ] in var1 . if var2 contains the value var0 [ var4 ] then assign false to var5 . if var5 is true and var0 [ var4 ] is odd value then add 1 to var3 . 
given 0 - based char typed array var0 . assign true to var5 . increase var3 by the number of entrances of var0 [ var4 ] in var1 . if var2 contains the value var0 [ var4 ] then assign false to var5 . 
given 0 - based char typed array var0 . assign true to var5 . increase var3 by the number of entrances of var0 [ var4 ] in var1 . 
given 0 - based char typed array var0 . assign true to var5 . increase var3 by the number of entrances of var0 [ var4 ] in var1 . 
given integers var0 , var1 , var2 . assign 0 to var3 . while var1 contains the character " 7 " or var2 contains the character " 7 " do following operations . add 1 to var3 . substract var0 from var2 . if var2 is negative value then substract 1 from var1 and add $$CONSTANT$$ to var2 . if var1 is negative value then assign 23 to var1 . 
given integers var0 , var1 , var2 . add 1 to var3 . substract var0 from var2 . if var2 is negative value then substract 1 from var1 and add $$CONSTANT$$ to var2 . if var1 is negative value then assign 23 to var1 . 
given integers var0 , var1 , var2 . add 1 to var3 . substract var0 from var2 . if var2 is negative value then substract 1 from var1 and add $$CONSTANT$$ to var2 . 
given integers var4 , var5 , var6 . assign var4 , var5 , var6 to var3 , var7 , var8 . assign hh * $$CONSTANT$$ + mm to var0 . assign 0 to var9 . while func0 ( var0 ) is $$CONSTANT$$ update var0 by func1 ( time , var3 ) and increment var9 . 
given integers var0 , var3 . decrease var0 by var3 . if var0 is negative then increase it by $$CONSTANT$$ * $$CONSTANT$$ . return var0 . 
given integers var0 , var3 . decrease var0 by var3 . if var0 is negative then increase it by $$CONSTANT$$ * $$CONSTANT$$ . 
given integers var0 , var1 , var2 . assign 0 to var3 . while var1 contains the character " 7 " or var2 contains the character " 7 " do following operations . add 1 to var3 . substract var0 from var2 . if var2 is negative value then substract 1 from var1 and add $$CONSTANT$$ to var2 . if var1 is negative value then assign 23 to var1 . when loop is ended , return var3 . 
given integers var4 , var5 , var6 . assign var4 , var5 , var6 to var3 , var7 , var8 . assign hh * $$CONSTANT$$ + mm to var0 . assign 0 to var9 . while func0 ( var0 ) is $$CONSTANT$$ update var0 by func1 ( time , var3 ) and increment var9 . return var9 . 
given integers var0 , var1 , var2 . assign 0 to var3 . as long as each of values var1 / 10 , var1 % 10 , var2 / 10 does not equal 7 and if var2 % 10 does not equal 7 or var3 is not divisible by var0 do following operations . substract 1 from var2 . if var2 equals - 1 then do following operations . assign $$CONSTANT$$ to var2 . substract 1 from var1 . if var1 equals - 1 then assign 23 to var1 . add 1 to var3 . 
given integers var0 , var1 , var2 . substract 1 from var2 . if var2 equals - 1 then do following operations . assign $$CONSTANT$$ to var2 . substract 1 from var1 . if var1 equals - 1 then assign 23 to var1 . 
given integers var0 , var1 , var2 . assign $$CONSTANT$$ to var2 . substract 1 from var1 . if var1 equals - 1 then assign 23 to var1 . 
given integers var0 , var1 , var2 . assign 0 to var3 . as long as each of values var1 / 10 , var1 % 10 , var2 / 10 does not equal 7 and if var2 % 10 does not equal 7 or var3 is not divisible by var0 do following operations . substract 1 from var2 . if var2 equals - 1 then do following operations . assign $$CONSTANT$$ to var2 . substract 1 from var1 . if var1 equals - 1 then assign 23 to var1 . add 1 to var3 . when the loop is ended , return ans / x . 
you are given integers var7 , var8 , var9 . set var1 to var7 , var2 to var8 and var10 to var9 . perform $$CONSTANT$$ binary search on the range 1 to var1 * var2 . let var0 to the middle of the current search . if function func0 ( var0 , var1 , var2 ) return $$CONSTANT$$ value less than var10 , increase the $$CONSTANT$$ bound , otherwise decrease the $$CONSTANT$$ bound . return the result of the binary search . 
given integers var1 , var2 , var5 . assign 1 to var6 . assign the value ( ( var1 * 1 ) * var2 ) + 1 to var7 . while var6 is less than var7 , assign to var8 the value ( var6 + var7 ) > > 1 and if func0 ( mid , n , var2 ) is less than var5 then assign mid + 1 to var6 , or assign var8 to var7 , in other case . return the resultant start - 1 . 
you are given $$CONSTANT$$ number var0 , $$CONSTANT$$ number var1 and $$CONSTANT$$ number var2 . you have to performing binary search . for this , set var3 to 1 and var4 to var0 * var1 ; while var3 + 1 is less than var4 you have to set var5 to var3 + var4 divided by 2 ( rounded down ) , set var6 to zero ; for each var7 between 1 and var0 you have to add the minimum between var5 - 1 divided by var7 ( rounded down ) and var1 to var6 ; if var6 is less than var2 you have to set var3 to var5 , otherwise you have to set var4 to var5 . if var4 is equal to var0 * var1 and var0 * var1 is greater than 2 you have to return var4 , otherwise you have to return var3 . 
given 0 - based char typed array var0 . create char typed arrays var1 , var2 with values " $$CONSTANT$$ " , " $$CONSTANT$$ " , respectively . assign 0 to var3 . for all var4 $$CONSTANT$$ from 0 to length of var0 minus 1 do following operations . assign true to var5 . increase var3 by the number of entrances of var0 [ var4 ] in var1 . if var2 contains the value var0 [ var4 ] then assign false to var5 . if var5 is true and var0 [ var4 ] is odd value then add 1 to var3 . when the loop is ended , return var3 . 
