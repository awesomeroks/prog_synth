given an integer array var0 , let var1 be the size of var0 . create an array var2 identical to var0 . sort var2 . initialize var4 to 0 . set var5 to 1 , so long as var5 is < = var1 , do the following in a loop : set var6 to var5 . initialize var7 to var1 - 1 , do the following in a loop so long as var6 is more than 0 : add var2 [ var7 ] to var4 , and decrement var7 and var6 . ( end of inner loop ) set var5 to var5 * 4 . ( end of outer loop ) return var4 . 
given integers var0 , var1 . if var0 does not exceed var1 then return var0 . let var2 be the smallest value such that ans * ( ans + 1 ) / 2 is not less than n - m . return var2 plus var1 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to create an array of numbers var2 and store in it the elements in var0 . set var3 to zero . you have to sort var2 . set var5 to var1 . while var5 is greater than zero you have to , for each var6 between 1 and var5 , add var2 [ var1 - var6 ] to var3 , divide var5 by 4 ( rounded down ) . you have to return var3 . 
given strings var0 , var1 . if length of var0 not equals to the length of var1 , return " NO " . if both var0 and var1 contain at least one character ' 1 ' or both of them do not contain ' 1 ' at all , return " YES " ; else return " NO " . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var1 to the length of var0 . you have to create an array of numbers var2 with the same elements than var0 . you have to sort var2 . you have to set var5 to zero and var6 to 1 . if var1 is equal to 1 you have to return var2 [ 0 ] . you have to set var7 to 1 . while var6 is less than or equal to var1 , you have to iterate var8 from var1 - 1 to var1 - var6 and you have to add var2 [ var8 ] to var5 ; you have to add 1 to var7 and multiplicate var6 by 4 . after the loop ends you have to return var5 . 
given integers var0 and var1 , initialize var2 to 0 , var3 to 2000000000 . perform the binary search on segment [ var2 ; var3 ] to find the smallest integer var5 such that var5 * ( var5 + 1 ) / 2 > = var0 - var1 . return var0 if var1 > = var0 , return var1 + var5 otherwise . 
given an array var0 and integers var1 , var2 . initialize var3 to the length of var1 , var4 to - 2147483648 . for each var5 from 0 to var3 exclusive , if var2 [ var5 ] is greater than var0 , set var4 to the maximum between var4 and var1 [ var5 ] - var2 [ var5 ] + var0 ; else set var4 to the maximum between var4 and var1 [ var5 ] . return var4 . 
given an array of strings var0 , initialize var1 to length of var0 . for each position var2 in var0 from var1 - 2 down to 0 initialize var5 to whether there exists a position var6 such that var6 is less than lengths of var0 [ var3 ] and var0 [ var3 + 1 ] and var0 [ var3 ] [ var6 ] ! = var0 [ var3 + 1 ] [ var6 ] and if at least one such position exists , then set var0 [ var3 ] to a prefix of var0 [ var3 ] of length var6 , where var6 is the smallest such position , otherwise set var0 [ var3 ] to a prefix of var0 [ var3 ] of length , which is equal to the smaller of lengths of var0 [ var3 ] and var0 [ var3 + 1 ] . return var0 . 
given integer var0 and integer arrays var1 , var2 . assign the length of var1 to var3 . create integer array var4 of size var3 at var6 th position containing the value var1 [ var6 ] - ( var2 [ var6 ] - var0 ) if var2 [ var6 exceeds var0 or containing the value var1 [ var6 ] in other case . return the largest value in var4 . 
you are given an array of numbers var1 , an array of numbers var2 , a number var0 . you have to return the maximum between var1 [ var5 ] + var0 - var2 [ var5 ] for each position var5 in var2 with var2 [ var5 ] greater than var0 , and var2 [ var5 ] for each position var5 with var2 [ var5 ] less than or equal to var0 . 
given arrays of integers var1 and var2 as well as a single integer var0 , for each element in the arrays , calculate a value var8 . for the var5 th element , var8 is calculated as follows : 1 . initialise var8 = var2 [ var5 ] 2 . if var8 is greater than var0 , subtract var7 - var0 from it . return the maximum var8 value obtained by considering all var3 elements for the above operation . 
given strings var0 , var1 . if the length of var0 not equals the length of var1 , return " NO " . if both var0 and var1 contain character ' 1 ' or both of them do not contain character ' 1 ' , return " YES " ; else return " NO " . 
you are given an array of numbers var1 , an array of numbers var2 , a number var0 . you have to return the maximum between var1 [ var5 ] + var0 - var2 [ var5 ] for each position var5 in var2 with var2 [ var5 ] greater than var0 , and var2 [ var5 ] for each position var5 with var2 [ var5 ] less than or equal to var0 . 
given integer var0 , integer arrays var1 , var2 . assign - 2147483648 to var4 . for each var5 from 0 to n - 1 , do following operations . assign var2 [ var5 ] - k to var8 , 0 to var9 . if var8 exceeds 0 then assign var1 [ var5 ] - rem to var9 . otherwise , assign var1 [ var5 ] to var9 . assign the larger of var9 , var4 to var4 . when the loop is ended , return var4 . 
you are given a number var1 and a number var2 . store in var3 the var2 - 1 power of var2 modulo 1000000007 . if var1 - var2 is greater than zero you have to multiplicate the var1 - var2 power of var1 - var2 by var3 , all calculations have to be done modulo 1000000007 . you have to return var3 . 
given a string var0 . initialize var1 to an empty string . iterate through characters of var0 and if the current character equals ' r ' , concatenate var1 with the concatenation of the next character and 10 . iterate through characters of var0 in the reversed order and if the current character equals ' l ' , concatenate var1 with the concatenation of the next character and 10 . return var1 . 
given array var1 . return the average sum of all contiguous length - var0 subarrays of var1 . 
you are given an array of numbers var1 , an array of numbers var2 ( indexing is 0 - based ) , and a number var0 . you have to set var4 to - 2147483648 . for each var5 in var1 if var2 [ var5 ] is greater than var0 you have to store in var4 the maximum between var4 and var1 [ var5 ] - var2 [ var5 ] + var0 , otherwise you have to store in var4 the maximum between var4 and var1 [ var5 ] . you have to return var4 . 
you are given the numbers var2 , var3 . you have to performing binary search to find the least var7 between 1 and 2000000000 in such a way that ( ( var7 * ( var7 - 1 ) ) divided by 2 ) plus var3 + var7 is greater than or equal to var2 . if it value does not exist you have to set var7 to - 1 . you have to return the minimum between var3 + var7 and var2 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var7 to - 2147483648 . for each position var6 in var1 do the following actions : if var1 [ var6 ] - var0 > = 0 , then set var7 to var1 [ var6 ] - var2 [ var6 ] + var0 if var7 < var1 [ var6 ] - var2 [ var6 ] + var0 , otherwise set var7 to var1 [ var6 ] if var7 < var1 [ var6 ] . return var7 . 
you are given a number var0 , an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var1 ( indexing is 0 - based ) . you have to return the maximum between ( var1 [ var5 ] - var2 [ var5 ] + var0 ) for each position var5 in var1 with var2 [ var5 ] greater than var0 , and var1 [ var5 ] , for each position var5 in var1 with var2 [ var5 ] less than or equal to var0 . 
given an array of integers var0 , initialize var1 to length of var0 . count the sum of all the elements of var0 and store the result in var2 . count the number of integers var5 between 1 and 5 ( both inclusive ) such that ( var2 + var5 ) % ( var1 + 1 ) is not equal to 1 . return the result . 
you are given an array of numbers var0 and an array of numbers var1 ( indexing is 0 - based ) . you have to set var2 to the length of var0 . you have to create an array of numbers var5 of length var2 , set var5 [ 0 ] to zero . you have to create an array of numbers var6 of length var2 , set var7 to 1 and set var9 to zero . for each var8 between 1 and var2 - 1 , you have to store in var9 the minimum between var9 and var7 - 1 , while var9 + 1 is less than var7 and ( var5 [ var6 [ ( var9 + 1 ) ] ] + ( var1 [ var6 [ ( var9 + 1 ) ] ] * var0 [ var8 ] ) ) is less than or equal to ( var5 [ var6 [ var9 ] ] + ( var1 [ var6 [ var9 ] ] * var0 [ var8 ] ) ) , you have to add 1 to var9 ; you have to set var5 [ var8 ] to ( var5 [ var6 [ var9 ] ] + ( var1 [ var6 [ var9 ] ] * var0 [ var8 ] ) ) , while var7 is greater than 1 and - 1 . 0 * ( var5 [ var6 [ ( var7 - 1 ) ] ] - var5 [ var6 [ ( var7 - 2 ) ] ] ) divided by ( var1 [ var6 [ ( var7 - 1 ) ] ] - var1 [ var6 [ ( var7 - 2 ) ] ] ) is greater than or equal to - 1 . 0 * ( var5 [ var8 ] - var5 [ var6 [ ( var7 - 2 ) ] ] ) divided by ( var1 [ var8 ] - var1 [ var6 [ ( var7 - 2 ) ] ] ) you have to subtract 1 to var7 ; you have to set var6 [ var7 ] to var8 and add 1 to var7 . after the loop ends , you have to return var5 [ var2 - 1 ] . 
given integers var7 , var8 . if var7 does not exceerd var8 then return var7 . assign to var3 the square toot of the value 2 * a . assign to var10 the value func0 ( 0 , var3 ) . return the value b + 1 + var10 . 
given integers var0 , var1 and 0 - based , integer typed arrays var2 and var3 . substract 1 from var0 and var1 . if in the range from var0 to var1 , inclusive , there is such var8 that var2 [ var8 ] does not equal var3 [ var8 ] then return " LIE " . otherwise , assign return " TRUTH " . 
you are given a number var0 , a number var1 , an array of numbers var2 and an array of numbers var3 ( indexing is 0 - based ) . if at some index var8 in var2 , less than var0 , var2 [ var8 ] is different to var3 [ var8 ] you have to set var5 to 1 , otherwise you have to set var5 to zero . if at some index var9 in var2 greater than or equal to var1 , var2 [ var9 ] is different to var3 [ var9 ] you have to set var5 to 1 . if var5 is equal to 1 you have to return " LIE " , otherwise you have to return " TRUTH " . 
you are given a number var0 and a number var1 . you have to create an array of strings var4 . you have to insert the decimal representation of the minimum between var1 + 1 and var0 + 1 in var4 . you have to set var2 to var0 and var3 to 0 . while var2 is greater than or equal to zero and var3 is less than or equal to var1 you have to insert the decimal representation of var2 plus " " plus the decimal representation of var3 in var4 ; you have to add 1 to var3 and subtract 1 to var2 . you have to return var4 . 
given array var1 . if its smallest element equals 1 , return - 1 . otherwise , return 1 . 
you are given a number var0 and an array of numbers var1 ( indexing is 0 - based ) . you have to create an array of strings var10 initially empty . you have to create an array of numbers var3 with the numbers between 1 and var0 . you have to set var6 to zero . for each var7 in var1 you have to set var8 to the length of var3 , var9 to ( var6 + var1 [ var7 ] ) modulo var8 , insert the decimal representation of var3 [ var9 ] in var10 with a space at the end , remove the element with index var9 in var3 and set var6 to var9 modulo length of var3 . after the loop ends , you have to return var10 . 
given array var1 . initialize the length of var1 to var3 . initialize the sorted array var1 to var4 . assign 0 to result . if var3 equals 1 then return var4 [ 0 ] . for all var7 s from 1 to var7 < = var3 , by multiplying var7 by 4 , increase the result by the sum of last var7 characters in var4 . return the result . 
given integers var0 , var1 . in first line of output , write the minimum of var0 and var1 , plus 1 . in each next line of output , write values i , j where i obtains values from 0 to var0 and j obtains values from var1 to 0 . 
given integer var0 and integer arrays var1 , var2 . return the largest value var1 [ var5 ] decreased by the larger of 0 and var2 [ var5 ] - var0 where var5 obtains values from 0 to length of var1 minus 1 . 
given an integer var3 , an integer var2 , an integer var4 , and a record __globals__.add 1 to __globals__.tenis . numbersets and subtract var2 from var3 if var3 is bigger than or equal to var2 . add 1 to __globals__.tenis . numbersets and subtract var2 from var4 if var4 is bigger than or equal to var2 . 
given a string var0 , initialize var1 to empty array of integers . for each position var2 in var0 in reverse order append var2 to the end of var1 if var0 [ var2 ] = " l " , append var2 to the begin of var1 otherwise . initialize var3 to empty string . for each element var4 in var1 append a string representation of var4 and " \ n " to the end of res . return var3 . 
you are given a number var0 and a number var1 . you have to subtract var1 to var0 . you have to performing binary search to find the smallest var2 between 1 and 2000000000 in such a way that var2 * ( var2 + 1 ) divided by 2 is greater than or equal to var0 . you have to return var2 + var1 . 
given integer arrays var0 , var1 , var2 . create char typed matrix var12 . for all var4 s from 0 to length of var1 minus 1 , do following operations . if var1 [ var4 ] does not equal 1 then add to var0 [ var1 [ var4 ] - 2 ] the value var2 [ var4 ] - 1 . if var1 [ var4 ] does not equal the length of var0 then add to var0 [ var1 [ var4 ] ] the value var0 [ var1 [ var4 ] - 1 ] - e [ var4 ] . assign 0 to var0 [ var1 [ var4 ] - 1 ] . when var4 becomes equal to length of var1 , return var0 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var7 to - 9223372036854775808 . for each position var8 in var1 set var7 to var1 [ var8 ] if var2 [ var8 ] < = var0 and var7 < var1 [ var8 ] , set var7 to var1 [ var8 ] - var2 [ var8 ] + var0 if var2 [ var8 ] > var0 and var7 < var1 [ var8 ] - var2 [ var8 ] + var0 . return var0 . 
you are given a number var1 , an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 ( indexing is 0 - based ) . set var8 to - 2147483648 . for each position var9 in var2 , if var3 [ var9 ] is greater than var1 store in var8 the maximum between var8 and var2 [ var9 ] - var3 [ var9 ] + var1 , otherwise store in var8 the maximum between var8 and var2 [ var9 ] . return var8 . 
you are given an integer k , arrays var1 and var2 . initialize integers var10 equal to ' 0 ' , var9 equal to ' 0 ' , var3 equal to length of array var1 and var4 equal to - 10000000000 . iterating over given array var1 , assign to the variable var6 the value var1 [ c _ i + 1 ] and the value var2 [ d _ i + 1 ] to the variable var7 . also , assign the value ( ( var7 > var0 ) ) ? ( ( var6 - ( var7 - var0 ) ) ) : ( var6 ) to the variable var8 , and assign the value of var8 to var4 if var8 > var4 . after the loop is ended , output var4 . 
given integer arrays var0 , var1 . let var2 be the largest value var1 [ var9 ] / var0 [ var5 ] and var3 be the number of appearances of this value where var1 [ var9 ] is divisible by var0 [ var5 ] , var9 obtains values from 0 to length of var1 to length of var1 minus 1 and var5 obtains values from 0 to length of var0 minus 1 . return var3 . 
given a character array var0 , initialise a new array var3 of integers . add the index ( assume var0 starting index is 1 ) of the characters whose ascii value is equal to 114 to the array var3 . now traverse var0 from the end and add the index of the characters in var0 whose ascii value is equal to 108 . finally return the array var3 . 
given integer var0 and integer typed array var1 . create char typed matrix var9 . assign to var2 the length of var1 . create a boolean array var3 of size equal to var2 * var0 containing true values at all positions var1 - 1 where var4 obtains values from 0 to var2 - 1 . assign 0 to var5 . for all var6 s from 0 to var2 - 1 do following operations . insert var1 [ var6 ] into var9 . assign true to var3 [ ( var1 [ var6 ] - 1 ) ] . for all var7 s from 0 to var0 - 2 do following loop . for all var8 s from var5 to var0 * var2 - 1 , if var3 [ var8 ] is true then assign var8 to var5 . otherwise , do following operations . assign true to var3 [ var8 ] . add s + 1 to the end of var9 . assign var8 to var5 . exit from the loop . when the loops are ended , return var9 . 
given two integers var0 and var1 . initialize var2 and var3 to var0 and var1 respectively . initialize var4 to ( 240 - var3 ) and var5 to 1 . until var4 is bigger than or equal to ( 5 * var5 ) , and var5 is less than var2 , decrease var4 by ( 5 * var5 ) and increment var5 . after iteration if var5 is equal to var2 and var4 - ( 5 * var5 ) bigger than or equal to zero return var5 . otherwise return ( var5 - 1 ) . 
given char arrays var0 , var1 . if the lengths of var0 and var1 are different then return " NO " . otherwise , if var0 and var1 are equal then return " YES " . otherwise , if both var0 and var1 contain the character ' 1 ' then return " YES " . otherwise , return " NO " . 
given a string var3 , and a string var4 . return " NO " if var3 or var4 consists only of the character ' 0 ' and the other string has a character which is not ' 0 ' , return " YES " otherwise . 
given an integer var0 and arrays var1 , var2 both of integer types . assign 0 to var9 and var8 . let var3 be the length of var1 . assign - 2147483648 to var4 . for all var5 s from 0 to var5 < var3 do following operations . assign the values of next elements in var1 and in var2 to var6 and var7 , respectively . if var7 is larger than var0 then set the larger of var4 and ( var6 + var0 ) - var7 to var4 . otherwise , set the larger of var4 and var6 to var4 . after the loop is ended , return var4 . 
given integer typed arrays var0 , var1 , var2 . create integer typed array var12 . assign 1 and 0 to var4 and var5 , respectively . for all var5 s from 0 to m - 1 , insert the larger of var0 [ 0 ] and var0 [ var1 [ var5 ] - 1 ] into var12 and update var0 [ 0 ] by the larger of var0 [ 0 ] and var0 [ ( var8 - 1 ) ] ) + var9 . when the loop is ended , return var12 . 
given arrays var0 , var1 . initialize var5 to 0 . for each element var3 in var0 and var4 in var1 , perform the following operations . initialize var7 to var3 + 1 . if var4 is greater than 1 , perform the following operations . initialize var8 to 0 , var9 to 1 . while var9 is less than var4 , multiply var9 by 4 and increase var8 by 1 . set var7 to var8 + var3 . set var5 to the maximum between var5 and var7 . return var5 . 
given array var0 you need to save indexes of var0 which values are equal to 114 into string with " \ n " and save indexes of var0 which values are equal to 108 after this you need also to move saved indexes of var0 which values are equal to 108 to string wih saved indexes of var0 which values are equal to 114 with " \ n " in reverse order return result string 
given integers var0 , var1 and integer arrays var2 , var3 . given integers var0 , var1 and integer arrays var2 , var3 . assign the length of var2 to var4 . create integer arrays var5 , var6 of sizes var4 where every element var5 [ var7 ] equals var2 [ var7 ] + var3 [ var7 ] and var6 [ var7 ] equals var2 [ var7 ] + var3 [ var7 ] . sort var6 . let var10 and var11 be the first and last elements of var6 , respectively . if max - min exceeds r - l then return - 1 . otherwise , return a char typed matrix var14 of size var4 at var7 th row containing the value var5 [ var13 ] + l - var10 . 
you are given an array of numbers var2 ( indexing is 0 - based ) , an array of numbers var3 ( indexing is 0 - based ) and a number var1 . you have to set var9 to - 1000000000 . for each position var10 in var2 if var3 [ var10 ] is greater than var1 you have to store in var9 the maximum between var9 and var2 [ var10 ] - var3 [ var10 ] + var1 , otherwise you have to store in var9 the maximum between var9 and var2 [ var10 ] . you have to return var9 . 
given integer arrays var0 , var1 . let var6 be the largest value var1 [ var9 ] / var0 [ var8 ] and var7 be the number of its occurences where var1 [ var9 ] is divisble by var0 [ var8 ] and var9 obtains values from 0 to m - 1 , var8 obtains values from 0 to n - 1 . return var7 . 
given arrays of integers var2 and var3 and an integer var1 , find the maximum value of var2 [ var9 ] minus the greater of var3 [ var9 ] - var1 and 0 over all positions var9 in var2 . return the result . 
you are given the numbers var0 , var1 , var2 , var3 , var4 , var5 , var6 , var7 , var8 , var9 , var10 , var11 . you have to set var12 to zero . if var1 is less than zero you have to add var6 to var12 . if var1 is greater than var4 you have to add var7 to var12 . if var2 is less than zero you have to add var8 to var12 . if var2 is greater than var5 you have to add var9 to var12 . if var0 is less than zero you have to add var10 to var12 . if var0 is greater than var3 you have to add var11 to var12 . you have to return var12 . 
you are given a string var4 , a string var5 , a number var2 . you have to set var6 to false and var7 to false . you have to set var6 to true if there exist a position var8 less than var2 in var4 with var4 [ var8 ] equal to 49 . you have to set var7 to true if there exist a position var8 less than var2 in var5 with var5 [ var8 ] equal to 49 . if var6 is equal to true and var7 is equal to true , or , var6 is different to true and var7 is different to true you have to return " YES " ; otherwise you have to return " NO " . 
given arrays var1 , var2 and number var0 for all elements of arrays var5 , var2 , var1 if current element of var2 < var0 set value of element var5 with index var6 = current element of var1 else set value = current element of var1 minus ( current element of var2 minus k ) sort array var5 and return it 
given arrays var5 , var6 of the same length and an integer var4 . iterate through elements of arrays and initialize var10 to the current element in var5 , var11 to the current element in var6 . if var11 is greater than var4 , initialize var12 to var10 - var11 + var4 . otherwise , initialize var12 to var10 . return the maximum among all values of var12 . return var8 . 
given an integer var0 , find the smallest integer , which is greater than var0 , such that all its digits are distinct and return the array , which contains one element equal to the result . 
given integers var0 and var1 , initialize var2 to 2 * ( var0 - var1 ) . perform the binary search on segment [ 0 ; 4000000000 ] to find the largest value of var3 such that var3 * ( var3 + 1 ) < var2 . return var1 + var3 . 
given arrays of integers var1 and var2 and an integer var0 , initialize var4 to - 2147483648 . for each position var6 in var1 initialize var5 to var1 [ var6 ] - var2 [ var6 ] + var0 if var2 [ var6 ] > var0 , initialize var5 to var1 [ var6 ] otherwise and set var4 to var5 if var4 < var5 . return var4 . 
given an integer var1 and a string var2 . initialize var3 to 0 , var4 to var1 , var5 to var2 , var6 to an empty array . push - 1 into var6 . for each var7 from 0 to the length of var5 exclusive , if var5 [ var7 ] equals ' 1 ' , push var7 into var6 . push the length of var5 into var6 . initialize var8 to var6 , var9 to the length of var8 - 2 . if var4 is greater than 0 , perform the following operations . initialize var10 to 1 . while var10 + var4 is less than the length of var8 , perform the following operations . add ( var8 [ var10 ] - var8 [ cur - 1 ] ) * ( var8 [ cur + k ] - var8 [ cur + k - 1 ] ) to var3 and increase var10 by 1 . otherwise , perform the following operations . initialize var11 to 1 . while var11 is less than the length of var8 , perform the following operations . initialize var12 to ( var8 [ var11 ] - var8 [ cur _ 1 - 1 ] - 1 ) . add var12 * ( var12 + 1 ) / 2 to var3 . increase var11 by 1 . return var3 . 
you are given an array of strings var0 . for each position var4 in var0 from greater to less except the highest , you have to performing binary search for find the longest preffix of var0 [ var4 ] wich is less than or equal to var0 [ var4 + 1 ] , you have to store in var0 [ var4 ] this preffix . you have to return all strings in var0 . 
you are given an integer var0 and arrays var1 , var2 of integer types . assign - 2147483648 to var3 . for all var7 s from 0 to var7 < length of var1 , do following operations . if var2 [ var7 ] is larger than var0 then assign the larger of f - ( t - k ) and var3 to var3 . otherwise , assign the larger of a and var3 to var3 . when var7 becomes equal to the length of var1 , exit from the loop . when the loop is ended , return var3 . 
you are given an array of numbers var0 ( indexing is 0 - based ) , an array of numbers var1 ( indexing is 0 - based ) . you have to set var6 to zero and var7 to zero . for each position var8 in var0 and each position var9 in var1 if var0 [ var8 ] is less than or equal to var1 [ var9 ] , if var1 [ var9 ] is divisible by var0 [ var8 ] you have to , set var10 to var1 [ var9 ] divided by var0 [ var8 ] ( rounded down ) , if var10 is greater than var6 set var6 to var10 and var7 to 1 , otherwise if var10 is equal to var6 add 1 to var7 . you have to return var7 . 
given an array var0 and integers var1 , var2 , var3 , var4 , var5 . initialize var15 to an empty array , var6 to the length of var0 , var7 , var8 , var9 , var10 , var11 , var12 , var13 to 0 . for each var14 from 0 to var6 exclusive , perform the following operations . add var0 [ var14 ] to var13 . add var13 / var5 to var12 . subtract ( var13 / var5 ) * var5 from var13 . add var13 / var4 to var11 . subtract ( var13 / var4 ) * var4 from var13 . add var13 / var3 to var10 . subtract ( var13 / var3 ) * var3 from var13 . add var13 / var2 to var9 . subtract ( var13 / var2 ) * var2 from var13 . add var13 / var1 to var8 . subtract ( var13 / var1 ) * var1 from var13 . return an array consisting of the following elements : var8 , var9 , var10 , var11 , var12 , var13 . 
given an array of integers var0 , initialize var1 to length of var0 . copy the array var0 into var2 and sort var2 in non - decreasing order . initialize var4 to 0 . for each position var5 in var2 set var4 to ( var4 + var2 [ var1 - 1 - var5 ] * var2 [ var5 ] ) % 10007 . return var4 % 10007 . 
given an array var0 . initialize var2 to var0 . sort the elements of var2 in increasing order . initialize var4 to 0 and var5 to 10007 . for each var6 from 0 to var1 - 1 , add the value of var2 [ var6 ] * var2 [ var1 - var6 - 1 ] to var4 and take var4 by modulo var5 . return var4 . 
given integer var0 , integer array var1 . create char matrix var9 . assign the length of var1 to var2 . create boolean array var3 of size n * k . for each var4 from 0 to k - 1 , assign true to var3 [ var1 [ var4 ] - 1 ] . assign 0 to var5 . for each var4 from 0 to k - 1 , do following operations . create char array var7 containing the value var1 [ var4 ] . for each var8 from 1 to n - 1 , do following operations . if var3 [ var5 ] is false then increment var8 , add j + 1 to the end of var7 . increment var5 . when var8 becomes equal var0 , add var7 to the end of var9 . when var4 becomes equal to var2 , return var9 . 
you are given an integer var0 . assign var0 to var1 . while var0 does not equal 1 do following operations . assign 1 to var2 . for all var3 s from 2 to var3 < = square root of var0 , if var0 is divisible by var3 then assign var2 by the larger of var2 and the maximum of var3 and n / i . after the current loop is ended , increase var1 by var2 and assign var2 to var0 . after all loops are ended , return var1 . 
you are given an integer var0 . assign 0 to var2 . assign var0 to var3 . while var0 is larger than 1 , do following operations . assign 0 to var2 . for all var1 s from 2 to var1 < = n / 2 do following operations . if var0 is divisible by y then do this . divide var0 by var1 . increase var3 by var0 . assign 1 to var2 . exit from current loop . when var1 becomes larger than n / 2 , exit from current loop . after the current loop is ended , if var2 does not equal 1 then increment var3 and exit from the main loop . when all loops are ended , return var3 . 
given a string var1 and an integer var0 . initialize var2 to an array , var3 , var4 to 0 . set var2 [ 0 ] to 1 . for each var5 from 0 to the length of var1 exclusive , perform the following operations . if var1 [ var5 ] equals ' 1 ' , increase var4 by 1 . if var4 is not less than var0 , add var2 [ var4 - var0 ] to var3 . increase var2 [ var4 ] by 1 . return var3 . 
given integers var0 , var1 . initialize var2 to the minimum between var0 and var1 , var4 to an array consisting of one single element var2 + 1 . for each var3 from 0 to var2 , push the concatenation of var3 and var2 - var3 into var4 . return var4 . 
given integers var0 , var1 and integer arrays var2 , var3 . assign 0 to var5 , var7 , var8 . substract 1 from var0 and from var1 . for all var6 s from 0 to length of var2 minus 1 do following operations . if var6 is in the range from var1 to var0 , exclusive , and if var2 [ var6 ] does not equal vet [ var6 ] then assign 1 to var7 . otherwise , if var6 is not in the range from var1 to var0 , exclusive , then erect var8 to the power of var2 [ var6 ] * vet2 [ var6 ] . when the loop is ended , if var7 equals 1 or var8 does not equal 0 then return " LIE " . otherwise , return " TRUTH " . 
given integers var0 , var1 , var2 . if var2 is larger then var1 then if var1 is not less than var0 then add values a / n , b / n to var3 . otherwise , if var2 is not divisible by var0 then assign - 1 to var3 . otherwise , add values a / n , b / n to var3 . if var2 was not larger than var1 then do following operations . exchange the values of var2 and var1 . if var1 is not less than var0 then add values a / n , b / n to var3 . otherwise , if var2 is not divisible by var0 then assign - 1 to var3 . otherwise , add values a / n , b / n to var3 . after this , return var3 . 
you are given integers var0 , var1 , var2 . if var0 is larger than var1 and var0 is larger than var2 or if var0 is less than 1 or if a + b is less than 0 or if var0 is larger than var1 and var2 is not divisible by var0 or if var0 is larger than var2 and var1 is not divisible by var0 , then return - 1 . otherwise , return the value ( var2 / var0 ) + ( var1 / var0 ) . 
given an integer var0 . assign var0 to var1 . assign 2 to var2 . while i * i does not exceed var0 , if var0 is divisible by var2 then do following operations . while var0 is divisble by var2 , divide var0 by var2 . decrease var1 by the value res / i . after the loop is ended , if var0 exceeds 1 then decrease var1 by the value res / n . return var1 . 
given three arrays var0 , var1 , and var2 . return the number of indices var5 from 0 to var3 ( exclusive ) , such that at least two of the three integers var0 [ var5 ] , var1 [ var5 ] , and var2 [ var5 ] equal one . 
you are given an array var1 of integer type . sort var1 . assign 0 to result . for all var7 s from 0 to var7 < length of var1 , update var8 by the value var3 [ var7 ] * var3 [ var2 - var7 - 1 ] taken by modulo 10007 and increase the result by var8 taken by modulo 10007 . when var7 becomes equal to the length of var1 , exit from the loop and return the result . 
you are given a number var0 and a string var1 . set var2 to var0 , var3 to var1 , var4 to zero , var5 to zero . while var3 is different to " " you have to store in var6 the larger position in var3 in such a way that either the number represented by the suffix of var3 starting in var6 is greater than or equal to var2 , or the length of the suffix of var3 starting in var6 is greater than the number of digits of var2 ; if such position does not exist , set var6 to zero ; store in var6 the least position greater than var6 with var3 [ var6 ] different to 48 , or set var6 to the last position in var3 if it does not exist ; set var7 to the number represented by the suffix of var3 starting at position var6 , set var3 to the preffix of var3 ending at position var6 - 1 , store in var8 the var5 power of var2 , add var8 * var7 to var4 and add 1 to var5 . you have to return var4 . 
you are given a number var0 . you have to create a var0 * var0 matrix of numbers var1 . you have to set var2 to var0 - 1 and var3 to var0 divided by 2 ( rounded down ) . set var1 [ var2 ] [ var3 ] to 1 . for each var4 between 2 and var0 * var0 , if var1 [ var2 + 1 modulo var0 ] [ var3 + 1 modulo var0 ] is equal to zero , set var2 to var2 + 1 modulo var0 , set var3 to var3 + 1 modulo var0 , otherwise set var2 to var2 - 1 + var0 modulo var0 ; set var1 [ var2 ] [ var3 ] to var4 . you have to return the matrix var1 . 
given an array var0 consisting of integers 0 , 1 , 2 , and 3 . update array var0 in the following way : 1 - replace every value , which is equal to 1 , with 0 or 1 , 2 - replace every value , which is equal to 2 , with 0 or 2 , 3 - and replace every value , which is equal to 3 , with 0 , 1 , or 2 , such that : 1 - the number of values in the resulting array var0 , which are equal to 0 , is as minimum as possible , 2 - and there is no position var5 ( 0 < = var5 < | var0 | - 1 ) in the resulting array var0 , where ( var0 [ var5 ] = = var0 [ i + 1 ] ) and ( var0 [ var5 ] ! = 0 ) . return the number of zeros in the resulting array var0 . 
given integers var4 , var5 , var6 . create integer array var8 . for each var7 from 0 to last position of __globals__.a . ns , if current values of __globals__.a . ns , __globals__.a . xs , __globals__.a . ys equal to var4 , var5 and to var6 , respectively , then return __globals__.a . ans [ var7 ] . when the loop is ended , return var8 . 
given an integer var0 , initialize var3 to empty array of strings . push " - 1 " to the end of var3 and return var3 if var0 = 1 or var0 = 2 . if var0 is even , then set var2 to ( var0 * var0 - 4 ) / 4 , rounded down , and push a string , which is obtained by concatenation of string representation of var2 , " " and string representation of var2 + 2 , to the end of var3 , otherwise set var2 to ( var0 * var0 - 1 ) / 2 , rounded down , and push a string , which is obtained by concatenation of string representation of var2 , " " and string representation of var2 + 1 , to the end of var3 . return var3 . 
you are given a number var0 and an array of numbers var1 . you have to set var3 to the length of var1 and var4 to var0 - 1 . you have to create an array of numbers var5 with the elements of var1 . you have to sort var5 . you have to set var7 to var4 divided by var3 ( rounded down ) . you have to set array of numbers var8 to the value of the function func0 evalated at var5 and at var7 . you have to set var9 to var4 - var3 * var8 [ 0 ] divided by var8 [ 1 ] - var8 [ 0 ] ( rounded down ) . you have to return var5 [ var7 ] and var5 [ var9 ] separated by a space . 
you are given a string var1 , a number var0 . you have to set var2 to zero . you have to create an array of numbers var3 of the length of var1 plus 1 . you have to set var3 [ 0 ] to 1 , and var4 to zero . for each position var5 in var1 you have to add the digit in var1 [ var5 ] to var2 , if var2 is greater than or equal to var0 you have to add var3 [ var2 - var0 ] to var4 , you have to add 1 to var3 [ var2 ] . after the loop ends ends you have to return var4 . 
you are given an array of numbers var1 ( indexing is 0 - based ) . you have to store in array of numbers var3 all elements of var1 sorted from lowest to highest . you have to return the sum of var3 [ var8 ] * var3 [ var2 - 1 - var8 ] for each position var8 into var3 , all calculations have to be done modulo 10007 . 
given integer var0 . create char typed matrix var14 . if var0 is even value and it does not equal 2 then do following operations . assign to var4 the square of var0 divided by the integer representation of " 4 " . insert into var14 the string value of var4 decreased by the integer representation of " 1 " . insert into var14 the string value of var4 increased by the integer representation of " 1 " . otherwise , if var0 is odd value and it does not equal 1 then do following operations . assign to var9 the square of var0 . assign to var11 the value var9 divided by the integer representation of " 2 " . insert into var14 the value var11 . insert into var14 the value var11 plus the integer representation of " 1 " . if none of these cases is true then insert " - 1 " into var14 . return var14 . 
you are given an array of numbers var0 and an array of numbers var1 indexing is 0 - based . store in var6 the maximum of the difference of each element var7 of var0 and the closest value to var7 that exists in var1 . you have to return var6 . 
you are given a string var1 and an integer var0 . set var2 to var1 , create a sorted set of characters var3 containing all characters in var2 . initialize a char to int map var4 . initialize var6 to 2147483647 , var7 to 0 . iterate from 0 to var0 - 1 with index var8 , in each iteration , if var4 doesn ' t contain the key var2 [ var8 ] , set var4 [ var2 [ var8 ] ] to 0 , increment var4 [ var2 [ var8 ] ] . if the size of var4 is less than that of var3 , continue to the beginning of the loop . otherwise , while var4 [ var2 [ var7 ] ] is more than 1 , decrement var4 [ var2 [ var7 ] ] and increment var7 , ( end of while loop ) set var6 the the minimum between var6 and var8 - var7 + 1 . return var6 . 
you are given an integer var0 . create an integer var1 . store the largest power of two var0 is divisible by into var1 . if var0 equals 1 then return a string consisting of mult / 4 * 3 and mult / 4 * 5 separated by space , both divisions are integer divisions otherwise , return a string consisting of ( ( n * n ) / 2 ) * mult and ( ( ( ( n * n ) + 1 ) / 2 ) * mult ) ) separated by space , both divisions are integer divisions . 
given integer var0 and char matrix var1 . assign to var2 the length of var1 . assign var0 to var3 . for each var4 from n - 1 downto 0 , then for each var8 from m - 1 downto 0 do following operations . if var1 [ var4 ] [ var8 ] equals 87 then assign 1 to var9 . otherwise , assign - 1 to it . assign to var10 the value var9 - var5 [ var7 ] [ var8 ] . if var10 does not equal 0 then do following operations . add 1 to var6 . add var10 to var5 [ var11 ] [ var12 ] where var11 and var12 obtain values from 0 to var4 and from 0 to var8 , respectively . return the resultant var6 . 
given integers var0 , var1 , var2 , var3 , var4 . assign the values ( ( var0 + var4 ) - 1 ) / var4 , 0 , ( var1 / var2 ) + 1 to var5 , var6 , var7 , respectively . for all var8 s from 0 to 59 do following operations . assign the values ( var6 + var7 ) / 2 , ( var1 - ( var2 * var9 ) ) / ( var3 - var2 ) , med - bt to var9 , var10 , var11 , respectively . if the values ( var5 * var10 ) + ( ( ( var5 - 1 ) * ( ( var10 * var3 ) - ( var10 * var2 ) ) ) / ( var2 + var3 ) ) exceeds var9 then assign var9 to var6 . otherwise , assign var9 to var7 . when the loop is ended , return var6 . 
given an integer var0 . if var0 modulo 2 equals 1 , set var1 to var0 * var0 / 2 , var2 to var0 * var0 / 2 + 1 ; else set var2 to var0 * var0 / 4 - 1 , var1 to var0 * var0 / 4 + 1 . if n , var1 or var2 equals 0 , return - 1 ; else return the concatenation of var1 , " " and var2 . 
given an integers var0 , var1 , var2 , var3 , var4 , var5 , var6 , string array var7 . assign var1 to 1 . assign var2 to 2 . assign var3 to n / 2 . assign var4 to 0 . for every var5 in range from 0 to var0 - 1 , for every var6 in range from 0 to var0 - 1 if | var3 - var6 | is less than or equal to var4 then add string of var1 into var7 and increase var1 by 2 , otherwise add string of var2 into var7 and increase var2 by 2 . if var6 is less than var0 - 1 then add " \ t " into var7 , if var5 is less than var3 increment var4 , else decrement var4 . return var7 . 
given integer var0 . if this . a is divisible by 4 then assign the values 3 * ( this . a / 4 ) , 5 * ( this . a / 4 ) to this . b and to this . c , respectively . otherwise , if this . a is even value then assign the values ( ( this . a * this . a ) / 8 ) * 2 , ( ( ( this . a * this . a ) / 8 ) + 1 ) * 2 to this . b and to this . c , respectively . otherwise , return the values this . c , this . b , separated by space . 
given string var1 and map var5 you need to initialize variable with value 2147483647 and copy string var1 to string var4 you need to fill map symbols in the string var1 and number of their appearances in this string if during the process of filling size of var5 > = size of var4 you need to reduce number of appereances in map of the symbol which index in strung var1 = = var3 and after this you need to increase var3 by 1 after this you need to find minimum from the value 2147483647 and var7 - var3 + 1 return found minimal 
you are given a number var0 . you have to create a var0 * var0 matrix of numbers var1 . you have to set var2 to zero and var3 to var0 divided by 2 ( rounded down ) . for each var4 between 0 and var0 * var0 - 1 you have to set var1 [ var2 ] [ var3 ] to var4 , set var2 to var2 + var0 - 1 modulo var0 , set var3 to var3 + 1 modulo var0 ; if var1 [ var2 ] [ var3 ] is different to 0 you have to set var2 to var2 + 2 modulo var0 , set var3 to var3 + var0 - 1 modulo var0 . you have to return the numbers in var1 . 
given integer typed arrays var0 , var1 . assign the length of var0 to var2 . assign 1 to the result . assign to var3 the number of elements in var1 with position var5 which are less than var0 [ var5 ] - x [ i _ 1 - 1 ] plus the number of elements which are less than var0 [ i _ 1 + 1 ] - x [ var5 ] . while iterating over array , in each case when var1 [ var5 ] is less than var0 [ var5 + 1 ] - var0 [ var5 ] , increase var0 [ var5 ] by var1 [ var5 ] . eventually , if var2 exceeds 1 then increase var3 by 1 . return var3 . 
given an integer var0 and an array var1 . return the sum of the values of ( var0 - var1 [ var5 ] ) over all values of var5 from 0 to the lengh of var1 - 1 exclsuive . 
given a string var0 , initialize var6 to empty array of strings . for each integer var2 from 0 to 999 ( both inclusive ) initialize var3 to string representation of var2 ; append " YES " to the end of var6 , append a string representation of var2 to the end of var6 and return var6 if var3 is a subsequence of var0 , append " NO " to the end of var6 and return var6 otherwise . 
given array ' a ' need to find sum of the elements of array var1 for all elements of array a need to find max between 1 and ( a - ( sum - current element of var1 ) ) and min between ( a - ( n - 1 ) ) and current element of var1 if max > min you need to save ( var1 [ var5 ] - ( max - min ) ) - 1 and add this value to char matrix var9 else you need to pass this iteration retrun result matrix 
given integer arrays var1 , var2 . assign the length of var1 to var3 . assign 0 and - 2147483648 to var4 and to var5 , respectively . for all var6 s from 0 to length of var1 minus 1 do following operations . if var1 [ var6 ] - hs [ var6 ] exceeds var5 then add 1 to var4 and assign var8 to var5 . otherwise , if var6 is last position in var1 or var1 [ var6 ] + hs [ var6 ] is less than var1 [ i + 1 ] then assign var1 [ var6 ] + hs [ var6 ] to var5 and add 1 to var4 . otherwise , assign var1 [ var6 ] to var5 . return the resultant var4 . 
given integers var0 , var1 , var2 , var3 . initialize var4 to 1 , var5 to 0 . for each var6 from 0 to var2 exclusive , perform the following operations . set var4 to var0 * var4 + var1 . if var4 is not greater than var3 , increase var5 by 1 ; else break the loop . return var2 - var5 . 
given integer array var0 . sort var0 . create integer array var4 of size var1 at var2 th position containing var0 [ n - i - 1 ] . return the sum of all values var0 [ var2 ] * b [ var2 ] modulo 10007 where var2 is from 0 to n - 1 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to set var1 to the length of var0 . you have to create an array of numbers var2 ( indexing is 0 - based ) of length var1 minus 1 . for each var4 in var2 you have to store in var2 [ var4 ] the sum of the elements in var0 at indices less than var4 + 2 . you have to create an array of numbers var5 of length var1 minus 1 . you have to set var5 [ var1 - 2 ] to var2 [ var1 - 2 ] . you have to iterate var6 between var1 - 3 and 0 , inside the loop you have to set var5 [ var6 ] to the maximum between var5 [ var6 + 1 ] and var2 [ var6 ] - var5 [ var6 + 1 ] . you have to return var5 [ 0 ] . 
given integers var7 and var8 , find the greatest common divisor of var7 and var8 . return the result . 
given integers var0 , var1 . assign 0 to var2 . while var0 is larger than or equal to 1 and var1 is larger than or equal to 2 or while var0 is larger than or equal to 2 and var1 is larger than or equal to 1 , do following loops . while var0 is larger than or equal to 1 and var1 is larger than or equal to 2 and var0 is less than or equal to var1 , do following operations . increment var2 . decrement var0 . decrement var1 by 2 . after the current loop is ended , do this . while var0 is larger than or equal to 2 and var1 is larger than or equal to 1 and var0 is larger than or equal to var1 , do following operations . increment var2 . decrement var0 by 2 . decrement var1 . after all loops are ended , return var2 . 
given a string var0 consisting of small letters of english alphabet . starting from second character check that if it is equal to previous character in var0 . if it is change it into next letter in alphabet , in case of ' z ' change it into ' a ' . after change , if it is not last character of var0 and equal to next character , again change it into next letter in alphabet , in case of ' z ' change it into ' a ' . after checking all characters , return var0 . 
given integers var0 , var1 . assign 0 to var2 . while 2 * var1 exceeds var0 and var0 exceeds 0 , add 1 to var2 , decrease var1 by 2 and decrement var0 . if 2 * newbies does not exceed var0 then add var1 to var2 . return var2 . 
given integers var2 , var3 , var1 , var4 and var5 , for as long as var4 < var1 , add to var4 ( var2 - var3 ) * 12 and increase var5 by 1 . return var5 . 
given integer var0 . assign 1 , 0 , 0 to var1 , var2 , var3 , respectively . for all var4 s from 1 to var0 , assign the values var2 , ( ( 3 * var1 ) + ( 2 * var2 ) modulo 10 ^ 9 + 7 and var3 to var3 , var2 and var1 , respectively . return var1 . 
given an integer arrays var0 and var1 , var2 is equal to length of var0 , var3 is equal to 1 , var5 is equal to var0 [ 0 ] . integer var6 in range from 1 to var2 - 1 . if var0 [ var6 ] - var1 [ var6 ] is greater than var5 , then increment var3 and assign var5 to var0 [ var6 ] , otherwise if var0 [ var6 ] + var1 [ var6 ] is less than var0 [ i _ 1 + 1 ] , then increment var3 and assign var5 to var0 [ var6 ] + var1 [ var6 ] , otherwise assign limit to var0 [ var6 ] . return var3 + var2 greater than 1 . 
given integers var0 , var1 . set var1 to the value of var1 modulo ( var0 * ( var0 + 1 ) ) / 2 . for each var2 from 0 to var0 - 1 , if var1 is less than var2 , break the loop ; else decrease var1 by var2 . return var1 . 
given integers var9 , var10 and integer typed arrays var4 , var5 . assign the length of var4 to var3 . create real typed 3 - dimensional array var6 of sizes n + 1 , l + 1 , 500 , consisting of ' - 1 ' s . return the result of function func0 ( 0 , l , k , n , prob , award , var6 ) . 
given integer var0 . assign 1 to var1 . assign 0 to var2 and var3 . for all var4 s from 2 to var0 do following operations . assign var3 to var2 . assign the value ( 2 * var3 ) + ( 3 * var1 ) modulo 10 ^ 9 + 7 to var3 . assign var2 to var1 . when the loop is ended , return var3 . 
given integer var0 . return the sum of powers of 2 from 1 to var0 . 
given integers var0 and var1 , initialize var8 to empty array of strings , var2 to var0 * ( var1 - 1 ) + 1 , var3 to 1 , var4 to var0 - var1 + 1 , var5 to var0 * ( 2 * var2 + ( var0 - 1 ) * var4 ) * 0 . 5 . append var5 , rounded down and converted to string , to the end of var8 . repeat the following actions var0 times : for each integer var7 from 0 to var0 - 1 ( both inclusive ) , append a string , obtained by concatenation of var3 , converted to string , and " " , to the end of var8 and add 1 to var3 if var7 < var1 - 1 , otherwise add var2 to var5 if var7 = var1 - 1 , append a string , obtained by concatenation of var2 , converted to string , and " " , to the end of var8 and add 1 to var2 . return var8 . 
given integers var0 and var1 , initialize var2 to 0 . for each integer var3 from 0 to var1 ( both inclusive ) initialize var5 to var0 - 2 * var3 , var6 to var1 - var3 , continue the enclosing loop if var6 < 0 or var5 < 0 , set var7 to the minimum of var5 and var6 / 2 ( rounded down ) , set var2 to var7 + var3 if var7 + var3 > var2 . return var2 . 
given an integer set var2 , an integer var0 , a char array var1 . for each i in var1 , if var1 [ i ] is equal to 42 than add i into the var2 . given a boolean var4 is equal to false . foreach var5 in var2 and var6 in range from 1 to var5 + var6 * 4 < var0 . if platform contains var5 + var6 and var5 + 2 * var6 and var5 + 3 * var6 and var5 + 4 * var6 than assign var4 to true . if var4 is equal to true return " yes " , else return " no " . 
given integers var0 , var1 . create char typed matrix var12 . create integer typed matrix var2 of sizes var0 , var0 . assign ( ( var1 - 1 ) * var0 ) + 1 to var2 [ 0 ] [ ( var1 - 1 ) ] and to var3 . for all var4 s from 1 to n - 1 , assign ( ( var2 [ ( var4 - 1 ) ] [ ( var1 - 1 ) ] + var0 ) - var1 ) + 1 to var2 [ var4 ] [ k - 1 ] and increase var3 by var2 [ var4 ] [ ( var1 - 1 ) ] . assign 1 to var5 . for all var6 s from 0 to n - 1 do following operations . for all var7 s from 0 to k - 2 , assign var5 to var2 [ var6 ] [ var7 ] and add 1 to var5 . assign 1 to var8 . for all var9 s from var1 to n - 1 , assign var2 [ var6 ] [ ( var1 - 1 ) ] + var8 to var2 [ var6 ] [ var9 ] and add 1 to var8 . when the loop is ended , add var3 to the end of var12 and insert arrays from var2 into var12 . return var12 . 
given a string var0 . initialize var1 to the first character of var0 . then for each var2 from 1 to the length of var0 - 1 , add the character opposite to the previous one to var1 . if it is already not the same as previous one , left it how it is . return var1 . 
you are given an integer var0 . assign 0 to resultant value . for all var2 s from 1 to var2 < = var0 , increment the result by the value 2 erected to the power of var2 . return the result . 
you are given integers var0 , var1 , var3 , var4 , var5 . let var6 be the lowest common multiple between var0 and var1 . set var7 to var3 / var0 , var8 to var3 / var1 , var9 to var3 / var6 , where ' / ' is division rounded down . if var4 is more than var5 , subtract var9 from var8 , otherwise subtract var9 from var7 . return ( var7 * var4 ) + ( var8 * var5 ) . 
given two integers var0 , var1 . if var1 equals 0 and var0 not equals 1 or var1 is greater than 9 * var0 , return the pair of - 1s . initialize var3 , var4 to empty strings . for each var5 from 0 to var0 exclusive , set var3 to the concatenation of var3 and the minimum between 9 and n , subtract the minimum between 9 and var1 from var1 . for each var6 from 0 to var0 - 1 exclusive , set var4 to the concatenation of var4 and the minimum between 9 and var2 , subtract the minimum between 9 and var2 from var2 . set var4 to the concatenation of var2 + 1 and var4 . return the concatenation of var4 , " " and var3 . 
given integer var0 . return the sum of powers of 2 from 1 to var0 . 
given integer var6 . set integer __globals__.proa . n to var6 , __globals__.proa . l to 1 and __globals__.proa . r to 20000000 . set __globals__.proa . ans to the largest value such that ( __globals__.proa . ans * __globals__.proa . ans + 1 ) / 2 < = __globals__.proa . n . set __globals__.proa . p equal to ( __globals__.proa . n - ( ( __globals__.proa . ans * ( __globals__.proa . ans + 1 ) ) divided by 2 ( rounded down ) ) ) . if __globals__.proa . p is not equal to 0 then set integer __globals__.proa . ans equal to __globals__.proa . p . return __globals__.proa . ans . 
given integers var1 , var2 and char typed array var3 . assign 0 to var4 . create integer array var5 of size 2 . for all var6 s from 0 to n - 1 do following operations . as long as var7 is less than var1 , do following operations . if var3 [ var7 ] equals 97 then add 1 to var5 [ 0 ] . otherwise , add 1 to var5 [ 1 ] . if var2 is not less than the minimum of var5 [ 0 ] and var5 [ 1 ] then add 1 to var7 and go to the next step of the loop . if var3 [ var7 ] equals 97 then substract 1 from var5 [ 0 ] . otherwise , substract 1 from var5 [ 1 ] . exit from the current loop . when the current loop is ended , update var4 by the larger of its current value and j - i . if var3 [ var7 ] equals 97 then substract 1 from var5 [ 0 ] . otherwise , substract 1 from var5 [ 1 ] . when var6 becomes equal to var1 , exit from the loop and return var4 . 
given 0 - based , char typed array var2 . assign 1 to the result . for all var4 s from 0 to var4 < length of var2 do following operations . assign 0 to var5 . if var2 [ var4 ] is in the range from 48 to 57 then assign var2 [ var4 ] - 48 to var5 . otherwise , if var2 [ var4 ] is in the range from 65 to 90 then assign ( var2 [ var4 ] - 65 ) + 10 to var5 . otherwise , if var2 [ var4 ] is in the range from 97 to 122 then assign var2 [ var4 ] - 97 + 36 . otherwise , if var2 [ var4 ] equals 45 then assign 62 to var5 . otherwise , if var2 [ var4 ] equals 95 then assign 63 to var5 . multiply the result by __globals__.vasyaandlabel . a [ var5 ] modulo __globals__.vasyaandlabel . mod . when the loop is ended , return var3 . 
given integer var1 and char typed arrays var2 , var3 . create an integer typed array var4 of size 7 . for all var6 s from 4 to 369 , add 1 to var4 [ i % 7 ] . return var4 [ x - 1 ] . 
given integer typed arrays var0 and var1 . let var5 be the sum of all elements in var0 . assign var1 to var7 with all values being decreased by 1 . create a boolean array var9 of size var2 . for all var6 s from 0 to k - 1 , substract var0 [ var7 [ var10 ] ] from var5 , add var5 * var0 [ var7 [ var10 ] ] to var4 and assign true to var9 [ var7 [ var10 ] ] . after the loop is ended , return the sum of such values var0 [ var11 ] * var0 [ ( ( var11 + 1 ) % var2 ) ] that both var9 [ var11 ] and var9 [ ( ( var11 + 1 ) % var2 ) ] are false values . 
you are given integer arrays var0 and var1 . let var2 be the size of var0 and var3 be the size of var1 . set var4 to the sum of all elements in var0 . initialize var6 to 0 . iterate from 0 to var3 - 1 with index var5 , in each iteration , let var8 be var1 [ var5 ] - 1 , subtract var0 [ var8 ] from var4 , add var4 * var0 [ var8 ] to var6 , and set var0 [ var8 ] to 0 . ( end of loop ) iterate from 0 to var2 - 1 with index var5 , in each iteration increase var6 by var0 [ var5 ] * var0 [ ( var5 + 1 ) mod var2 ] . after end of all iterations , return var6 . 
given an array of integers var3 and integers var0 , var1 and var2 , initialize var4 to length of var3 , var6 to 3 - dimensional array of integers of dimensions 2 by var0 + 1 by var1 + 1 . for each integer var7 from 0 to var1 ( both inclusive ) set var6 [ var4 % 2 ] [ 0 ] [ var7 ] to 1 . for each integer var8 from var4 - 1 down to 0 ( both inclusive ) iterate over all integers var9 from 0 to var0 ( both inclusive ) and for each integer var10 from 0 to var1 ( both inclusive ) set var6 [ var8 % 2 ] [ var9 ] [ var10 ] to ( var6 [ ( var8 + 1 ) % 2 ] [ var9 ] [ var10 ] + var6 [ var8 % 2 ] [ var9 - 1 ] [ var10 - var3 [ var8 ] ] ) % var2 if var9 > 0 and var10 > = var3 [ var8 ] , var6 [ var8 % 2 ] [ var9 ] [ var10 ] to var6 [ ( var8 + 1 ) % 2 ] [ var9 ] [ var10 ] otherwise . return var6 [ 0 ] [ var0 ] [ var1 ] . 
you are given an array var0 of integer type . let var1 be the length of var0 . assign 0 to var2 , var3 , var4 . if var1 equals 1 then return 1 . for all var5 s from 0 to var5 less than n - 1 do following operations . assign var4 to var5 . assign var5 to var6 . update var5 by the largest value such that var5 is less than n - 1 and var0 [ var5 + 1 ] is larger than or equal to var0 [ var5 ] . assign var5 + 1 to var4 . update var5 by the largest value which is not less than current value such that var5 is less than n - 1 and var0 [ var5 + 1 ] is less than or equal to var0 [ var5 ] . set the larger of var2 and var5 - j + 1 to var2 . when var5 becomes equal to var1 , exit from the loop . when the loop is ended , return var2 . 
given integers var0 , var1 and char array var2 . create array var3 of sizes = 100005 at first position containing 0 and at any other var4 th position containing var3 [ i - 1 ] + 1 if var2 [ i - 1 ] equals 97 , or in other case containing var3 [ i - 1 ] . assign 1 to l . assign n + 1 to r . while l is less than r do following operations . assign to var7 the value ( l + r ) / 2 . assign 0 to var8 . assign 1 to var8 if there is such case that var3 [ ( ( var9 + var7 ) - 1 ) ] - var3 [ ( var9 - 1 ) ] or ( var7 - ( var3 [ ( ( var9 + var7 ) - 1 ) ] - var3 [ ( var9 - 1 ) ] ) do not exceed var1 where var9 obtains values from 1 while i _ 1 + mid - 1 does not exceed var0 . if var8 equals 1 then assign to l the value mid + 1 . otherwise , assign var7 to r . return the resultant l - 1 . 
you are given a number var0 and a number var1 . you have to create an array of strings var3 initally empty . set var2 to 1 . while var1 is greater than or equal to zero you have to , if var1 - var2 is less than zero , insert the decimal representation of var1 to var3 and break from the enclosing loop , otherwise you have to , if var1 - var2 is equal to zero insert the string " 0 " to var3 and break from the enclosing loop , otherwise you have to , subtract var2 to var1 , add 1 to var2 , if var2 is greater than var0 set var2 to 1 . you have to return var3 . 
given integers var0 , var1 . assign the larger of var0 and var1 to var2 . assign the value ( ( var0 + var1 ) / 3 to var3 . return the less of var2 and var3 . 
you are given a number var0 and a number var1 . you have to set var2 to var0 , var3 to var1 , var5 to 76 and var4 to the ( var2 + 1 power of 2 ) - 2 . for each var6 between 0 and var2 - 1 you have to set var7 to var2 - var6 - 1 , if var3 is less than or equal to the var7 power of 2 you have to : if var5 is equal to 76 subtract the ( var7 + 1 power of 2 ) minus 1 to var4 , set var5 to 82 ; otherwise you have to : subtract the var7 power of 2 to var3 , if var5 is equal to 82 subtract the ( var7 + 1 power of 2 ) minus 1 to var4 , set var5 to 76 . you have to return var4 . 
given integers var0 , var1 and char typed matrix var2 . assign var1 to var4 . assign 0 to count . for all var10 s from n - 1 downto 0 do following operations . add var6 [ var10 ] to var7 . if var2 [ var10 ] [ var9 ] equals then assign 1 to var11 . otherwise , assign - 1 to var11 . if var7 does not equal var11 then do following operations . add 1 to var8 . assign var11 - var7 to var12 . add var12 to var7 . add var12 to var6 [ var10 ] . when the loop is ended , return var8 . 
given integers var0 , var1 . initialize var2 to 0 . while var0 is greater than 0 , var1 is greater than 0 and var0 or var1 is greater than 1 , perform the following operations . if var0 is not less than var1 , subtract 2 from var0 , decrease var1 by 1 ; else subtract 2 from var1 , decrease var0 by 1 . increase var2 by 1 . return var2 . 
given integers var1 , var2 and var7 , initialize var0 to array of integers of length 31 . set var0 [ 0 ] and var0 [ 1 ] to 1 . for each position var8 from 2 to 30 ( both inclusive ) set var0 [ var8 ] to var8 * var0 [ var8 - 1 ] . initialize var9 to 0 . for each integer var10 from 4 to var1 ( both inclusive ) continue the enclosing loop if var7 - var10 > var2 , set var11 to var7 - var10 , continue the enclosing loop if var11 < 1 and add var0 [ var1 ] * var0 [ var2 ] / ( var0 [ var10 ] * var0 [ var1 - var10 ] * var0 [ var11 ] * var0 [ var2 - var11 ] ) to var9 . return var9 , converted to string . 
given arrays of integers var0 and var1 , initialize var3 to 2 . for each position var4 in var0 , starting from 2 , if var0 [ var4 - 2 ] < var0 [ var4 - 1 ] - var1 [ var4 - 1 ] , then increase var3 by 1 , otherwise if var0 [ var4 ] > var0 [ var4 - 1 ] + var1 [ var4 - 1 ] , then increase var3 by 1 and add var1 [ var4 - 1 ] to var0 [ var4 - 1 ] . return var2 if var2 < 2 , return var3 otherwise . 
you are given a number var7 , a number var5 , a number var6 , a number var8 and a number var9 . you have to set var10 to ( ( ( var7 divided by var5 ( rounded down ) ) - ( ( var7 * ( the value of the function func0 at the arguments var5 and var6 ) ) ) divided by ( var5 * var6 ) rounded down ) ) * var8 ) . you have to add ( ( ( var7 divided by var6 ( rounded down ) ) - ( ( var7 * ( the value of the function func0 at the arguments var5 and var6 ) ) ) divided by ( var5 * var6 ) rounded down ) ) * var9 ) , to var10 . if var8 is greater than var9 you have to add ( ( ( var7 * ( the value of the function func0 at the arguments var5 and var6 ) ) divided by ( var5 * var6 ) rounded down ) * var8 ) , to var10 ; otherwise you have to add ( ( ( var7 * ( the value of the function func0 at the arguments var5 and var6 ) ) divided by ( var5 * var6 ) rounded down ) * var9 ) , to var10 . you have to return var10 . 
given arrays var0 , var1 . initialize var2 to the length of var0 , var4 to - 1 , var5 to 0 . for each var6 from 0 to var2 exclusive , perform the following operations . if var6 equals 0 , set var4 to var0 [ var6 ] and increase var5 by 1 . otherwise , if var0 [ var6 ] - var1 [ var6 ] is greater than var4 , set var4 to var0 [ var6 ] , increase var5 by 1 . otherwise , if var6 equals var2 - 1 or var0 [ var6 ] + var1 [ var6 ] is less than var0 [ var6 + 1 ] , set var4 to var0 [ var6 ] + var1 [ var6 ] , increase var5 by 1 ; else set var4 to var0 [ var6 ] . return var5 . 
given integers var0 , var1 and arrays var2 , var3 . if there exists such index var7 from 0 to var0 - 1 such that var2 [ var7 ] not equals to var3 [ var7 ] , return " LIE " . if there exists such index var8 from var1 to the length of var2 exclusive such that var2 [ var8 ] not equals to var3 [ var8 ] , return " LIE " . otherwise , return " TRUTH " . 
given integers var0 , var1 . assign the minimum of values var0 - 2 * var0 - m / 3 and the minimum of var0 , var1 to var2 . if both var1 and var0 are larger than or equal to 1 and m + n is larger than or equal to 3 then do following operations . assign the values var0 - ( 3 * var2 ) , var1 - ( 3 * var2 ) to var3 and var4 , respectively . if ( var0 + var1 ) - ( 3 * var2 ) is less than 0 then return t - 1 . otherwise , if both var4 and var3 are larger than or equal to 1 and var4 + var3 is larger than or equal to 3 then return t + 1 . otherwise , return var2 . if nothing was returned yet , return 0 . 
given a string var0 and index var1 into it . return the character which is not equal to both var0 [ var1 - 1 ] and var0 [ var1 + 1 ] . 
given integers var0 , var1 , var2 , var3 . add the value var2 < < 3 to var0 . if var0 is less than var1 and var2 is less than var3 then result is - 1 . otherwise , if var0 is not less than var1 then result is 0 . otherwise , if var2 exceeds var3 then result is the value ceil ( ( ( ( real ) ( var1 - var0 ) / ( var2 - var3 ) ) / 12 ) ) . otherwise , result is - 1 . return the result . 
given 0 - based , integer typed array var0 of integer type . assign the sorted version of var0 to var2 . assign 0 to result . assign the last position of var2 to var5 . as long as var5 is not less than 3 , do following operations . if var2 [ var5 ] or var2 [ var5 ] - 1 equal to var2 [ i _ 1 - 1 ] then do following loop . assign i _ 1 - 2 to var6 . as long as var6 is not less than 1 and var5 is not less than 3 , by decreasing var6 by 1 , do following operations . if var2 [ var6 ] does not equal var2 [ j - 1 ] and var2 [ var6 ] - 1 does not equal var2 [ j - 1 ] then go to the next step of the loop . if var2 [ var6 ] or var2 [ j - 1 ] equals var2 [ j - 1 ] and if var2 [ var5 ] or var2 [ var5 ] - 1 equals var2 [ i _ 1 - 1 ] then increase the result by var2 [ var5 - 1 ] * var2 [ var6 - 1 ] , assign j - 1 to var5 and exit from the loop . when all the loops are ended , return var3 . 
given an array of integers var0 , initialize var1 to length of var0 , var3 to array of integers of length var1 + 5 . for each integer var4 from 0 to var1 - 1 ( both inclusive ) set var3 [ var4 + 2 ] to var3 [ var4 + 1 ] and for each integer var5 from 0 to 1 iterate over all integers var6 from var4 to 0 in decreasing order : break from the enclosing loop if ( ( var4 - var6 + var5 ) % 2 ) - th bit ( 0 - based starting from least significant ) of var0 [ var6 ] is 0 ; set var3 [ var4 + 2 ] to var4 - var6 + 1 + var3 [ var6 ] if var4 - var6 + 1 + var3 [ var6 ] > var3 [ var4 + 2 ] . return var1 - var3 [ var1 + 1 ] . 
you are given arrays var0 , var1 of integer types . assign 0 to var2 . let var3 and var4 be the lengths of var0 and var1 , respectively . assign 0 and m - 1 to var7 and var8 , respectively . assign ( var7 + var8 ) / 2 to var9 . iterating over var0 , where var10 is current character , do following operations . assign 0 to var7 . assign m - 1 to var8 . while high - low is larger than 1 , do following operations . assign ( var7 + var8 ) / 2 to var9 . if var1 [ var9 ] equals var10 then assign var9 to var7 and var8 . otherwise , if var1 [ var9 ] is less than var10 then assign var9 to var7 . otherwise , if var1 [ var9 ] is larger than var10 then assign var9 to var8 . when high - low becomes equal to 1 , exit from the loop . after the current loop is ended , update ams by the larger of var2 and the minimum of values var1 [ var7 ] - var10 , var1 [ var8 ] - var10 taken by module . after all loops are ended , return var2 . 
given arrays var0 , var1 both of integer types . let var4 be the length of var0 . create a matrix var5 of sizes var4 , 2 and of integer type . for all var6 s from 0 to var6 < var4 , assign the value of next element in var0 to var5 [ var6 ] [ 0 ] and assign the value of next element in var1 to var5 [ var6 ] [ 1 ] . after the loop is ended , assign the minimum value of var4 and 2 to var7 . for all var8 s from 1 to var8 < n - 1 do following operations . if var5 [ var8 ] [ 0 ] - var5 [ ( var8 - 1 ) ] [ 0 ] is larger than var5 [ var8 ] [ 1 ] then increment var7 . otherwise , if var5 [ ( var8 + 1 ) ] [ 0 ] - var5 [ var8 ] [ 0 ] is larger than var5 [ var8 ] [ 1 ] then increment var7 and increment var5 [ var8 ] [ 0 ] by var5 [ var8 ] [ 1 ] . after all loops are ended , return var7 . 
given arrays of integers __globals__.a . ns , __globals__.a . xs , __globals__.a . ys , __globals__.a . ans and integers var4 , var5 , var6 , initialize var8 to empty array of integers . for each position var7 in __globals__.a . ns append __globals__.a . ans [ var7 ] to the end of var8 and return var8 if var4 = __globals__.a . ns [ var7 ] , var5 = __globals__.a . xs [ var7 ] and var6 = __globals__.a . ys [ var7 ] . return var8 if the cycle above ended successfully . 
given two integer arrays var1 and var0 , initialize var2 to the length of the array var0 , initialize an array var3 of var2 arrays of size 2 . for each position var4 from 0 to var2 ( not inclusive ) , store var0 [ var4 ] in var3 [ var4 ] [ 0 ] and store var1 [ var4 ] in var3 [ var4 ] [ 1 ] . initialize var5 to - 2147483648 , and var6 to 1 . for each position fr var7 om 0 to var2 - 1 ( not inclusive ) do : - if var3 [ var7 ] [ 0 ] - var3 [ var7 ] [ 1 ] > var5 then add one to var6 and store var3 [ var7 ] [ 0 ] in var5 else if var3 [ var7 ] [ 0 ] + var3 [ var7 ] [ 1 ] < var3 [ ( var7 + 1 ) ] [ 0 ] then add one to var6 and store var3 [ var7 ] [ 0 ] + var3 [ var7 ] [ 1 ] in var5 , else store var3 [ var7 ] [ 0 ] in var5 . return var6 . 
given integer var0 and char typed array var1 . assign 0 to var2 . assign the length of var1 to var4 . create array var5 of size 128 containing 1 at position ( int ) var1 [ 0 ] . for all var3 s from 1 to n - 1 do following operations . if var5 [ ( int ) var1 [ var3 ] ] equals then assign the value ( var3 - var2 ) + 1 to var4 . add 1 to var5 [ ( int ) var1 [ var3 ] ] . as long as var2 is less than var3 and var5 [ ( int ) var1 [ var3 ] ] exceeds 1 , substract 1 from var5 [ ( int ) var1 [ var3 ] ] , add 1 to var2 and update var4 by the minimum of var4 and i - j + 1 . when the loop is ended , return var4 . 
you are given integers var0 , var1 . assign values var1 - 1 , 1 to variables var2 , var3 . create an array var4 of integer type , initially consisting of elements 1 , 1 . for all var5 s from 0 to var5 < var0 do following operations . create an array var6 of integer type , initially consisting of elements 0 , 0 . if the value var2 & ( 1 < < var5 ) equals 0 then do following operations . assign the value 1 + var4 [ 1 ] to var6 [ 0 ] . update the value of var6 [ 1 ] by the value ( 1 + var3 ) + var4 [ 1 ] . otherwise , if the value var2 & ( 1 < < var5 ) was not equal 0 then do following operations . assign the value ( 1 + var3 ) + var4 [ 0 ] to var6 [ 0 ] . update the value of var6 [ 1 ] by the value 1 + var4 [ 0 ] . after this , multiply var3 by 2 and increment it by 1 . initialize var6 to var4 . after the loop is ended , return the value var4 [ 0 ] - 1 . 
given an integer var0 , if var0 % 3 = 0 , then initialize var5 to var0 / 3 and return the concatenation of var2 * var5 , converted to string , " " and var3 * var5 , converted to string , otherwise if var0 % 4 = 0 , then initialize var6 to var0 / 4 and return the concatenation of var1 * var6 , converted to string , " " and var3 * var6 , converted to string , otherwise if var0 % 5 = 0 , then initialize var7 to var0 / 5 and return the concatenation of var1 * var7 , converted to string , " " and var2 * var7 , converted to string , otherwise if var0 < = 2 , then return " - 1 " , otherwise if var0 is odd , then return the concatenation of ( var0 * var0 - 1 ) / 2 , converted to string , " " and ( var0 * var0 - 1 ) / 2 + 1 , converted to string , otherwise return the concatenation of ( var0 * var0 ) / 4 - 1 , converted to string , " " and ( var0 * var0 ) / 4 + 1 , converted to string . 
given integer var0 . if var1 is even value then assign values var1 / 2 , ( var4 * var4 ) - 1 , h * h + 1 to var4 , var2 and var3 , respectively . if var1 is odd value then assign values ( ( var1 * var1 ) - 1 ) / 2 , ( ( ( var1 * var1 ) - 1 ) / 2 ) + 1 to var2 and var3 , respectively . return var2 and var3 . 
given arrays of integers var0 and var1 , initialize var3 to length of var0 , var4 to length of var1 , var6 to 0 . find the sum of all elements of var0 and store the result in var5 . for each position var8 in var1 add var0 [ var1 [ var8 ] - 1 ] to var6 . initialize var9 and var10 to 0 . for each position var11 in var1 add ( var5 - var0 [ var1 [ var11 ] - 1 ] ) * var0 [ var1 [ var11 ] - 1 ] to var9 . add ( var5 - var6 ) * var6 to var9 and divide var9 by 2 , rounding the result down . for each position var12 in var0 add var0 [ var12 % var3 ] * var0 [ ( var12 + 1 ) % var3 ] to var9 if both var12 and ( var12 + 1 ) % var3 does not present in var1 . return var9 . 
given integers var0 , var1 . while var1 is greater than 0 , perform the following operations . for each var2 from 1 to var0 , if var1 is greater than var2 , subtract var2 from var1 ; else return var1 . return 0 . 
given an integer array var2 and integer var1 . set var3 to length of var2 and var4 to var1 . initialize var6 to empty integer matrix with ( var3 + 1 ) rows and ( var3 + 1 ) columns . set var6 [ 0 ] [ 0 ] to one . set __globals__.increasesequence . mod to 1000000007 , and let mod be same as this . for each var7 between 0 inclusive and var3 exclusive , and for each var8 between 0 inclusive and var7 + 1 inclusive , if ( var2 [ var7 ] + var8 ) is equal to var4 , then set var6 [ var7 + 1 ] [ var8 ] to ( var6 [ var7 + 1 ] [ var8 ] + var6 [ var7 ] [ var8 ] ) modulo mod . after , check if var8 is not smaller than 1 , if so then set var6 [ var7 + 1 ] [ var8 ] to ( var6 [ var7 + 1 ] [ var8 ] + var6 [ var7 ] [ ( var8 - 1 ) ] ) modulo mod . in the case of ( var2 [ var7 ] + var8 ) is not equal to var4 , check if var2 [ var7 ] [ x ] is equal to ( var4 + 1 ) , if so set var6 [ var7 + 1 ] [ var8 ] to ( var6 [ var7 + 1 ] [ var8 ] + ( ( var6 [ var7 ] [ ( var8 + 1 ) ] * ( var8 + 1 ) ) modulo mod ) ) modulo mod , set var6 [ var7 + 1 ] [ var8 ] to ( var6 [ var7 + 1 ] [ var8 ] + var6 [ var7 ] [ var8 ] ) modulo mod , and set var6 [ var7 + 1 ] [ var8 ] to ( var6 [ var7 + 1 ] [ var8 ] + ( var6 [ var7 ] [ var8 ] * var8 ) ) modulo mod . after all , return var6 [ var3 ] [ 0 ] . 
given integer var0 and char typed arrays var1 , var2 . assign var0 and var2 to var3 and var4 , respectively . if var4 is equals to " week " then do following operations . substract 1 from var3 . assign 0 to var5 . assign 4 to var7 . for all var6 s from 0 to 365 do following operations . if var7 equals var3 then add 1 to var5 . add 1 to var7 . if var7 equals 7 then assign 0 to var7 . when the loop is ended , return var5 . if var4 was not equal to " week " then if var3 does not exceed 29 then return 12 or if var3 does not exceed 30 then return 11 , otherwise , return 7 . 
given 0 - based , integer typed arrays var0 and var1 . assign to var2 the length of var0 . assign 0 to var4 and to var5 . for all var6 s from 0 to n - 1 do following operations . if var6 equals 0 or var0 [ var6 ] - var1 [ var6 ] exceeds var4 then add 1 to var5 and assign var0 [ var6 ] to var4 . otherwise , if var6 equals n - 1 or var0 [ var6 ] + var1 [ var6 ] is less than var0 [ i _ 1 + 1 ] then add 1 to var5 and assign var0 [ var6 ] + var1 [ var6 ] to var4 . otherwise , assign var0 [ var6 ] to var4 . when the loop is ended , return var5 . 
given integer var0 . if var0 is even value then result is a / 2 . otherwise , result is n / 2 + 1 . return result . 
you are given a number var0 and a number var1 . if var0 is greater than or equal to 2 * var1 set var2 to var1 , otherwise if var1 is greater than or equal to 2 * var0 set var2 to var0 , otherwise set var2 to ( var0 + var1 ) divided by 3 ( rounded down ) . you have to return var2 . 
you are given a number var0 and a number var1 . you have to set var2 to zero . you have to iterate , inside the loop , if var0 is equal to 1 and var1 is equal to 1 you have to break from the enclosing loop , if var0 is equal to 0 or var1 is equal to zero you have to break from the enclosing loop , if var0 is greater than var1 add 1 to var2 , subtract 2 to var0 , subtract 1 to var1 ; otherwise add 1 to var2 , subtract 2 to var1 , subtract 1 to var0 . you have to return var2 . 
given integers var0 , var1 . if var0 is greater than var1 , set var2 to var1 and if var0 is greater than 2 * var1 , set var3 to 2 * var1 ; else set var3 to var0 . if var0 is less than var1 , set var2 to var0 and if var1 is greater than 2 * var0 , set var3 to 2 * var0 ; else set var3 to var1 . if var2 is even , initialize var4 to var2 / 2 , var5 to var4 ; else initialize var4 to var2 / 2 + 1 , var5 to var2 / 2 . initialize var6 to var3 - var4 . return var5 + var6 / 3 . 
given a string var1 . initialize var2 to var1 . for each var3 from 1 to the length of var2 exclusive , if var2 [ var3 ] equals var2 [ i - 1 ] , perform the following operations . for each var4 from 97 to 122 , if var4 not equals var2 [ i - 1 ] and var3 + 1 is not less than the length of var2 or var2 [ i + 1 ] not equals var4 , set var2 [ var3 ] to var4 and break the loop . return var2 . 
you are given a string var1 . you have to set var2 to var1 . for each position var4 in var2 except the firstone if var2 [ var4 ] is equal to var2 [ var4 - 1 ] you have to , for each var5 between 97 and 122 if ( var2 [ var4 - 1 ] is different to var5 ) and is not true that ( var4 + 1 is less than var3 and var2 [ var4 + 1 ] is equal to var5 ) , you have to set var2 [ var4 ] to var5 and break from the enclosing loop . you have to return var2 . 
you are given integers var1 , var2 . assign 0 to result . while both var1 and var2 are larger than 0 , do following loop . if var1 is larger than or equal to var2 then do following operations . decrease var1 by 2 . decrement var2 . if var1 and var2 are larger than or equal to 0 then increment the result . otherwise , exit from the loop . if var1 was less than var2 then do following operations . decrease var2 by 2 . decrement var1 . if var1 and var2 are larger than or equal to 0 then increment the result . otherwise , exit from the loop . when at least one of values var1 or var2 becomes equal to 0 , exit from the loop . when the loop is ended , return the result . 
given integers var0 , var1 . initialize var2 to the least common multiple of var0 and var1 , var3 to var2 / var0 , var4 to var2 / var1 . if var0 is greater than var1 , increase var3 by 1 ; else increase var4 by 1 . if var3 is less than var4 , return " Masha " ; else if var3 is greater than var4 , return " Dasha " ; else reteurn " Equal " . 
given integer var0 and integer arrays var1 , var2 . create integer arrays var4 and var5 of sizes var3 at var7 th position containing the values var1 [ var7 ] - d [ var7 ] + 1 and var2 [ var7 ] / p - c [ var7 ] / p , respectively . add 1 to each element in var5 with such position var7 that var1 [ var7 ] is divisible by var0 . create real typed array var6 of size var3 at var7 th position containing the value 1 - pcount [ var7 ] / range [ var7 ] . return the sum of all values 2 * ( 1 . 0 - ( var6 [ var11 ] * var6 [ ( ( var11 + 1 ) % var3 ) ] ) ) where var11 obtains values from 0 to n - 1 . 
given integers var0 , var1 . initialize var3 to an empty array . push var1 * var0 * 6 - 1 into var3 . for each var2 from 0 to var0 exclusive , push the concatenation of var1 * ( 6 * var2 + 1 ) , var1 * ( 6 * var2 + 2 ) , var1 * ( 6 * var2 + 3 ) , var1 * ( 6 * var2 + 5 ) into var3 . return var3 . 
given integers var4 , var5 , var6 . return the sum of values func0 ( x , var3 ) * func0 ( y , ( var6 - var3 ) ) where var3 obtains values from 4 ot z - 1 . 
you are given a number var0 , a number var1 and a string var2 . you have to set var7 to zero and var5 to zero . for each position var6 in var2 if the minimum between the number of characters " a " in var2 between position var5 and position var6 ( both inclusive ) and the number of characters " b " in var2 between position var5 and position var6 ( both inclusive ) is greater than var1 you have to add 1 to var5 , otherwise you have to add 1 to var7 . you have to return var7 . 
you are given a number var1 . you have to return the total number of digits in all numbers between 1 and var1 . 
given integer var3 . return the sum of all values func0 ( var2 ) where var2 is from 1 to var3 . 
given arrays of integers var0 , var1 . assign var2 to the length pf array var0 . if var2 is less or equal to 2 , return var2 as answer . otherwise assign var4 to 2 . for each var5 from 1 inclusive to var2 - 1 exclusive do such operation : ( if difference between var0 [ var5 ] and var1 [ var5 ] is bigger than var0 [ var5 - 1 ] , increment var4 . if sum of var0 [ var5 ] and var1 [ var5 ] is less than var0 [ var5 + 1 ] , increment var4 and increase var0 [ var5 ] by var1 [ var5 ] ) . return var4 . 
given integers var1 and var2 , find the sum of ( var1 - var6 + 1 ) * ( var2 - var7 + 1 ) over all pairs of integers ( var6 ; var7 ) such that 2 < = var6 < = var1 , 2 < = var7 < = var2 and var6 and var7 are even . return the result . 
you are given an array var0 of char type . if var1 is even number then assign values ( ( var1 * var1 ) / 4 ) - 1 , ( ( var1 * var1 ) / 4 ) + 1 to var3 and var4 , respectively . otherwise , assign values ( var1 * var1 ) / 2 , ( ( var1 * var1 ) / 2 ) + 1 to these variables . return var3 and var4 . 
given array var0 need to find its length and do pass length times need to save first element of array var0 in variuable var4 need to through the arrays var0 and var1 if current value of var0 minus current value of var1 is bigger than var4 and increase answer by 1 if var6 is not the last index and sum of current elements of var0 and var1 is less than next elements set var4 value to sum of current elements of var0 and var1 and increase answer by 1 else if var6 is the last element increase answer by 1 else set var4 value to current element of var0 return found answer 
you are given an integer var0 , an integer var1 , an integer var2 , an integer var3 , an integer var4 , and an integer var5 . let ' s assume that there is a 2d array of size 2 * 2 containing distinct numbers from 1 to 9 . your task is to find these numbers such : 1 - the sum of numbers in the first row is var0 , 2 - the sum of numbers in the second row is var1 , 3 - the sum of numbers in the first column is var2 , 4 - the sum of numbers in the second column is var3 , 5 - the sum of numbers in the main diagonal is var4 , 6 - the sum of numbers in the secondary diagonal is var5 . return - 1 if the values for these cells do not exist , return these numbers otherwise . 
given integers var2 , var1 , var0 , var3 and var4 . calculate least common multiply value of var0 and var1 and store it into var5 . if var3 is bigger than var4 , initialize var6 to var4 then var4 to var3 then var3 to var6 then var6 to var0 then var0 to var1 then var1 to var6 . initialize var7 to var2 divided by var0 rounded down multiplied by var4 . initialize var8 to var2 divided by var5 rounded down . increase var7 by ( var2 divided by var1 rounded down minus var8 ) * var3 . return var7 . 
you are given a number var0 and a number var1 . you have to set var2 to zero . while var0 is greater than or equal to 2 and var1 is greater than or equal to 1 , or , var0 is greater than or equal to 1 and var1 is greater than or equal to 2 ; if var0 is greater than var1 you have to subtract 2 to var0 , subtract 1 to var1 , add 1 to var2 ; otherwise you have to subtract 2 to var1 , subtract 1 to var0 , add 1 to var2 . you have to return var2 . 
given arrays of integers var1 and var2 , find the sum of product of var1 [ var8 ] and the smallest value of var2 between positions 0 and var8 ( both inclusive ) across all positions var8 in the arrays . return the result . 
you are given an array of numbers var0 . you have to set var6 to zero and var1 to the length of var0 . you have to create a ( var1 + 1 ) * 3 matrix var3 . for each var4 between 1 and var1 you have to set var2 to var0 [ var6 ] and add 1 to var6 ; you have to set var3 [ var4 ] [ 0 ] to the maximum among var3 [ var4 - 1 ] [ 0 ] , var3 [ var4 - 1 ] [ 1 ] and var3 [ var4 - 1 ] [ 2 ] ; if var2 is equal to 1 or var2 is equal to 3 you have to set var3 [ var4 ] [ 1 ] to the maximum between var3 [ var4 - 1 ] [ 0 ] + 1 and var3 [ var4 - 1 ] [ 2 ] + 1 ; if var2 is equal to 2 or var2 is equal to 3 you have to set var3 [ var4 ] [ 2 ] to the maximum between var3 [ var4 - 1 ] [ 0 ] + 1 and var3 [ var4 - 1 ] [ 1 ] + 1 . you have to return var1 minus the maximum among var3 [ var1 ] [ 0 ] , var3 [ var1 ] [ 1 ] and var3 [ var1 ] [ 2 ] . 
given integers var0 , var1 , var2 . assign 0 to result . as long as var1 is not less than 2 and var2 is not less than 1 or while var1 is not less than 1 and var2 is not less than 2 do following operations . if var1 exceeds var2 then add 1 to result , substract 2 from var1 , substract 1 from var2 . othetrwise , substract 1 from var1 , substract 2 from var2 and add 1 to the result . when the loop is ended , return var5 . 
given integers var0 , var1 and var2 . initialize var3 to 1 . 0 . for every var4 between 0 inclusive and var2 inclusive , multiply var3 by ( ( real ) ( var1 - var4 ) / ( real ) ( ( var0 + 1 ) + var4 ) ) . after , set var3 to ( 1 . 0 - var3 ) . if var3 is not bigger than 0 . 0 , return 0 . 0 , otherwise return var3 . 
given integers var0 , var1 , var2 , var3 , var4 , var5 . assign the values var1 , var2 , var3 , var4 , var5 to var6 , var7 , var8 , var9 , var10 , respectively . assign ( 1 . 0 / var8 ) - ( 1 . 0 / var9 ) to var11 . assign 1 . 0 / ( var8 + var9 ) to var12 . assign 0 to var13 . assign var7 / ( real ) var8 to var14 . while var14 - var13 is larger than 1e - 07 * max ( 1 . 0 , var14 ) ) do following operations . update var15 by ( var13 + var14 ) / 2 . assign ( ( var7 / ( real ) var8 ) - var15 ) / var11 to var16 . assign 0 to var17 . for all var18 s from 0 to var18 < var6 , by increasing var18 by var10 , do this . if var18 + var10 is less than var6 then increment var17 by ( 2 * var16 ) * var12 . otherwise , increment var17 by var16 / var9 . after the current loop is ended , if var17 is less than or equal to var15 then assign var15 to var14 . otherwise , assign var15 to var13 . after the loop is ended , return ( var13 + var14 ) / 2 . 
you are given a number var0 and a number var1 . you have to set var2 to zero . for each var3 between zero and var0 you have to set var4 to the minimum between var1 - 2 * var3 and var0 - var3 divided by 2 ( rounded down ) , you have to store in var2 the maximum between var2 and var3 + var4 . after the loop ends , you have to return var2 . 
given the numbers var4 , var1 , var2 , var3 , var4 , var5 , var6 , var7 . if var4 is less than var3 and var7 is less than var0 and var6 is less than var3 and var5 is less than var0 return " Team 1 " . if var4 is greater than var3 and var7 is greater than var0 and var6 is greater than var3 and var5 is greater than var0 set var8 to true ; otherwise set var8 to false . if var4 is less than var1 and var7 is less than var2 and var6 is less than var1 and var5 is less than var2 return " Team 1 " ; otherwise if var4 is greater than var1 and var7 is greater than var2 and var6 is greater than var1 and var5 is greater than var2 and var8 is equal to true return " Team 2 " . return " Draw " . 
given a string var0 , iterate over all positions var1 in var0 starting from 1 . if var0 [ var1 ] = var0 [ var1 - 1 ] , then do the following actions : increase var0 [ var1 ] by 1 and set var0 [ var1 ] to a if var0 [ var1 ] = " { " , if var1 is less than length of var0 minus 1 and var0 [ var1 ] = var0 [ var1 + 1 ] , then increase var0 [ var1 ] by 1 and set var0 [ var1 ] to a if var0 [ var1 ] = " { " . return var0 . 
given integers var0 , var1 , var2 , var3 . increment var0 by 8 * var2 . if var0 is greater than var1 return 0 . if var2 is not greater than var3 , return - 1 . if var2 is not greater than var3 , return - 1 . initialize var4 to 12 * ( var2 - var3 ) . return the value of ( var1 + var4 - 1 - var0 ) / var4 . 
given an array of numbers var1 and an integer var0 , var4 to 1 , var2 to the number of elements in var1 , and store a sorted copy of var1 into var5 . let the var4 be the larger of first elements of var5 , the the difference of var0 and the last element of var5 , and the largest difference of two neighbor elements in var5 . return var4 . 
given integers var0 , var1 and a string var2 . initialize var3 to var0 , var4 to var1 , var5 to var3 , var7 to var2 , var6 to all valid values of var8 such that var7 [ var8 ] equals ' 0 ' . initialize var10 to 0 . for each var9 from 0 to the length of var6 - var4 exclusive , perform the following operations . while var6 [ var10 ] - var6 [ var9 ] is less than var6 [ k + i _ 1 ] - var6 [ var10 ] , set var5 to the minimum between var5 and var6 [ k + i _ 1 ] - var6 [ var10 ] , increase var10 by 1 . set var5 to the minimum between var5 and var6 [ var10 ] - var6 [ var9 ] . return var5 . 
given integers var0 , var1 . initialize var2 to the minimum between var0 and var1 , var3 to 0 . while var2 is greater than 0 , perform the following operations . initialize var4 to the maximum between var0 and var1 . if ( var4 - 2 is not less than 0 ) and ( var2 - 1 is not less than 0 ) , decrease var4 by 2 , decrease var2 by 1 , set var0 to var4 , set var1 to var2 and increase var3 by 1 . if var0 equals 1 and var1 equals 1 , break the loop . set the value of var2 to the minimum between var0 and var1 . return var3 . 
given integers var4 , var5 , var6 . return the sum of all values func0 ( a , var8 ) * func0 ( b , ( var6 - var8 ) ) where var8 obtains values from 4 to t - 1 . 
given integer var0 . if var0 exceeds 1 then return n / 2 + n % 2 . return var0 . 
given a string var1 . then , find and return a string var3 such that there are no two adjacent equal characters in var3 , and the number of positions var5 ( 0 < = var5 < | var1 | ) , where var3 [ var5 ] is not equal to var1 [ var5 ] , is as small as possible . 
given an array var0 of integer type . assign 0 to var7 . let var1 be the length of var0 . store the sorted elements from var0 in new array var2 . assign 0 to var4 . assign n - 1 to var5 . assign n - 1 to var6 . while var5 is larger than 0 do following operations . while var5 is larger than 0 and the value var2 [ var5 ] - var2 [ ( var5 - 1 ) ] taken by module is larger than 1 , decrement var5 . after the loop is ended , assign i _ 1 - 2 to var6 . while var6 is larger than 0 and the value var2 [ var6 ] - var2 [ ( var6 - 1 ) ] taken by module is larger than 1 , decrement var6 . after the loop is ended , if both i - 1 and var6 are larger than 0 then increment var4 by var2 [ var5 - 1 ] * var2 [ var6 - 1 ] . after this , assign var6 - 2 to var5 . after all loops are ended , return var4 . 
we define pow as a function that takes two arguments var1 , var2 and returns the value of var1 in power of var2 modulo 1000000007 . we define inv as a function that takes one argument var4 and returns the value of ( var4 in power of 1000000005 ) modulo 1000000007 . given integers var6 , var7 , var8 , var9 . if var6 equals 1 , return ( var9 + var7 * var8 ) modulo 1000000007 . otherwise , return pow ( var6 , var8 ) * var9 + var7 * ( 1 - pow ( var6 , var8 ) modulo 1000000007 . 
you are given a number var0 and a number var1 . you have to iterate var2 from zero and while is true that var0 is greater than or equal to 2 and var1 is greater than or equal to 1 , or , var0 is greater than or equal to 1 and var1 is greater than or equal to 2 . inside the loop if var0 is greater than or equal to var1 , you have to subtract 2 to var0 and subtract 1 to var1 , otherwise you have to subtract 1 to var0 and subtract 2 to var1 . you have to return var2 . 
you are given integers var0 , var1 , var2 , var3 , var4 , var5 . assign values ( ( var0 - var3 ) + var4 ) / 2 , ( ( var0 + var3 ) - var4 ) / 2 , ( ( ( ( 2 * var2 ) - var0 ) + var3 ) - var4 ) / 2 , ( ( var3 - var0 ) + var4 ) / 2 to variables var6 , var7 , var8 and var9 , respectively . if each of these variables is larger than 0 and less than 10 , and all of them have different values and b + c equals var5 and c + d equals var1 then output values var6 , var7 and var8 , var9 each pair in separate lines . otherwise , return - 1 . 
given integers var0 , var1 , var2 and var3 , initialize var4 to 0 . for as long as var0 < var1 , initialize var5 to var0 , add var2 * 8 to var0 , break from the enclosing loop if var0 > = var1 , increase var4 by 1 , substract var3 * 12 from var0 and add var2 * 4 to var0 , set var4 to - 1 and break from the enclosing loop if var5 > = var0 . return var4 . 
given integers var0 , var1 , var2 , var4 , var3 . add 8 * var2 to var0 . if var0 is not less than var1 , break the loop . increase var4 by 1 . add 4 * var2 - 12 * var3 to var0 . return var4 . 
you are given integers a , b . initialize integers var2 equal to given a and var3 equal to given b . initialize result as a variable var4 equal to ' 0 ' . while var2 > ' 0 ' and var3 > ' 0 ' do following operations . if var2 < var3 then increase var2 by ' 1 ' , decrease var3 by ' 2 ' and if var3 < ' 0 ' then decrease var4 by ' 1 ' . else if var2 > = var3 then increase var3 by ' 1 ' , decrease var2 by ' 2 ' and if var2 < ' 0 ' then decrease var4 by ' 1 ' . after this , increase var4 by ' 1 ' . after loop is ended , output var4 . 
you are given a number var0 and a number var1 . you have to return the greatest common divisor of var0 and var1 . 
you are given an array of reals var0 ( indexing is 0 - based ) , for each var3 in var0 , var0 [ var3 ] represent the probability that event var3 is fulfilled . you have to find a subset of var0 in such a way the probability that exactly one event is fulfilled is as great as possible , and return this probability . 
you are given an array of numbers var1 ( indexing is 0 - based ) , an array of numbers var2 ( indexing is 0 - based ) . set var3 to the length of var1 . you have to create an array of numbers var4 of length var3 . set var4 [ 0 ] to var1 [ 0 ] - var2 [ 0 ] . set var4 [ var3 - 1 ] to var1 [ var3 - 1 ] + var2 [ var3 - 1 ] . if var3 is equal to 1 set var7 to 1 , otherwise set var7 to 2 . for each var8 between 1 and var3 - 2 set var9 to var1 [ var8 ] - var2 [ var8 ] , var10 to var1 [ var8 ] + var2 [ var8 ] , if var4 [ var8 - 1 ] is less than var9 and var1 [ var8 - 1 ] is less than var9 , add 1 to var7 , set var4 [ var8 ] to var9 , otherwise if var1 [ var8 + 1 ] is greater than var10 , add 1 to var7 , set var4 [ var8 ] to var10 . you have to return var7 . 
given integers var1 , var2 . initialize var3 to var1 , var4 to var2 , var5 to 2 in power of var3 , var6 to 0 , var4 to var5 - var4 + 1 . for each var7 from 0 to var3 exclusive , perform the following operations . divide var5 by 2 . if var4 is greater than var5 , set var4 to 2 * var5 - var4 + 1 and increase var6 by 1 ; else add 2 * var5 to var6 . return var6 . 
given integers var1 and var2 and a string var3 , initialize var4 to var1 , var5 to var2 , var6 to var3 , var7 to 0 . for each character var8 from " a " to " b " initialize var9 to 0 , var10 to 0 and var11 to 0 and for as long as var10 < var4 , do the following actions : increase var11 by 1 if var6 [ var10 ] = var8 ; for as long as var11 > var5 , decrease var11 by 1 if var6 [ var9 ] = var8 and increase var9 by 1 ; set var7 to var10 - var9 + 1 if var7 < var10 - var9 + 1 and increase var10 by 1 . return var7 . 
given an array var1 of var3 integers ( 0 indexed ) and a prime var0 , initialize var10 and var11 to 0 and var3 to length of var1 . create a real array var4 of length var3 + 1 and initialize var5 to 0 iterate from var6 = 0 to var3 - 1 var7 = var1 [ var10 ] var8 = var2 [ var11 ] var4 [ var6 ] = ( var8 divided by var0 rounded down ) - ( ( var7 - 1 ) divided by var0 rounded down ) ) divided by ( var8 - var7 + 1 ) finally equate var4 [ var3 ] to var4 [ 0 ] iterate from var6 = 1 to var3 and add the following to var5 at each iteration 1 - ( ( 1 - var4 [ var9 ] ) * ( 1 - var4 [ ( var9 - 1 ) ] ) ) finally multiply var5 with 2000 and return var5 
given array var1 . successively remove the longest prefix of var1 which has sum less than or equal to var3 , until the array is empty . return the number of operations . 
given integers var0 and var1 , initialize var6 to empty array of strings . append " - 1 " to the end of var6 if var0 * var1 > var0 * ( var0 - 1 ) / 2 . otherwise do the following : append a string representation of var0 * var1 to the end of var6 . for each integer var3 from 0 to var0 - 1 ( both inclusive ) iterate over all integers var4 from var3 + 1 to var3 + var1 ( both inclusive ) , set var5 to var4 + 1 , decrease var5 by var0 if var5 > var0 and append a string , obtained by concatenation of string representation of var3 + 1 , " " and string representation of var5 , to the end of var6 . return var6 . 
you are given the numbers var1 , var2 , var3 , var4 . you have to set var9 to ( var3 - var1 ) divided by 2 ( rounded down ) . you have to set var10 to var4 - var2 . if var10 is divisible by 2 , divide var10 by 2 , set var11 to ( var9 + 1 ) * ( var10 + 1 ) + var10 * var9 , otherwise divide var10 by 2 ( rounded down ) , set var11 to ( 2 * var9 + 1 ) * ( var10 + 1 ) . you have to return var11 . 
given integer var0 . assign 2 , 0 to var1 , var2 . for each var3 from 1 to var0 , add to var2 the value var1 and multiply var1 by 2 . return var2 . 
you are given a number var0 , an array of numbers var1 ( indexing is 0 - based ) , an array of numbers var2 ( indexing is 0 - based ) . you have to set var3 to the length of var1 . you have to create an array of reals var4 of the length of var1 . for each position var5 in var1 you have to , set var6 to ( var2 [ var5 ] divided by var0 ( rounded down ) ) minus ( var1 [ var5 ] - 1 divided by var0 ( rounded down ) ) , set var4 [ var5 ] to var2 [ var5 ] - var1 [ var5 ] - var6 + 1 divided by var2 [ var5 ] - var1 [ var5 ] + 1 . you have to set var7 to zero . for each position var8 in var1 you have to , set var9 to var8 - 1 + var3 modulo var3 , add 2000 * ( 1 - var4 [ var8 ] * var4 [ var9 ] ) to var7 . you have to return var7 . 
given integers var0 , var1 . assign 1 to var2 . while var1 exceeds 0 , do following operations . if var1 is not less than var2 then substract var2 from var1 . add 1 to var2 . if var2 equals to n + 1 then assign 1 to var2 . when the loop is ended , return var1 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to return the elements in var0 sorted from lowest to highest . 
given an integer array var0 . set var2 to var0 and sort it . store concatenated elements of var2 in order with a space between every adjacent elements into ret . return ret . 
given integers var0 , var1 . create char matrix var7 . assign 1 , 0 to var4 , var5 . create integer matrix var6 of sizes n + 1 , n + 1 . for each var3 from 1 to var0 and for each var2 from 1 to k - 1 , assign var4 to var6 [ var3 ] [ var2 ] and add 1 to var4 . for each var3 from 1 to var0 and for each var2 from var1 to var0 , do following operations . assign var4 to var6 [ var3 ] [ var2 ] . add 1 to var4 . if var2 equals var1 then add var6 [ var3 ] [ var2 ] to var5 . when var3 becomes larger than var0 , insert var5 into var7 . for each var2 from 1 to var0 and for each var3 from 1 to var0 , add to the end of var7 the value var6 [ var2 ] [ var3 ] . return var7 . 
you are given an array of integers var0 , and an array of integers var1 . currently , each value in var0 [ var3 ] ( 0 < = var3 < | var0 | ) represents a segment [ var0 [ var3 ] , var0 [ var3 ] ] . we can transform the var3 - th segment in var0 to either the segment [ var0 [ var3 ] - var1 [ var3 ] , var0 [ var3 ] or to the segment [ var0 [ var3 ] , var0 [ var3 ] + var1 [ var3 ] ] . we need to transform as many segments as possible such that no two segments intersects . we will go over the values in var0 from left to right , and then try to make it a segment of the first type by checking the right boundary of the last segment , if that does not work we will try to make a segment of the second type by check the position of the next segment . finally we will return the maximum number of segments that can be transformed . 
given a string var2 of length var1 . initialize var6 to an array such that element on position var7 stores the number of characters number var7 in alphabetical order in var2 . sort var6 in decreasing order . initialize var9 to the number of indices var7 in var2 , such that var6 [ var7 ] equals to the maximum in var6 . return the value of ( var9 ^ var1 ) modulo 1000000007 . 
you are given an array of characters var4 . return " YES " if there exists five positions in var4 such that the value at these positions is equal to ' * ' and the difference between every two consecutive positions is equal , return " NO " otherwise . 
given a string var1 , initialize var4 to array of integers of length , equal to length of var1 , which is filled with zeroes , var5 to array of integers of length , equal to length of var1 plus 1 , which is filled with zeroes . for each position var6 in var1 set var4 [ var6 ] to 1 if var1 [ var6 ] = " 1 " , add var4 [ var6 - 1 ] to var4 [ var6 ] if var6 > 0 . set var7 to 0 and var5 [ 0 ] to 1 . for each position var8 in var4 add var5 [ var4 [ var8 ] - var0 ] to var7 if var4 [ var8 ] > = var0 , add 1 to var5 [ var4 [ var8 ] ] . return var7 . 
given 3 integers var0 , var1 and var2 . initialize values of 3 variables var3 , var4 and var5 to var1 , var2 and 0 respectively . while values of var4 and var3 are both positive , do the followings . among var3 and var4 , if the larger number is not less than 2 and the smaller number not less than 1 , add 1 to var5 and decrease the larger number by 2 and decrease the smaller number by 1 . otherwise , set the values of var4 and var3 both to 0 . when var4 or var3 is no more positive , return the value of var5 . 
given integers var0 , var1 , var2 , var3 , var4 . assign 1000000 to var5 . assign 0 to var6 . for all var7 s from 0 to var7 < = var5 do following operations . if var4 * var7 is larger than var0 then exit from current loop . set the larger of var6 and ( var7 * var2 ) + ( ( ( var0 - ( var7 * var4 ) ) / var3 ) * var1 ) ) to var6 . after the loop is ended , for all var8 s from 0 to var8 < = var5 do following operations . if var3 * var8 is larger than var0 then exit from current loop . set the larger of var6 and ( var8 * var1 ) + ( ( ( var0 - ( var8 * var3 ) ) / var4 ) * var2 ) ) to var6 . after the loop is ended , return var6 . 
given integers var0 , var1 . initialize var2 to 0 , var3 to 1 . while var3 is not less than 1 , var3 is not greater than var0 and var1 is not less than var3 , perform the following operations . add var3 to var2 . subtract var3 from var1 . increase var3 by 1 . if var3 is greater than var0 , set var3 to 1 . return var1 . 
you are given a number var1 , a number var0 , an array of numbers var3 ( indexing is 0 - based ) , a number var2 . you have to set var4 to the length of var3 . you have to create a three - dimensional array var5 of dimensions ( 2 , var0 + 1 , var1 + 1 ) . set var5 [ 0 ] [ 0 ] [ 0 ] to 1 . for each var7 between 1 and var4 you have to , set var8 to ( var7 biwise and 1 ) , for each var9 between 0 and var0 and each var10 between 0 and var1 , set var5 [ var8 ] [ var9 ] [ var10 ] to var5 [ var8 bitwise xor 1 ] [ var9 ] [ var10 ] , if var9 is greater than zero and var10 is greater than or equal to var3 [ var7 - 1 ] add var5 [ var8 ] [ var9 - 1 ] [ var10 - var3 [ var7 - 1 ] ] to var5 [ var8 ] [ var9 ] [ var10 ] , while var5 [ var8 ] [ var9 ] [ var10 ] is greater than or equal to var2 subtract var2 to var5 [ var8 ] [ var9 ] [ var10 ] . set var11 to zero . for each var12 between 0 and var1 you have to , add var5 [ var4 biwise and 1 ] [ var0 ] [ var12 ] to var11 , while var11 is greater than or equal to var2 subtract var2 to var11 . return var11 . 
you are given a number var0 , a number var1 , a string var2 . if var0 is equal to var1 + 1 or var1 - var0 is less than or equal to 1 you have to , if var0 is equal to var1 + 1 set var3 to zero , otherwise set var3 to 1 , set var4 to zero , while var4 is less than var0 + var1 you have to , concatenate the decimal representation of var3 to var2 , add 1 to var4 , set var3 to ( var3 + 1 ) modulo 2 ; otherwise you have to , set var5 to zero , set var6 to zero , set var7 to zero , while var5 is less than var0 or var6 is less than var1 you have to , if var7 modulo 2 is equal to 1 concatenate string " 0 " to var2 , add 1 to var5 , otherwise if var1 - var6 is greater than var0 - var5 + 1 concatenate string " 11 " to var2 , add 2 to var6 , otherwise concatenate string " 1 " to var2 and add 1 to var6 , add 1 to var7 . return var2 . 
given array var0 of integer type . let var1 be the length of var0 . create arrays var3 , var4 of sizes var1 and consisting of values - 1 . assign 0 to var3 [ 0 ] . iterating over var0 , by starting from first element , in each case when current element in var0 is larger than or equal to previous one , increment the current element in var3 by the value of previous one increment by 1 . in other cases , assign 0 to current element in var3 . after the loop is ended , assign 0 to var4 [ n - 1 ] . iterating over var0 by starting from last element , in each case when current element is larger than or equal to next one , increment the current element in var4 by the next one incremented by 1 . in other cases , assign 0 to current element in var4 . after the loop is ended , let var7 be the maximum sum of pairwise elements from var3 and var4 standing at same positions . increment var7 by 1 . return var7 . 
given integers var0 , var1 , var2 . set the minimum of var3 and var4 to var5 . return the value of var5 erected to the power of var5 . 
you are given integers var0 , var1 . return the factorial of the minimum of var1 and var0 . 
given integers var0 , var1 . set var0 to the minimum between var0 and var1 . initialize var2 to var0 . for each var3 from 2 to var2 exclusive , multiply var0 by var3 . return var0 . 
given integers var0 , var1 . return the factorial of minimum of var0 and var1 . 
given an integer var0 , var1 is equal to factorial of var0 . return var1 . 
given integers var1 and var2 and an array of integers var3 , initialize var5 to length of var3 , var6 to var1 , var7 to var2 , var8 to array of integers of length var5 + 1 , filled with zeroes . for each integer var9 from 1 to var5 set var8 [ var9 ] to var3 [ var9 - 1 ] + var8 [ var9 - 1 ] ( all indices are 0 - based ) . initialize var10 to 2 - dimensional array of integers of dimensions var5 + 1 and var7 + 1 , filled with zeroes . for each var11 from var6 to var5 ( both inclusive ) iterate over all var12 from 1 to var7 ( both inclusive ) and set var10 [ var11 ] [ var12 ] to the maximum of var10 [ var11 - 1 ] [ var12 ] and var10 [ var11 - var6 ] [ var12 - 1 ] + var8 [ var11 ] - var8 [ var11 - var6 ] . return var10 [ var5 ] [ var7 ] . 
you are given a number var0 , a number var1 and an array of numbers var2 ( indexing is 0 - based ) . you have to set var3 to the length of var2 . you have to create an array of numbers var5 of the length of var2 . you have to store in var5 [ var0 - 1 ] the sum of the first var0 elements in var2 . for each var7 between var0 and var3 - 1 you have to set var5 [ var7 ] to var5 [ var7 - 1 ] + var2 [ var7 ] - var2 [ var7 - var0 ] . you have to create a ( var1 + 1 ) * ( var3 + 1 ) matrix of numbers var8 . you have to set var8 [ var9 ] [ 0 ] to zero for each var9 between 0 and var1 - 1 . for each var10 between 1 and var1 and each var11 between var0 and var3 you have to set var8 [ var10 ] [ var11 ] to the maximum between var8 [ var10 ] [ var11 - 1 ] and var8 [ var10 - 1 ] [ var11 - var0 ] + var5 [ var11 - 1 ] . you have to return var8 [ var1 ] [ var3 ] . 
given integer arrays var0 , var1 . create integer array var7 . assign the length of var0 to var2 . create 0 - based integer array var4 at first position containing teh value 1 . assign var0 [ 0 ] to var5 . if var2 equals 1 then return 1 . for all var3 s from 1 to n - 2 do following operations . if var0 [ var3 ] - var5 exceeds var1 [ var3 ] then assign the values var4 [ ( var3 - 1 ) ] + 1 , var0 [ var3 ] to var4 [ var3 ] and to var5 , respectively . otherwise , if var0 [ i + 1 ] - x [ var3 ] exceeds var1 [ var3 ] then assign the values var4 [ ( var3 - 1 ) ] + 1 , var0 [ var3 ] + var1 [ var3 ] to var4 [ var3 ] and to var5 , respectively . otherwise , if none of these cases are true then assign the values var4 [ ( var3 - 1 ) ] , var0 [ var3 ] to var4 [ var3 ] and to var5 , respectively . when the loop is ended , return the last value in var4 , increased by 1 . 
given arrays var0 , var1 of integer types . let var2 be the length of var0 . assign 1 to var4 . assign var0 [ 0 ] to var5 . assign the values var0 [ var6 ] - var1 [ var6 ] , var0 [ var6 ] + var1 [ var6 ] to var7 and var8 , respectively . if var7 is larger than var5 then increment var4 and assign var0 [ var6 ] to var5 . otherwise , if var8 is less than var0 [ var6 + 1 ] then increment var4 and assign var8 to var5 . otherwise , assign var0 [ var6 ] to var5 . after the loop is ended , if var2 does not equal 1 then increment var4 . return var4 . 
you are given an array of numbers var0 , an array of numbers var1 , a number var2 . set var3 to zero . you have to create an array of numbers var4 of the length of var0 . for each position var5 in var0 you have to , set var6 to var1 [ var5 ] - var0 [ var5 ] + 1 , var7 to var0 [ var5 ] modulo var2 , if var7 is equal to zero set var8 to var0 [ var5 ] , otherwise set var8 to var0 [ var5 ] + var2 - var7 , if var8 is less than or equal to var1 [ var5 ] set var9 to 1 + ( ( var1 [ var5 ] - var8 ) divided by var2 ) ( rounded down ) , otherwise set var9 to zero , set var4 [ var5 ] to var9 , add 4000 * var9 divided by var6 to var3 , if var5 is greater than zero set var10 to var1 [ var5 - 1 ] - var0 [ var5 - 1 ] + 1 , subtract ( 2000 * var4 [ var5 - 1 ] * var9 ) divided by var6 * var10 to var3 . set var11 to the length of var0 minus 1 . set var12 to var1 [ var11 ] - var0 [ var11 ] + 1 . set var13 to var1 [ 0 ] - var0 [ 0 ] + 1 . subtract ( 2000 * var4 [ var11 ] * var4 [ 0 ] ) divided by var13 * var12 to var3 . return var3 . 
given an array of integers var1 , initialize var2 to length of var1 . calculate prefix sums of array var1 and store the result in array var4 . find the frequency of the most frequent element in var4 and store the result in var8 . return var2 - var8 . 
given integers var0 , var1 . let var2 be the less of var0 and var1 . assign ( n + m ) / 3 to var3 . return the less of var2 and var3 . 
given integers var2 , var3 . set var4 : = ( ( 365 + func0 ( var2 ) ) % 7 ) . set var5 : = func0 ( var2 ) . while var5 does not equal func0 ( + + var3 ) or var4 does not equal 0 , set var4 = ( ( ( var4 + 365 ) + func0 ( var3 ) ) % 7 ) . return var3 . 
you are given a string var0 . you have to create an array of numbers var1 of length 64 where var1 [ var6 ] is equal to the number of pairs var3 , var4 ( var3 and var4 are greater than or equal to zero and less than 64 ) with ( var3 bitwise and var4 ) equal to var6 . you have to set var5 to 1 . for each position var6 in var0 you have to , if var0 [ var6 ] is greater than or equal to 48 and var0 [ var6 ] is less than or equal to 57 set var7 to var1 [ var0 [ var6 ] - 48 ] , otherwise if var0 [ var6 ] is greater than or equal to 65 and var0 [ var6 ] is less than or equal to 90 set var7 to var1 [ var0 [ var6 ] - 55 ] , otherwise if var0 [ var6 ] is greater than or equal to 97 and var0 [ var6 ] is less than or equal to 122 set var7 to var1 [ var0 [ var6 ] - 61 ] , otherwise if var0 [ var6 ] is equal to 45 set var7 to var1 [ 62 ] , otherwise set var7 to var1 [ 63 ] ; store in var5 the value of var7 * var5 modulo 1000000007 . you have to return var5 . 
given integers var0 , var1 . assign 0 to var2 . while n + m is larger than or equal 3 and both var0 and var1 are not equal 0 , do followingf operations . if var0 is larger than var1 then decrement var0 by 2 and decrement var1 . otherwise , decrement var0 and decrement var1 by 2 . after this , increment var2 . after the loop is ended , return var2 . after the loop is ended , return var2 . 
given an array of integers var0 . initialize an empty string var6 . initialize new empty integer array var1 and make it equal to array var0 . after sorting array var1 , concatenate all elements of var1 in order , with a space between every adjacent elements , and store it in var6 . return var6 . 
you are given a string var0 . for each position var1 greater than zero in var0 , if var0 [ var1 ] is equal to var0 [ var1 - 1 ] you have to , add 1 to var0 [ var1 ] , if var0 [ var1 ] is greater than 122 set var0 [ var1 ] to 97 , if ( var1 + 1 ) is less than the length of var0 and var0 [ var1 ] is equal to var0 [ var1 + 1 ] you have to , add 1 to var0 [ var1 ] and if var0 [ var1 ] is greater than 122 set var0 [ var1 ] to 97 . you have to return var0 . 
given char typed array var0 . for all var3 s from 1 to length of var0 minus 1 do following operations . if var0 [ i - 1 ] equals var0 [ var3 ] then if i + 1 is less than the length of var0 then for all var4 s starting from 1 do following operations . if var0 [ var3 ] + j does not equal var0 [ i + 1 ] and does not exceed 122 then add var4 to var0 [ var3 ] and exit from the current loop . if var0 [ var3 ] - j does not equal var0 [ i + 1 ] and is not less than 97 then substract var4 from var0 [ var3 ] and exit from current loop . add 1 to var4 . if i + 1 was not less than the length of var0 then if var0 [ var3 ] + 1 does not exceed 122 then add 1 to var0 [ var3 ] or substract 1 from var0 [ var3 ] in other case . when var3 becomes equal to the length of var0 , return the resultant var0 . 
you are given integers var4 , var5 , var6 . create an array var8 of integer type . for all var7 s from 0 to var7 < length of __globals__.a . ns , if __globals__.a . ns [ var7 ] equals var4 and __globals__.a . xs [ var7 ] equals var5 and __globals__.a . ys [ var7 ] equals var6 then return __globals__.a . ans [ var7 ] . 
given integers var0 , var1 . assign var0 and var1 to var2 , var3 . assign 1 < < var2 to var4 . assign max + 1 - n to var3 . assign 0 to var5 . for each var6 from 0 to h - 1 , do following operations . update var4 by the value var4 > > 1 . if var3 exceeds var4 then add 1 to var5 and assign the value 2 * max + 1 - n to var3 , or in other case , add to var5 the value 2 * max . when the loop is ended , return var5 . 
you are given a number var1 and a number var2 . set var6 to the var1 power of 2 , var4 to var2 and var5 to 1 . set var7 to zero and var8 to true . while var5 is less than var6 you have to , set var9 to ( var5 + var6 ) divided by 2 ( rounded down ) , if var4 is less than or equal to var9 you have to , if var8 is equal to true add 1 to var7 , otherwise add var6 - var5 + 1 to var7 , set var6 to var9 and var8 to false ; otherwise you have to , if var8 is equal to true add var6 - var5 + 1 to var7 , otherwise add 1 to var7 , set var5 to var9 + 1 and var8 to true . you have to return var7 . 
you are given a number var1 and a number var2 . you have to set __globals__.c . sequence [ 0 ] to 1 and var3 to var2 . for each var4 between 0 and var1 - 1 , if var3 is less than or equal to the var1 - var4 - 1 power of two , you have to set __globals__.c . sequence [ ( var4 + 1 ) ] to zero , otherwise subtract the var1 - var4 - 1 power of two to var3 and set __globals__.c . sequence [ ( var4 + 1 ) ] to 1 . set var5 to zero . for each var4 between 0 and var1 - 1 you have to , if var2 is greater than the var1 - var4 - 1 power of two , you have to subtract the var1 - var4 - 1 power of two to var2 , if __globals__.c . sequence [ var4 ] is equal to __globals__.c . sequence [ var4 + 1 ] add the var1 - var4 power of two to var5 , otherwise add 1 to var5 . you have to return var5 . 
you are given an integer var0 . create a matrix var7 of char type . create a matrix var1 of sizes var0 and var0 , of integer type . initialize integers var2 , var3 with initial values n - 1 and n / 2 , respectively . assign 1 to var1 [ var2 ] [ var3 ] . for all var4 s from 2 to var4 < = n * n , do following operations . if var1 [ ( ( var2 + 1 ) % var0 ) ] [ ( ( var3 + 1 ) % var0 ) ] equals 0 then assign the values ( var2 + 1 ) % var0 , ( var3 + 1 ) % var0 to var2 and var3 , respectively . otherwise , assign the value ( ( var2 - 1 ) + var0 ) % var0 to var2 . assign var4 to var1 [ var2 ] [ var3 ] . when var4 becomes larger than n * n , exit from the loop and do the following loop . for all var5 s from 0 to var5 < var0 , do following loop . for all var6 s from 0 to var6 < var0 , do following operations . if var1 [ var5 ] [ var6 ] is less than 10 then add the double space to the end of var7 . otherwise , if var1 [ var5 ] [ var6 ] is less than 100 then add the space to the end of var7 . otherwise , do nothing . add the string representation of var1 [ var5 ] [ var6 ] to the end of var7 and separate it with next value , by space . when var5 becomes equal to var0 , exit from the loop and return var7 . 
given array var1 and number var0 you need to copy it into array var4 for each var6 = 0 . . length of the array var1 increase var3 by current element of array var4 divided by 10 set value of var7 to current element of array var4 divided by 10 update value of current element of array var4 by ( ( ( var7 * 10 ) + 10 ) - current element of array var4 ) sort array var4 for each element of var4 if k > = current element of var4 decrease var0 by current element of var4 and increase var3 by 1 increase var3 by var0 divided by 10 set var3 minimal of var3 and length of the var7 * 10 return found var3 
you are given a number var0 . you have to set var1 to 1 and var4 to zero . if var0 is divisible by 2 you have to set var2 to var0 divided by 2 ( rounded down ) and var3 to var0 + 1 , otherwise , you have to set var2 to var0 and var3 to var0 + 1 divided by 2 ( rounded down ) . you have to add var2 to var4 and multiplicate var4 by var3 . you have to multiplicate var4 by 6 and you have to add var4 to var1 . you have to return var1 . 
given integers var0 , var1 and 0 - based array var2 of char type . create an array var4 of char type . for all var5 s from 0 to var5 < var0 , if var1 equals 0 then add var2 [ var5 ] to the end of var4 , otherwise do following operations . set the larger of var2 [ var5 ] - 97 and 122 - var2 [ var5 ] to var3 . if var3 does not exceed var1 then do following operations . if the integer representation of var2 [ var5 ] increased by 1 does not exceed 122 then add the char representation of var2 [ var5 ] + var3 to the end of var4 . otherwise , add the char representation of var2 [ var5 ] - var3 to the end of var4 . decrease var1 by var3 . if var3 was exceeding var1 then do following operations . if var2 [ var5 ] + var1 does not exceed 122 then add the char representation of var2 [ var5 ] + var1 to the end of var4 . otherwise , add the char representation of var2 [ var5 ] - var1 to the end fo var4 . assign 0 to var1 . when var5 becomes equal to var0 , if var1 exceeds 0 then return - 1 . otherwise , return var4 . 
you are given a number var0 . you have to return the sum of the powers of two from 1 to var0 . 
given integers arrays var0 , var1 . create integer array var3 of size 100001 . add 1 to all elements of var3 with positions stored in var0 . return a matrix var8 of size equal to length of var0 , at var4 th row containing the values ( var2 - 1 ) + var3 [ var1 [ var6 ] ] , ( var2 - 1 ) - var3 [ var1 [ var6 ] ] , separated by space . 
given an integer var0 , if var0 = 1 , return 1 , otherwise return var0 / 2 , rounded up to the nearest integer . 
given an array var2 and an integer var1 . initialize var3 to the length of var2 , var6 to the sum of elements of var2 , var4 to var1 and var8 to an empty string . for each element var9 in var2 , perform the following operations . initialize var10 to var4 - var3 + 1 , var11 to var4 - var6 + var9 , var11 to the maximum of 1 and var11 , var10 to the minimum of var10 and var9 . if length of var8 is greater than 0 , concatenate var8 with " " . concatenate var8 with the maximum of 0 and the value of var9 - ( var10 - var11 ) + 1 . return var8 . 
given an integer var0 and an array var1 . initialize var8 to an empty array , var3 to the length of var1 , var2 to the sum of elements of var1 . for each var7 from 0 to var3 exclusive , perform the following operations . initialize var5 to the maximum between 1 and var0 - var2 + var1 [ var7 ] . if var0 - var3 + 1 is less than var1 [ var7 ] , set var6 to var0 - var3 + 1 ; else set var6 to var1 [ var7 ] . push the value of ( var1 [ var7 ] - var6 + var5 - 1 ) into var8 . return var8 . 
given integer var0 and char typed arrays var0 , var2 . if var2 does not equal week then if var0 does not exceed 29 or equals 29 or 30 , then return 12 , 11 or 7 , respectively . if var2 equals " week " then do following operations . assign 0 and 4 to var4 and var5 , respectively . for all var6 s from 1 to 366 do following operations . if var5 equals n - 1 then add 1 to var4 . add 1 to var5 modulo 7 . when the loop is ended , return var4 . 
you are given an array of numbers var0 and an array of numbers var1 . you have to create an array of numbers var4 of length 2000005 . you have to set var4 [ var5 ] to true if var0 contains the element var5 or var1 contains the element var5 . you have to store in var7 the number of pairs ( var8 , var9 ) in such a way that ( var0 [ var8 ] bitwise xor var1 [ var9 ] ) is greater than zero ( var0 [ var8 ] bitwise xor var1 [ var9 ] ) is less than 2000005 and var4 [ ( var0 [ var8 ] bitwise xor var1 [ var9 ] ) ] is equal to true . if var7 is divisible by 2 return " Karen " , otherwise return " Koyomi " . 
given an array of numbers var1 and a number var4 , determine the absolute value of the sum of elements of var1 and store it in var5 . you have to return var5 divided by var4 ( rounded up ) . 
given integers var0 , var1 , var2 , var3 . create integer matrix var4 of sizes 101 , 101 . assign 1 to var4 [ 0 ] [ 0 ] . assign the values var1 , var2 , var3 to var5 , var6 and to var7 , respectively . for each var9 from 1 to var5 , for each var10 from 1 to var6 , while i - j is not negative value , do following operations . if var10 is less than var7 then add values var4 [ ( var9 - var10 ) ] [ 0 ] , var4 [ ( var9 - var10 ) ] [ 1 ] modulo 10 ^ 9 + 7 to var4 [ var9 ] [ 0 ] and to var4 [ var9 ] [ 1 ] , respectively . otherwise , increase var4 [ var9 ] [ 1 ] by var4 [ ( var9 - var10 ) ] [ 0 ] + ways [ ( var9 - var10 ) ] [ 1 ] modulo 10 ^ 9 + 7 . return the resultant var4 [ var5 ] [ 1 ] . 
given integers var0 , var1 . assign 0 to var2 . for all var3 s from 1000000 to var2 < = var3 , do following operations . assign the average of var2 and var3 to var4 . if var4 is larger than the minimum of var0 and var1 or if var0 + var1 is less than 3 * var4 then assign var4 - 1 to var3 . otherwise , assign var4 + 1 to var2 . after the loop is ended , return var3 . 
given integers var0 , var1 . return the factorial of the less value of var0 and var1 . 
given integers var0 and var1 . calculate factorial value of minimum of var0 and var1 and store it into var3 . return var3 . 
given an integer var1 . return the sum of ( 2 ^ var4 ) over all values of var4 from 1 to var1 . 
given integers var1 , var2 . initialize var3 to var1 , var4 to var2 , var5 to var3 / 2 , var6 to var5 / ( var4 + 1 ) . while var6 * ( var4 + 1 ) is not greater than var5 , increase var6 by 1 . 
you will be given an integer var0 . return the value of ( 2 ^ 1 ) + ( 2 ^ 2 ) + ( 2 ^ 3 ) + . . + ( 2 ^ var0 ) . 
given integers var1 , var2 , var3 and integer type array var4 . assign to var5 the length of var4 . assign 1 to __globals__.cf544c . dp [ 0 ] [ 0 ] [ 0 ] . for all var7 s from 1 to var5 do following operations . assign to var8 the value it & 1 . for all var9 s from 0 to var1 do following loop . for all var10 s from 0 to var2 do following operations . assign to __globals__.cf544c . dp [ var8 ] [ var9 ] [ var10 ] the value __globals__.cf544c . dp [ ( var8 ^ 1 ) ] [ var9 ] [ var10 ] . if var9 exceeds 0 and var10 is not less than var4 [ it - 1 ] then assign to __globals__.cf544c . dp [ var8 ] [ var9 ] [ var10 ] the value __globals__.cf544c . dp [ var8 ] [ var9 ] [ var10 ] + __globals__.cf544c . dp [ var8 ] [ ( var9 - 1 ) ] [ ( var10 - var4 [ ( var7 - 1 ) ] ) ] . update __globals__.cf544c . dp [ var8 ] [ var9 ] [ var10 ] modulo var3 . after all loops are ended , return the sum of first var2 elements in __globals__.cf544c . dp [ var5 & 1 ] [ var1 ] taken by modulo var3 . 
given integers var0 , var1 . assign true to var2 . assign 0 to var3 . as long as var2 is true do following operations . assign false to var2 . if var0 exceeds var1 and both n - 2 and m - 1 are not less than 0 then do following operations . substract 2 from var0 . substract 1 from var1 . add 1 to var3 . assign true to var2 . if var0 does not exceed var1 and both n - 1 and m - 2 are not less than 0 then do following operations . substract 1 from var0 . substract 2 from var1 . add 1 to var3 . assign true to var2 . when the loop is ended , return var3 . 
you are given a number var0 and a number var1 . you have to create an array of strings var11 initially empty . you have to set var3 to ( ( var0 * ( var1 - 1 ) ) + 1 ) . you have to create a var0 * var0 matrix of numbers var4 . for each var5 between 0 and var0 - 1 , inside the loop for each var6 between 0 and var1 - 2 you have to set var4 [ var5 ] [ var6 ] to ( ( 1 + var6 ) + ( var5 * ( var1 - 1 ) ) ) , for each var7 between var1 - 1 and var0 - 1 you have to set var4 [ var5 ] [ var7 ] to var3 and add 1 to var3 . after the loop in var5 ends , you have to store in var2 the sum of the elements of var4 at column with index var1 - 1 . you have to insert in var11 the decimal representation of var2 . for each var9 between 0 and var0 - 1 and each var10 between 0 and var0 - 1 you have to insert the decimal representation of var4 [ var9 ] [ var10 ] with a space at the end in var11 . you have to return var11 . 
given integer var0 and integer array var1 , var2 . create integer typed sorted set var4 consisting of elements of var1 and var2 . let var7 be the number of values var1 [ var8 ] ^ var2 [ var9 ] which appear in var4 where both var8 and var9 obtain values from 0 to length of var1 minus 1 . if var7 is even value then return " Karen " . otherwise , return " Koyomi " . 
given integer var0 . for each var1 from 0 to 9 , do following operations . if n + i is divisible by 10 then add var1 to var0 and exit from the loop . otherwise , if n - i is divisible by 10 then substract var1 from var0 and exit from the loop . when the loop is ended , return var0 . 
given integer array a . return a sorted in non - decreasing order . 
given arrays var0 , var1 . initialize var2 to the length of var0 , var3 to a boolean array . for each var4 from 0 to var2 exclusive , set var3 [ var0 [ var4 ] ] and var3 [ var1 [ var4 ] ] to true . initialize var6 to 0 . for each var7 from 0 to var2 exclusive and for each var8 from 0 to var2 exclusive , if var3 [ x [ i _ 2 ] xor y [ j ] ] is true , set var6 to var6 xor 1 . if var6 equals 0 , return " Karen " ; else return " Koyomi " . 
you are given an array of numbers var1 ( indexing is 0 - based ) and a number var0 . you have to create an array of strings var10 initially empty . you have to create an array of numbers var3 and store in it all elements in var1 in order . you have to sort var3 . set var5 to 1 and var6 to zero . you have to create an array of numbers var7 initially empty . while var0 is greater than or equal to var5 you have to , if ( var6 is less than var2 and var5 is different to var3 [ var6 ] ) or var6 is greater than or equal to var2 , insert var5 in var7 , subtract var5 to var0 , otherwise add 1 to var6 ; add 1 to var5 . you have to insert the decimal representation of the length of var7 to var10 . you have to insert the decimal representation of each number in var7 plus a space character to var10 . you have to return var10 . 
given an array of integers var1 . initialize integers var5 , var3 and var4 to zero . iterate var1 from beginning to end with index var6 . increment var5 if next element modulo 3 is zero . otherwise , if element modulo 3 is one , increment var3 . otherwise , increment var4 . after the iteration , return minimum of var5 divided by 2 rounded down and minimum of var3 and var4 . 
given integers var1 and var2 , initialize var3 to var1 , var4 to var2 and var5 to 0 . for as long as either var3 > = 2 and var4 > = 1 or var3 > = 1 and var4 > = 2 , substract 2 from var3 , substract 1 from var4 and add 1 to var5 if var3 > var4 , substract 1 from var3 , substract 2 from var4 and add 1 to var5 otherwise . return var5 . 
you are given an array of numbers var0 ( indexing is 0 - based ) and an array of numbers var1 ( indexing is 0 - based ) . you have to create an array of numbers var4 of length 111111 . you have to store in var4 the frequency of each distinct number in var0 . you have to create an array of strings var8 intially empty . set var2 to the length of var0 . for each position var6 in var0 you have to , insert in var8 the decimal representation of var2 + var4 [ var1 [ var6 ] ] - 1 plus a space character plus the decimal representation of var2 - var4 [ var1 [ var6 ] ] - 1 . you have to return var8 . 
given integers var1 , var2 . initialize var3 to var1 , var4 to var2 . decrease var4 by 1 , var5 to 1 . while true , perform the following operations . increase var5 by 1 . set var5 to var5 modulo var3 . if var5 equals 0 , set var5 to var3 . if var4 - var5 is less than 0 , break the loop . decrease var4 by var5 . return var4 . 
given an array of integers var1 , initialize var3 to length of var1 and var5 to array of reals of length var3 . for each position var6 in var1 set var7 to var2 [ var6 ] / var0 - var1 [ var6 ] / var0 + 1 if var1 [ var6 ] % var0 = 0 , set var7 to var2 [ var6 ] / var0 - var1 [ var6 ] / var0 otherwise ( all results of division are rounded down ) , set var5 [ var6 ] to var7 / ( var2 [ var6 ] - var1 [ var6 ] + 1 ) . initialize var8 to 0 . 0 . for each position var9 in var5 add ( 1 - ( 1 - var5 [ var9 ] ) * ( 1 - var5 [ var9 + 1 ] ) ) * 2000 to var8 if var9 + 1 < var3 , add ( 1 - ( 1 - var5 [ var9 ] ) * ( 1 - var5 [ 0 ] ) ) * 2000 to var8 otherwise . return var8 . 
given an integer var0 , initialize var4 to empty array . append to var4 strings representing integers 4 and var0 - 4 if var0 is even , append to var4 strings representing integers 9 and var0 - 9 otherwise . return var4 . 
given an integer var0 , initialize var1 to 1 . for each var2 from 0 to var0 - 1 ( both inclusive ) multiply var1 by 2 ; substract 100 from var1 if var2 = 12 . return var1 . 
given integers var0 , var1 . initialize the result to 0 . for all var4 s from 1 to var4 < = var2 , increment the result by the value 1 < < var4 . when var4 becomes larger than var2 , return the resultant value . 
given char typed array var0 . assign 0 to var2 . for all var3 s from 0 to length of var0 - 1 , if var0 [ var3 ] is in the range from 65 to 90 , inclusive then add ( var0 [ var3 ] - 65 ) + 1 to var2 , otherwise , if var0 [ var3 ] is in the range from 97 to 122 then substract var0 [ var3 ] - 96 from var2 . return the resultant var2 . 
given an array var0 . initialize var1 to the length of array var0 . initialize var3 to 0 . initialize var4 to array of size var1 . initialize var5 to 0 . for each var6 from 0 inclusive to var1 exclusive do such operation : ( while var5 > 1 and var4 [ var5 - 1 ] < = min ( var4 [ var5 - 2 ] , var0 [ var6 ] ) do such operation : ( increase var3 by min ( var4 [ var5 - 2 ] , var0 [ var6 ] ) . decrement var5 ) . update var4 [ var5 ] to var0 [ var6 ] . increment var5 ) . for each var7 from 1 inclusive to var5 - 1 exclusive increase var3 by minimum of 2 neighbour elements of var4 [ var7 ] in array var4 . return var3 as result . 
given integers var0 , var1 . assign var1 to var2 , 2 to var3 , 0 to var4 . for each var5 from 0 to n - 1 , add var3 to var4 and multiply var3 by 2 . return var4 . 
you are given integers var0 and var1 . return the largest var2 such that all values i less than var2 correspond to following condition . i / 2 is larger than or equal to var0 and i / 3 is larger than or equal to var1 and i / 2 + i / 3 - i / 6 is larger than or equal to n + m 
given integers var0 and var1 , initialize var11 to empty array of strings , var2 to 0 , var3 to 2 - dimensional array of integers of dimensions var0 by var0 , var4 to 1 . for each integer var5 from 0 to var1 - 2 ( both inclusive ) iterate over all positions var6 in var3 , set var3 [ var6 ] [ var5 ] to var4 and add 1 to var4 . for each position var7 in var3 set var3 [ var7 ] [ var1 - 1 ] to var4 , add var4 to var2 , add 1 to var4 , iterate over all positions var8 in var3 [ var7 ] from var1 to var0 - 1 ( both inclusive ) and for each position set var3 [ var7 ] [ var8 ] to var4 and add 1 to var4 . append var2 , converted to string , to the end of var11 . iterate over all positions var9 in var3 : for each position var10 in var3 [ var9 ] append a string , obtained by concatenation of var3 [ var9 ] [ var10 ] , converted to string , and " " , to the end of var11 , append empty string to the end of var11 . 
you are given a string var2 , a number var0 , a number var1 . set var6 to " " and var4 to var1 . for each position var7 in var2 with var7 less than var0 you have to , set var8 to var2 [ var7 ] , if var8 - 97 is greater than 122 - var8 , store in var9 the minimum between var8 - 97 and var4 , concatenate the character var8 - var9 to var6 ; otherwise store in var9 the minimum between 122 - var8 and var4 , concatenate the character var8 + var9 to var6 ; subtract var9 to var4 . if var4 is greater than zero return - 1 , otherwise return var6 . 
you are given a number var0 and a number var1 . you have to create an array of strings var8 initially empty and an array of numbers var3 of length var0 + 1 . you have to set var2 to zero and var3 [ 0 ] to var0 * var0 + 1 . for each var4 between zero and var0 - 1 , you have to set var3 [ var4 + 1 ] to var3 [ var4 ] - var0 + var1 - 1 , add var3 [ var4 + 1 ] to var2 . you have to insert the decimal representation of var2 to var8 . you have to set var5 to 1 . for each var6 between zero and var0 - 1 and each var7 between 1 and var0 , if var7 is less than var1 you have to insert the decimal representation of var5 with a space at the end to the var6 - th row in var8 , add 1 to var5 ; otherwise you have to insert the decimal representation of var3 [ var0 - var6 ] + var7 - var1 with a space at the end to the var6 - th row in var8 . you have to return var8 . 
you are given integers var1 , var2 and an integer array var3 . let var5 be the size of var3 and set integers var6 to var1 and var7 to var2 . create a 1 - indexed prefix sum var8 of array var3 . create a 2d integer array var10 of size var5 + 1x var5 + 1 . iterate from 0 to var7 with integer var11 . in each iteration , do another loop iterating from 1 to var5 with index var12 . in each iteration , set var13 to t mod 2 , set var14 to var13 xor 1 , set var10 [ var12 ] [ var13 ] to var10 [ var12 - 1 ] [ var13 ] . if var11 > 0 and var12 - m > = 0 , set dp [ var12 ] [ var13 ] to the maximum between var10 [ var12 ] [ var13 ] and var10 [ var12 - var6 ] [ var14 ] + var8 [ var12 ] - var8 [ var12 - var6 ] . return var10 [ var5 ] [ var7 mod 2 ] . 
given integer array var0 . return the sorted var0 . 
given integer var5 and char typed arrays var6 , var7 . let var2 be the smallest position at which elements from var0 and var1 are not equal and var3 be the largest position at which values from var0 and var1 are not equal . assign j - i to var4 . add 1 to var2 . substract var4 from var3 . as long as len - 1 exceeds 0 do following operations . substract 1 from var4 . add 1 to var2 and to var3 . if var0 [ var2 ] does not equal var1 [ var3 ] then return 0 . when the loop is ended , return 1 . 
given integers var0 , var1 . assign 1 to var2 . while true do following operations . assign h / 2 , h / 3 , h / 6 to var3 , var4 , var5 . substract var5 from var3 , var4 . if var5 does not exceed the sum of two values where first value is the larger of 0 and var0 - var3 , second value is the larger of 0 and var1 - var4 , then return var2 . increment var2 . 
you are given the numbers var0 , var1 , var4 , var5 and the array of numbers var2 ( indexing is 0 - based ) and var3 ( indexing is 0 - based ) . you have to set var6 to the length of var2 . you have to create an array of numbers var8 of length var6 + 1 . you have to create an array of numbers var9 of length var6 + 1 . for each position var10 in var2 set var9 [ var10 ] to var3 [ var10 ] - var2 [ var10 ] + 1 , set var8 [ var10 ] to the value of the function func0 at the arguments var2 [ var10 ] , var3 [ var10 ] , var1 . you have to set var8 [ var6 ] to var8 [ 0 ] and var9 [ var6 ] to var9 [ 0 ] . for each position var13 in var8 set var8 [ var13 ] to 1 - ( var8 [ var13 ] divided by var9 [ var13 ] ) . you have to store in var14 the sum of 1 - var8 [ var15 ] * var8 [ var15 + 1 ] for each position var15 in var8 except the lastone . you have to return 2000 * var14 . 
given integers var0 , var1 . assign var0 and var1 to var2 and var3 , respectively . for all var4 s starting from 0 do following operations . if var2 is not less than var3 and 2 and var3 is not less than 1 then add 1 to var4 , substract 2 and 1 from var2 and var3 , respectively . otherwise , if var3 is not less than 2 and var2 and var2 is not less than 1 then add 1 to var4 and substract 1 and 2 from var2 and var3 , respectively . otherwise , exit from the loop . when the loop is ended , return var4 . 
given integer var0 . assign 2 , 0 to var1 , var2 . for each var3 from 1 to var0 , add var1 to var2 and multiply var1 by 2 . return var2 . 
you are given a number var0 . you have to return the sum of the powers of 2 between 1 and var0 . 
given integers var0 and var1 . set integer var4 to ( var1 - 1 ) and string var2 , var3 to " " . loop integer var5 from 0 to ( var0 - 1 ) ( exclusive ) , concatenate " 9 " to the front of string var2 and subtract 9 from var4 if var4 is greater than 9 else concatenate the string value of var4 to the front of var2 . concatenate the string value of 1 + var4 to the front of string var2 . set integer var4 to var1 . loop integer var7 from 0 to var0 ( exclusive ) , concatenate " 9 " to the end of string var3 and subtract 9 from var4 if var4 is greater than or equal to 9 else concatenate the string value of var4 at the end of string var3 and set var4 to 0 . return the concatenation of string var2 , " " and var3 . 
you are given integers var0 , var1 and arrays var2 , var3 of char types . if var3 equals " week " then if var1 equals one of values 5 , 6 then return 53 . otherwise , return 52 . if var3 was not equal to " week " then if var1 equals 31 then return 7 . otherwise , if var1 equals 30 then return 11 . otherwise , return 12 . 
given integer var0 , var1 . initialize var2 to var0 th power of 2 . assign 76 to var3 and 0 to var4 . while var0 does not equal 0 , do following operations . add 1 to var4 . if var3 equals 76 then if var1 does not exceed v / 2 then assign 82 to var3 , or in other case , let var4 be the sum of powers of 2 from 0 to n - 1 and exctract from var1 the value 2 erected to the power of n - 1 . otherwise , if var3 was not equal 76 then if var1 exceeds v / 2 then assign 76 to var3 and substract from var1 the value 2 erected to the power of n - 1 , or in other case let var4 be the sum of powers of 2 from 0 to n - 1 . substract 1 from var0 . divide var2 by 2 . if var0 equals 0 then exit from the loop . when the loop is ended , return var4 . 
given arrays var0 , var1 , var2 of char types . create a map var3 of types char consisting of pairs of values in var0 and in var1 standing at same positions . create an array var5 of char type . for all var6 s from 0 to var6 < length of var2 do following operations . assign var2 [ var6 ] to var7 . if var3 does not contain the key value equal to the lower case representation of var7 then add var7 to the end of var5 . otherwise , if var7 is lower case value then add the key of var7 in var3 , to the end of var5 . otherwise , add the upper case representation of key of lower case representation of var7 in var3 to the end of var5 . after the loop is ended , return var5 . 
you are given a number var5 and a number var6 . you have to return the var6 power of var5 . 
you are given a number var2 and a number var3 . you have to create an array of numbers var4 of length 2 . you have to set var4 [ 0 ] to 2 * var2 , and var4 [ 1 ] to 3 * var3 . you have to set var5 to the minimum between var2 divided by 3 ( rounded down ) and var3 divided by 2 ( rounded down ) . while var5 is different to 0 you have to , if var4 [ 0 ] is greater than var4 [ 1 ] set var6 to 1 , otherwise set var6 to zero , add var6 + 2 to var4 [ var6 ] , if var4 [ var6 ] is not divisible by ( 6 divided by var6 + 2 ( rounded down ) ) or var4 [ var6 ] is greater than var4 [ var6 bitwise xor 1 ] , subtract 1 to var5 . you have to return the maximum between var4 [ 0 ] and var4 [ 1 ] . 
given integers var0 , var1 . initialize var2 to var0 * 2 , var3 to var1 * 3 , var4 to var1 / 2 . for each var5 from 0 to var4 exclusive , perform the following operations . if var2 + 2 is less than var3 + 3 , add 2 to var2 ; else add 3 to var3 . if var3 modulo 2 equals 0 , increase var4 by 1 . return the maximum between var2 and var3 . 
given an array of integers var0 , initialize var6 to empty array of strings and copy var0 into a new array var2 . sort var2 in non - decreasing order . for each position var4 in var2 append a concatenation of var2 [ var4 ] , converted to string , and " " to the end of var6 . return var6 . 
given an array of integers var0 , initialize var11 to empty array of strings , var2 to length of var0 and var4 to empty integer to integer map . for each distinct element x in var0 set the value of var4 at x to the number of occurrences of x in var0 . initialize var6 and var7 to array of integers of length var2 . set all elements of var6 to var2 - 1 . for each position var9 in var1 add the value of var4 at var1 [ var9 ] to var6 [ var9 ] and set var7 [ var9 ] to var2 - 1 minus the value of var4 at var1 [ var9 ] if var4 has key var1 [ var9 ] , set var7 [ var9 ] to var2 - 1 otherwise . for each position var10 in var6 append a string , obtained by concatenation of string representation of var6 [ var10 ] , " " , string representation of var7 [ var10 ] and " \ t " , to the end of var11 . return var11 . 
you are given a number var0 and a number var1 . you have to create an array of strings var12 initially empty . you have to create an array of numbers var2 of length var0 * var0 . you have to create a var0 * var0 matrix of numbers var3 . you have to set var4 to 1 and var5 to zero . for each var6 between 0 and var0 - 1 and each var7 between 0 and var1 - 2 you have to set var3 [ var6 ] [ var7 ] to var4 and add 1 to var4 . for each var8 between 0 and var0 - 1 you have to iterate var9 between var1 - 1 and var0 - 1 and you have to set var3 [ var8 ] [ var9 ] to var4 and add 1 to var4 , after the loop in var9 ends you have to add var3 [ var8 ] [ var1 - 1 ] to var5 . after the loop in var8 ends you have to add the decimal representation of var5 to var12 . you have to insert each decimal representation of each element of var3 with a space at the end to var12 . you have to return var12 . 
given integers var1 , var2 , var3 . create integer typed matrix var4 of sizes 104 , 2 . assign 0 to var4 [ 0 ] [ 0 ] and to var4 [ 0 ] [ 1 ] . for all var5 s from 1 to var1 dollowing operations . assign 0 to var4 [ var5 ] [ 0 ] and to var4 [ var5 ] [ 1 ] . for all var6 s from 1 to var2 do following operations . if var6 exceeds var5 then exit from the current loop . if var6 is less than var3 then add the values var4 [ i - j ] [ 0 ] , var4 [ i - j ] [ 1 ] both modulo 10 ^ 9 + 7 to var4 [ var5 ] [ 0 ] and to var4 [ var5 ] [ 1 ] , respectively . otherwise , add var4 [ i - j ] [ 0 ] modulo 10 ^ 9 + 7 to var4 [ var5 ] [ 1 ] and multiply var4 [ var5 ] [ 1 ] by 2 modulo 10 ^ 9 + 7 . when the loops are ended , return var4 [ var1 ] [ 1 ] . 
given integers var0 , var1 and a string var2 , initialize var3 to var0 - 1 , var4 to var1 - 1 , var5 to 0 , var6 to - 1 , var7 to 0 , set var4 to var3 - var4 if var4 > var3 / 2 ( rounded down ) . for each position var8 from 0 to var3 / 2 ( rounded down , both inclusive ) if var2 [ var8 ] ! = var2 [ var3 - var8 ] , then do the following operations : initialize var9 to absolute difference of var2 [ var8 ] - var2 [ var3 - var8 ] , add the smaller of var9 and 26 - var9 to var5 , set var6 to var8 if var6 = - 1 , set var7 to var8 otherwise . add the smaller of absolute values of var4 - var6 and var4 - var7 to var5 , add the greater of var7 - var6 and 0 to var5 . return 0 if var6 = - 1 , return var5 otherwise . 
given integers var0 , var1 . initialize var2 to the least common multiple of var0 and var1 , var3 to var2 / var0 , var4 to var2 / var1 . if var0 is less than var1 , decrease var3 by 1 ; else decrease var4 by 1 . if var3 is greater than var4 , return " Dasha " ; else if var3 is less than var4 , return " Masha " ; else return " Equal " . 
given integers var2 , var3 . return the factorial of the minimum of var2 and var3 . 
given var0 , return the value of var0 factorial . 
given integers var4 and var5 . return factorial value of minimum of var4 and var5 . 
given arrays var0 and var1 . let x : = bitwise or of elements of var0 and y : = bitwise or of elements of var1 . return the sum of x and y . 
given an integer var0 . return the sum of all values of 2 ^ var3 for all var3 from 1 to var0 . 
given an integer var0 , find the sum of all powers of 2 with integer exponents between 1 and var0 ( both inclusive ) and return the result . 
given an integer var0 , initialize var2 to array of integers of length 56 . set var2 [ 0 ] to 0 and var2 [ 1 ] to 1 . for each position var4 from 1 to var0 ( both inclusive ) set var2 [ var0 ] to var2 [ 1 ] + 2 * var2 [ var4 - 1 ] . return 2 * var2 [ var0 ] . 
given arrays of integers var0 , var1 and var2 , find the sum of smaller of two values var0 [ var1 [ var5 ] - 1 ] and var0 [ var2 [ var5 ] - 1 ] over all positions var5 in var1 . return the result . 
given integers var0 , var1 . assign 0 to var3 . for each var4 from 0 to n - 1 and for each var5 from ( var4 + 1 ) % var0 to ( var4 + var1 ) % var0 add to the end of var2 the values i + 1 , j + 1 , separated by space , and add 1 to var3 . when var4 equals to var0 , in separate lines print var3 and var2 . 
given integer var1 and char typed array var2 and var3 . return the number of elements in __globals__.a . months which are not less than var1 . 
you are given a number var0 and a number var1 . if var1 is less than var0 - 1 or var1 is greater than 2 * var0 + 2 you have to return - 1 . you have to set string var2 to " " . while var0 is greater than zero or var1 is greater than 0 , if var0 is equal to var1 you have to concatenate string " 10 " to var2 , subtract 1 to var0 , subtract 1 to var1 ; otherwise if var0 is greater than var1 you have to concatenate string " 0 " to var2 and subtract 1 to var0 , otherwise if var1 is greater than var0 and var0 is greater than zero you have to concatenate string " 110 " to var2 , subtract 1 to var0 , subtract 2 to var1 ; otherwise you have to concatenate var1 copies of " 1 " to var2 . after the loop ends you have to return var2 . 
given integer array var0 . return the sorted var0 . 
given strings var4 , var5 , var6 , initialize var7 to empty string . for each position var3 in var6 set var8 to var6 [ var3 ] if var6 [ var3 ] is a digit , set var8 to var5 [ j ] , where j is such position that var4 [ j ] = var6 [ var3 ] , if var6 [ var3 ] is a lowercase english letter , set var8 to var5 [ j ] , changed to uppercase , where j is such position that var4 [ j ] is equal to var6 [ var3 ] , changed to lowercase , if var6 [ var3 ] is an uppercase english letter , and append var8 to the end of var7 . return var7 . 
given integers var1 , var2 . return the factorial of the minimum between var1 and var2 . 
you are given integers var0 , var3 var4 and arrays var1 , var2 of integer types . let var5 be the length of var1 . return " Karen " . 
given 0 - based arrays var0 , var1 of integer types . assign the length of var0 to var2 . assign var0 to sorted set var3 . insert var1 into var3 . let var6 be the number of values var0 [ var7 ] ^ var1 [ var8 ] which var3 contains where var8 and var4 obtain values from 0 to n - 1 . if var6 is even number then return " Karen " . otherwise , return " Koyomi " . 
given an array var0 . initialize var2 to the number of elements in var0 divisible by 3 , var3 to the number of elements giving a remainder 1 after dividing them by 3 , var4 to the number of elements giving a remainder 2 after dividing them by 3 . return the value of min ( var3 , var4 ) + var2 / 2 . 
you are given an array var0 and an array var1 . create a new bool array var3 of size 3000000 and for each element var4 in var0 , set var3 [ var4 ] to true . let var2 be the size of var0 . for each var4 from 0 till var2 - 1 set var3 [ var1 [ var4 ] ] to true . let var6 be the amount of indices made by the xor of each pair of elements from arrays var0 and var1 , where the the value of the indexed element in var3 is true . if var6 is divisible by 2 without remainder , return " Karen " , otherwise return " Koyomi " . 
given a string var0 . initialize var1 to 1e9 + 7 , var2 to an array of length 256 . for each var3 from 48 to 57 , set var2 [ var3 ] to var3 - 48 . for each var4 from 65 to 90 , set var2 [ var4 ] to var4 - 55 . for each var5 from 97 to 122 , set var2 [ var5 ] to var5 - 61 . set var2 [ 45 ] to 62 , var2 [ 95 ] to 63 . initialize var6 to an array of length 64 . for each var7 from 0 to 63 , iterate through all values of var8 from 0 to 63 and add 1 to var6 [ var7 & var8 ] . initialize var9 to 1 . for each var10 from 0 to the length of var0 exlusive , set var9 to ( var9 * var6 [ var2 [ var0 [ var10 ] ] ] ) modulo var1 . return var9 . 
given integers var2 , var1 , var0 , var4 , var3 . initialize var5 to 0 , var6 to var2 * var0 . while var6 is less than var4 , perform the following operations . add ( var6 / ( var1 - var0 ) * var0 ) to var6 . if var6 is less than var4 , increase var5 by 1 and add ( var6 / var1 + var3 ) * var0 to var6 ; else break the loop . return var5 . 
given integers var1 , var2 . initialize var3 to an array of length var1 + 1 . set var3 [ 0 ] to 1 . for each var4 from 0 to var1 , perform the following operations . initialize var5 to 1 . while var5 is not greater than var2 and var4 - var5 is not less than 0 , set var3 [ var4 ] to ( var3 [ var4 ] + var3 [ var4 - var5 ] ) modulo 1000000007 and increase var5 by 1 . return var3 [ var1 ] . 
given arrays of integers __globals__.a . ns , __globals__.a . xs , __globals__.a . ys and __globals__.a . ans and integers var4 , var5 and var6 , initialize var8 to empty array of integers . for each position var7 in __globals__.a . ns append __globals__.a . ans [ var7 ] to the end of var8 and return var8 if var4 = __globals__.a . ns [ var7 ] , var5 = __globals__.a . xs [ var7 ] and var6 = __globals__.a . ys [ var7 ] . return var8 . 
given an integer var0 . if var0 is less than or equals to 2 , return an array of string which contains only 1 element " - 1 " . initialize 2 integers var1 , var2 both to 0 . otherwise , if var0 is an odd number , set var1 to ( var0 / 2 ) rounded down times ( var0 + 1 ) , then set var2 to var1 plus 1 . otherwise , if var0 is divisible by 4 , set var1 to ( ( var0 / 4 ) * 3 ) , then set var2 to ( ( var0 / 4 ) * 5 ) . otherwise , if var0 - 2 is divisible by 4 , set var1 to ( var0 / 4 ) rounded down times ( var0 + 2 ) , then set var2 to var1 plus 2 . return a string array which contains 2 elements , the first one is string presentation of var1 , the second one is string presentation of var2 . 
given integer array var0 . return var0 sorted in increasing order . 
you are given an array of numbers var2 ( indexing is 0 - based ) , a number var0 , a number var1 . you have to create an array of numbers var4 of length var3 + 1 initialized with zeros . for each var5 between 1 and var3 set var4 [ var5 ] to var4 [ var5 - 1 ] + var2 [ var5 - 1 ] . you have to create a matrix of numbers var6 with 2 rows and var3 + 1 columns . for each var7 between 1 and var1 you have to , set var8 to var7 modulo 2 , for each var9 between var7 * var0 and var3 , set var6 [ var8 ] [ var9 ] to var6 [ var8 ] [ var9 - 1 ] , set var10 to var6 [ 1 - var8 ] [ var9 - var0 ] + var4 [ var9 ] - var4 [ var9 - var0 ] , store in var6 [ var8 ] [ var9 ] the maximum between var6 [ var8 ] [ var9 ] and var10 . you have to return var6 [ var1 modulo 2 ] [ var3 ] . 
given integer arrays var0 , var1 . assign the lengths of var0 and var1 to var2 and var3 , respectively . assign 0 to var4 , var6 and to var7 . for all var4 s from 0 to n - 1 do following operations . assign false to var9 . assign 2147483647 to var8 . add 1 to var6 , assign true to var9 and assign the module var0 [ var4 ] - var1 [ var6 ] to var8 as long as var6 is less than var3 and the module var0 [ var4 ] - var1 [ var6 ] does not exceed var8 . substract 1 from var6 . if var9 is true and var8 exceeds var7 then assign var8 to var7 . when var4 becomes equal to var2 , return var7 . 
given arrays of integers var0 and var1 , initialize var2 to length of var0 . set var4 to the smaller of var2 and 2 . for each position var5 in var0 from 1 ( inclusive ) to var2 - 1 ( exclusive ) if var0 [ var5 ] - var1 [ var5 ] > var0 [ var5 - 1 ] , then add 1 to var4 , otherwise if var0 [ var5 ] + var1 [ var5 ] < var0 [ var5 + 1 ] , then add 1 to var4 and add var1 [ var5 ] to var0 [ var5 ] . return var4 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to store in var2 [ 0 ] the number of positions var3 in var0 with var0 [ var3 ] modulo 3 equal to zero . you have to store in var2 [ 1 ] the number of positions var3 in var0 with var0 [ var3 ] modulo 3 equal to 1 . you have to store in var2 [ 2 ] the number of positions var3 in var0 with var0 [ var3 ] modulo 3 equal to 2 . you have to set var5 to var2 [ 0 ] divided by 2 ( rounded down ) . if var2 [ 1 ] is greater than var2 [ 2 ] you have to add var2 [ 2 ] to var5 , otherwise you have to add var2 [ 1 ] to var5 . you have to return var5 . 
given integer var1 and char matrix var2 . assign to var3 the length of var2 . assign var1 to var4 . create integer matrix var6 of sizes var3 , var4 . assign 0 to var7 . for each var5 from n - 1 downto 0 and for each var9 from m - 1 downto 0 , if var2 [ var8 ] [ var9 ] equals 87 and var6 [ var8 ] [ var9 ] does not equal 1 or if var2 [ var8 ] [ var9 ] equals 66 and var6 [ var8 ] [ var9 ] does not equal - 1 then do following operations . add 1 to var7 . if var2 [ var8 ] [ var9 ] equals 87 then assign 1 - var6 [ var8 ] [ var9 ] to var10 . otherwise , assign - 1 - b [ var8 ] [ var9 ] to var10 . add var10 to each value var6 [ var11 ] [ var12 ] where var12 is from 0 to var9 and var11 is from 0 to var8 . when the loops are ended , return var7 . 
you are given a number var0 and a number var1 . set var2 to the minimum between var0 and var1 . return the factorial of var2 . 
you are given an integer array var0 . sort var0 and return a string of it ' s space separated elements in sorted order . 
given an integer var0 . if var0 is smaller than 2 and bigger than - 1 then return 1 . otherwise follow these steps recursively with parameters x and y which are initially equal to 2 and var0 respectively ; if y - x is equal to zero return x . otherwise , if y - x is equal to 1 return x * y . otherwise , if y - x is equal to 2 return ( ( x * ( x + 1 ) ) * y ) . otherwise , initialize var2 to ( x + ( y - x ) divided by 2 rounded down ) and return the value which is returned when starting steps with parameters x and var2 multiplied by value returned when starting with parameters var2 + 1 and y . 
given an integer var0 , var1 is equal to factorial of var0 . return string of var1 . 
given integers var0 , var1 . return the factorial of the minimum of var0 and var1 . 
you are given integers var0 , var1 . return the factorial of the minimum of var0 and var1 . 
given integers var0 , var1 . return the factorial of the minimum of var0 and var1 . 
given integers var0 , var1 . return the factorial of the minimum of var0 , var1 . 
given array var0 of char type . create a matrix var4 of char type . assign the integer representation of var0 to var2 with leading and trailing spaces being removed . if var2 equals 1 then insert " 1 1 " into var4 and insert 1 into var4 . otherwise , add the values ( var2 - 1 ) * 2 , 2 , separated by spaces , to the end of var4 and add the values 1 and 2 , separated by spaces to the end of var4 . return var4 . 
given integer array var0 . return sorted var0 . 
you are given integers var0 , var1 , var2 , var3 , var4 , var5 , var6 , var7 , var8 , var9 , var10 , var11 , var12 , var13 , var14 , var15 . if ( ( ( ( ( var3 is equal to 1 ) and ( ( ( ( ( ( var0 is equal to 1 ) or ( var1 is equal to 1 ) ) or ( var2 is equal to 1 ) ) or ( var4 is equal to 1 ) ) or ( var9 is equal to 1 ) ) or ( var14 is equal to 1 ) ) ) or ( ( var7 is equal to 1 ) and ( ( ( ( ( ( var4 is equal to 1 ) or ( var5 is equal to 1 ) ) or ( var6 is equal to 1 ) ) or ( var2 is equal to 1 ) ) or ( var8 is equal to 1 ) ) or ( var13 is equal to 1 ) ) ) ) or ( ( var11 is equal to 1 ) and ( ( ( ( ( ( var8 is equal to 1 ) or ( var9 is equal to 1 ) ) or ( var10 is equal to 1 ) ) or ( var1 is equal to 1 ) ) or ( var6 is equal to 1 ) ) or ( var12 is equal to 1 ) ) ) ) or ( ( var15 is equal to 1 ) and ( ( ( ( ( ( var12 is equal to 1 ) or ( var13 is equal to 1 ) ) or ( var14 is equal to 1 ) ) or ( var0 is equal to 1 ) ) or ( var5 is equal to 1 ) ) or ( var10 is equal to 1 ) ) ) ) assign var16 to true . if var16 is equal to true return " YES " , otherwise return " NO " . 
given an integer var0 , round it to the nearest integer , which is divisible by 10 . in case of tie round it up . 
given an integer var1 , find the smallest non - negative integer var3 such that ( var1 - var3 ) % 10 = 0 and the smallest non - negative integer var4 such that ( var1 + var4 ) % 10 = 0 . return var1 - var3 if var3 < var4 , return var1 + var4 otherwise . 
you are given a number var0 and a number var1 . you have to set var2 to zero . for each var3 from 0 to var1 you have to set var4 to ( var1 - var3 ) * var0 , set var5 to ( ( var4 * ( var4 + 1 ) ) / 2 ) * ( var3 + 1 ) + ( ( var3 * ( var3 + 1 ) ) / 2 ) * ( var4 + 1 ) , store in var2 the maximum between var2 and var5 . you have to return var2 . 
given 0 - based integer typed array var0 . assign the sorted version of var0 to var2 . return elements of var2 being separated by spaces . 
given an integer var0 . return the factorial of var0 . 
given integers var0 , var1 . return the factorial of minimum of var0 and var1 both decreased by 1 . 
given integers var0 , var1 . return the factorial of the minimum of var0 and var1 . 
given an integer var0 . initialize var1 to var0 modulo 10 . if var1 is not greatetr than 5 , while var1 not equals 0 , decrease var1 and var0 by 1 ; else while var1 not equals 10 , increase var1 and var0 by 1 . return var0 . 
given an integer var0 . initialize var1 to var0 % 10 . if var1 is in closed interval [ 0 , 5 ] , decrease var0 by var1 . otherwise if var1 is in closed interval [ 6 , 9 ] , increase var0 by 10 minus var1 . return the value of var0 at the end . 
you are given a string var0 , a string var1 , a string var2 . you have to create an associative container var3 with a character as key and a character as value . for each var4 between 0 and 25 , insert the key var0 [ var4 ] with value var1 [ var4 ] to var3 , insert the key var0 [ var4 ] - 97 + 65 with value var1 [ var4 ] - 97 + 65 to var3 . set var5 to " " . for each position var6 in var2 you have to , if var3 contains var2 [ var6 ] as key set var7 to the value of var2 [ var6 ] in var3 , otherwise set var7 to var2 [ var6 ] , concatenate var7 to var5 . you have to return var5 . 
given an integer var1 , round it to the nearest integer , which is divisible by 10 ( in case of tie round up ) . store the result in var2 . return var2 . 
given strings var1 , var2 , var3 . initialize var4 to an empty map . for each var5 from 0 to the length of var1 excluisve , set var4 [ s [ i ] ] to var2 [ var5 ] . initialize var6 to an empty string . for each var7 from 0 to the length of var3 exclusive , perform the following operations . if var3 [ var7 ] is a letter , perform the following operations . if var3 [ var7 ] is a lowercase letter , concatenate var6 with var4 [ var3 [ var7 ] ] . otherwise , concatenate var6 with the lowercase of var4 [ var3 [ var7 ] ] . if var3 [ var7 ] is not a letter , just concatenate it with var6 . return var6 . 
given char typed array var0 . create integer array var1 of size 64 . add 1 to all values var1 [ ( var2 & var3 ) ] where both var2 and var3 obtain values from 0 to 63 . assign var0 to var4 . assign 1 to var6 . for all var2 s from 0 to length of var4 minus 1 do following operations . if var4 [ var2 ] is in the range from 48 to 57 or from 65 to 90 or from 97 to 122 then assign to var9 the values var4 [ var2 ] - 48 , var4 [ var2 ] - 55 , var4 [ var2 ] - 61 , respectively . if var4 [ var2 ] equals 45 then assign 62 to var9 . if none of these cases is true then assign 63 to var9 . multiply var6 by var1 [ var9 ] modulo 10 ^ 9 + 7 . return the resultant var6 . 
you are given a string var1 , a string var2 , a string var3 . you have to create an associative container var4 with a character as key and a character as value . for each position var5 in var1 you have to insert the key var1 [ var5 ] with value var2 [ var5 ] to var4 . set var7 to " " . for each position var8 in var3 you have to , set var9 to var3 [ var8 ] , if var9 - 97 is greater than or equal to 0 and var9 - 97 is less than 26 , concatenate the value of key var9 in var4 to var7 , otherwise if var9 - 65 is greater than or equal to 0 and var9 - 65 is less than 26 , concatenate the value of the lowercase fashion of var9 in var4 in uppercase fashion to var7 , otherwise concatenate var9 to var7 . you have to return var7 . 
given an array of integers var0 , initialize var6 to empty array of strings and copy var0 into a new array var2 . sort var2 in non - decreasing order . for each element var4 in var2 append a string , obtained by concatenation of var4 , converted to string , and " " , to the end of var6 . return var6 . 
you are given an array var0 of integer type . assign the values 0 , 1 , 1 to variables var2 , var3 , var4 , respectively . for all var5 s from 0 to var5 < the length of var0 do following operations . assign var5 to var6 . while var6 is larger than 0 and var0 [ var6 ] is larger than or equal to var0 [ var6 - 1 ] decrement var6 and increment var3 . after the current loop is ended , assign var5 to var6 . while var6 is less than n - 1 and var0 [ var6 ] is larger than or equal to var0 [ var6 + 1 ] increment var6 and var3 . after the current loop is ended , update var4 by the larger of var3 and var4 . assign 1 to var3 . after all loops are ended , return var4 . 
given a 2d array of characters , and an integer var1 . set the value of var3 to the number of rows in var2 . create a 2d array of integers var6 which currently consists of zeros . we want the value at var6 [ var5 ] [ var9 ] to be equal to 1 if var2 [ var5 ] [ var9 ] is equal to w , and var6 [ var5 ] [ var9 ] should be equal to - 1 otherwise , such that ( 0 < = var5 < var3 and 0 < = var9 < var1 ) . a change operation of the form ( var5 , var9 , var12 ) means adding the value var12 to all cells in var6 from the rectangle whose upper left cell is ( 0 , 0 ) and whose lower right cell is ( var5 , var9 ) . return the minimum number of operations required to make every cell in var6 equal to the required value at that cell . 
given 0 - based arrays var0 , var1 of integer types . assign the lengths of var0 and var1 to var2 and var3 , respectively . create an array var4 of size var3 and of integer type . create a boolean array var5 of size var2 . assign to var6 the sum of elements in var0 . assign 0 to var8 . for all var7 s from 0 to var7 < var3 do following operations . assign var1 [ var7 ] - 1 to var4 [ var7 ] . assign true to var5 [ var4 [ var7 ] ] . increase var8 by var0 [ var4 [ var9 ] ] . when var7 becomes equal to var3 exit from the loop . let var10 be the sum of values var0 [ ( var11 % var2 ) ] * var0 [ ( ( var11 + 1 ) % var2 ) ] where var11 obtains values from 0 to n - 1 , incusive . iterating over var4 where var12 is current value , increase var10 by the value var0 [ var12 ] * ( ( ( var6 - var0 [ var12 ] ) - var0 [ ( ( var12 + 1 ) % var2 ) ] ) - var0 [ ( ( ( var12 - 1 ) + var2 ) % var2 ) ] ) . iterating over var4 where var14 is current value do following operations . assign values ( ( var14 - 1 ) + var2 ) % var2 , ( var14 + 1 ) % var2 to var15 and var16 , respectively . decrease var13 by the value var0 [ var14 ] * ( ( var8 - var0 [ var14 ] ) - var0 [ var15 ] + var0 [ var16 ] ) where var0 [ var15 ] is to be substracted only if var5 [ var15 ] is true and var0 [ var16 ] is to be added only if var5 [ var16 ] is true . after the loop is ended , return the value ans + minusans / 2 . 
given integer var0 and char typed array var1 . assign - 1 to var2 and to var3 . assign 0 to var4 . iterating over var1 where var5 is current position , if current var1 [ var5 ] is 76 and var3 is not negative value and i - r is even value then assign var5 to var2 and add 1 to var4 , or if var1 [ var5 ] is 82 then assign var5 to var3 and add the value r - l - 1 to var4 . if resultant var3 does not exceed var2 then add the value n - l - 1 to var4 . return var4 . 
given an integer var5 , round it to the nearest integer , which is divisible by 10 . if there are two such integer , round it to the smaller one . return the result . 
you are given an array var0 of integer type . return the sorted array var0 . 
given integers var0 and var1 , find the product of all positive integers , which are not greater than both var0 and var1 , and return the result . 
given integers var0 and var1 , find the product of all positive integers , which are not greater than both var0 and var1 . return the result . 
given array var0 of integer type . create a matrix var6 of char type . let var1 be the lenght of var0 . initialize var0 to var2 . sort the array var2 . return var6 consisting of characters of var2 separated by spaces . 
you are given a string var0 . for each number var2 divisible by 8 between 0 and 9999 , if the decimal representation of var2 can be obtained by eliminating some digits of var0 without rearranging the remaining digits , you have to print the string " YES " and in the next line you have to print the decimal representation of var2 and finish the program . after the loop in var2 ends , you have to print the string " NO " . 
given an array of integers var1 , and an integer var0 . set the value of var10 to the sum of num [ var3 ] * var1 [ var3 ] ( 0 < = var3 < | var1 [ var3 ] | ) , such that : 1 - var1 is an array of non - negative integers , 2 - the sum of num [ var3 ] * ( 2 to the power of ( var3 - 1 ) ) is bigger than or equal to var0 , 3 - the value of var10 is as small as possible . return var10 . 
you are given a number var0 . if var0 modulo 5 is less than or equal to 5 , subtract ( var0 modulo 10 ) to var0 , otherwise set var0 to var0 + 10 - ( var0 modulo 10 ) . return var0 . 
given integers var1 , var2 , var3 and 0 - based , integer typed array var4 . assign the length of var4 to var5 . assign var1 , var2 to var6 and var7 , respectively . assign var3 to __globals__.a . modulo . create integer typed matrix var9 of sizes m + 1 , b + 1 . assign 1 to var9 [ 0 ] [ 0 ] . for all var12 s from 0 to var7 , if j + a [ var10 ] does not exceed var7 then increase var9 [ var11 + 1 ] [ var12 + var4 [ var10 ] ] by var9 [ var11 ] [ var12 ] modulo var3 where var10 and var11 obtain values from 0 to to n - 1 and to m - 1 , respectively . when the loops are ended , assign to the result the sum of elements in var9 [ var6 ] . 
given array var0 of char type and a matrix var1 of char type . assign 1000000007 to var2 . create arrays var3 consisting of digits from 0 to 9 , var4 at all positions containing the value 10 , both of size 10 and of integer type . let var6 be the length of var1 . assign 0 to var7 . for all var8 s from n - 1 to var8 > = 0 do following operations . assign var1 [ var8 ] [ 0 ] - 48 to var9 . assign 0 , 1 to var10 , var11 , respectively . for all var12 s from var12 = length of var1 [ var8 ] decremented by 1 to var12 > = 3 do following operations . assign ( var10 + ( var3 [ ( var1 [ var8 ] [ var12 ] - 48 ) ] * var11 ) ) % var2 to var10 . assign ( var11 * var4 [ ( var1 [ var8 ] [ var12 ] - 48 ) ] ) % var2 to var11 . after the loop is ended , assign var10 to var3 [ var9 ] . assign var11 to var4 [ var9 ] . after all loops are ended , assign 0 , 1 to var13 , var14 , respectively . for all var15 s from var15 = length of var0 decremented by 1 to var15 > = 0 do following operations . assign ( var13 + ( var3 [ ( var0 [ var15 ] - 48 ) ] * var14 ) ) % var2 to var13 . assign ( var14 * var4 [ ( var0 [ var15 ] - 48 ) ] ) % var2 to var14 . after all loops are ended , return var13 . 
given integers var0 , var1 . initialize var2 to 0 . for each var3 from 0 to var1 , initialize var4 to ( var1 - var3 ) * var0 and set var2 to the maximum between var2 and ( var4 + 1 ) * ( var3 + 1 ) * ( var4 + var3 ) / 2 . return var2 . 
you are given a number var6 . you have to return the factorial of var6 . 
given integer var0 . create integer array var1 consisting of values 1 , 2 . if var0 equals 1 then assign 1 to var2 . otherwise , assign 2 * ( var0 - 1 ) to var2 . in the first line of output , return var2 and 2 separated by space . in the next line return values var1 [ 0 ] and var1 [ 1 ] . 
you are given integers var2 , var0 and a string var1 . iterate from 0 to var0 - 1 with index var2 , and if var1 [ var2 ] is equal to 42 , iterate up from 1 with index var3 , while var2 + ( var3 * 4 ) is less than var0 . let variables var4 , var5 , . . . , var7 be integers , such that their values is equal to var2 + ( var3 * index ) , where index is 1 - based . if f [ var4 ] , f [ var5 ] , f [ var6 ] , f [ var7 ] are all equal to 42 , return " yes " . if nothing was returned after all iterations , return " no " . 
given integer var1 and char array var2 . create char typed matrix var7 . for all var3 s from 0 to n - 1 do following operations . assign 1 to var4 . while i + step * 4 is less than var1 do following operations . assign true to var5 . for all var6 s from 0 to 4 if var2 [ ( var3 + ( var4 * var6 ) ) ] equals 42 then update var5 by all & & 1 . otherwise , update it by all & & 0 . if var5 is true then return " yes " . when var3 becomes equal to var1 , if nothing is returned , return " no " . 
given integers var0 , var1 , var2 . create an array var3 of value var0 , var1 , var2 . if ( ( 1 . 0 / var3 [ 1 ] ) + ( 1 . 0 / var3 [ 2 ] ) ) + ( 1 . 0 / var3 [ 0 ] ) is less than 0 . 98 then return " NO " . sort var3 . of var3 [ 1 ] equals 2 or if var3 [ 0 ] equals 2 and both var3 [ 1 ] and var3 [ 2 ] equal 4 then return " YES " . if there is such case that var4 is not divisible by var3 [ 0 ] and i - 1 is not divisible by var3 [ 1 ] and i - 2 is not divisible by var3 [ 2 ] then return " NO " where var4 obtains values from 0 to var3 [ 0 ] * var3 [ 1 ] * var3 [ 2 ] - 1 . otherwise , return " YES " . 
given array var1 of char type . let var2 be the position in var1 where " ^ " is standing . assign 0 to var3 , var4 . assign var2 to var5 . for all var6 s frmo 0 to var6 < var2 do following operations . if var1 [ var6 ] does not equal 61 then increment var3 by the numeric value of var1 [ var6 ] ) * var5 . decrement var5 . after the loop is ended , assign 1 to var5 . for all var7 s from var2 + 1 to var7 < length of var1 do following operations . if var1 [ var7 ] does not equal 61 then increment var4 by the numeric value of var1 [ var7 ] ) * var5 . increment var5 . after the loop is ended , if var4 equals var3 then return " balance " . if var4 is larger than var3 then return " right " . otherwise , return " left " . 
you are given the strings var0 , var1 , var2 . you have to create an associative container ( string , string ) var5 . for each position var3 in var0 insert the key var0 [ var3 ] with the value var1 [ var3 ] to var5 . you have to set var6 to " " . for each position var3 in var2 , if var2 [ var3 ] is greater than or equal to 65 and var2 [ var3 ] is less than or equal to 90 you have to , set var7 to the character var2 [ var3 ] in lowercase fashion , set var7 to the value of the key var7 in var5 in uppercase fashion , concatenate var7 to var6 ; otherwise if var2 [ var3 ] is greater than or equal to 97 and var2 [ var3 ] is less than or equal to 122 concatenate the value of key var2 [ var3 ] in var5 to var6 ; otherwise concatenate var2 [ var3 ] to var6 . you have to return var6 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to return an array with the elements of var0 sorted from lowest to highest . 
two arrays var0 and var1 of the same length are given . initialize n as the length of that arrays and s as an empty string . for each x in var1 , concat " y z " to s where y = n - 1 + frequency of x in var1 and z = 2 * ( n - 1 ) - y return the final string s . 
given two integers var2 and var3 compute and return the factorial of the result of invocation of func0 ( first , var3 ) 
given an array var1 and an integer var0 . initialize var9 to an empty array , var2 to the length of var1 , var3 to the sum of elements of var1 . for each var5 from 0 to var2 exclusive , perform the following operations . initialize var6 to 0 , var7 to the maximum between 1 and var0 - var3 + var1 [ var5 ] , var8 to the minimum between var0 - var2 + 1 and var1 [ var5 ] . if var8 is not less than var7 , set var6 to var1 [ var5 ] - var8 + var7 - 1 . push var6 into var9 . return var9 . 
given an array var0 . initialize var2 to var0 . sort the elements of var2 in increasing order . initialize var5 , var7 to 0 , var1 to the length of var0 , var6 to an array of length var1 / 2 . for each var8 from var1 - 1 to 1 , if var2 [ var8 ] - var2 [ var8 - 1 ] is not greater than 1 , set var6 [ var7 ] to var2 [ var8 - 1 ] and increase var7 by 1 . for each var9 from 0 to var1 / 2 - 1 exclusive , if ( var6 [ var9 ] not equals 0 and var6 [ var9 + 1 ] not equals 0 ) , add the value of var6 [ var9 ] * var6 [ var9 + 1 ] to var5 . return var5 . 
given an integer var0 and an array var1 of char type . assign 0 , 1 to var2 and var3 , respectively . let var4 be the length of var1 . create an array var5 of size 128 and of integer type . assign 1 to var5 [ var1 [ 0 ] ] . while var3 is less than var0 , do following operations . if var5 [ var1 [ var3 ] ] equals 0 then assign ( var3 - var2 ) + 1 to var4 . increment var5 [ var1 [ var3 ] ] . while var2 is less than var3 and var5 [ var1 [ var2 ] ] is larger than 1 do following operations . decrement var5 [ var1 [ var2 ] ] . increment var2 . set the minimum of var4 and ( var3 - var2 ) + 1 to var4 . after the current loop is ended , increment var3 . after all loops are ended , return var4 . 
given an array var1 and an integer var0 . set integers var7 to 0 , var3 to var0 , var2 to the length of the array var1 , var4 to 0 , var5 to 0 and var6 to 0 . for var6 in range 0 to var2 - 1 , increase the value of var5 by var1 [ var7 + 1 ] . if var5 is greater than 8 , increase the value of var4 by 8 and decrease the value of var5 by 8 . else , increase the value of var4 by var5 and set var5 equal to 0 . if var4 is greater than or equal to var3 break from the loop . if after the completion of the loop , var4 is less than var3 , return ( 0 - 1 ) else return var2 + 1 . 
given integers var0 , var1 . initialize var2 to 0 . while true , perform the following operations . if the maximum between var0 and var1 is less than 2 or minimum between them is less than 1 , break the loop . if var0 is greater than var1 , increase var2 by 1 , decrease var0 by 2 and decrease var1 by 1 ; else increase var2 by 1 , decrease var1 by 2 and decrease var0 by 1 . return var2 . 
you are given integers var0 and var1 . return the factorial of min ( var0 , var1 ) . 
you are given a number var0 and a number var1 . you have to store in var4 the minimum between var0 and var1 . you have to store in var5 the factorial of var4 . you have to return var5 . 
you are given a string var1 , a string var2 and a string var3 . you have to create an associative container var4 . for each var5 between 0 and 25 you have to insert the pair var1 [ var5 ] and var2 [ var5 ] to var4 . you have to set var6 to " " . for each position var7 in var3 if var3 [ var7 ] is a capital letter you have to concatenate the uppercase of the letter asociated to the lowercase of var3 [ var7 ] in var4 to var6 , otherwise if var3 [ var7 ] is a small letter you have to concatenate the letter asociated to var3 [ var7 ] in var4 to var6 , otherwise you have to concatenate the letter var3 [ var7 ] to var6 . you have to return var6 . 
you are given a string var0 . you have to set var1 to the length of var0 , var2 to zero , var3 to var1 , var4 to zero , var5 to var0 [ 0 ] and var6 to 48 . for each position var7 in var0 in reverse order except the firstone you have to , subtract 1 to var3 , add 1 to var4 , set var6 to var0 [ var7 ] , if var4 is greater than var3 break from the enclosing loop , if var0 [ var7 ] is different to 48 you have to , if var3 is greater than var4 or ( var3 is equal to var4 and var5 is greater than or equal to var6 ) add 1 to var2 , set var4 to zero , otherwise you have to break from the enclosing loop . you have to return var2 + 1 . 
given an integer var0 , find the product of all integers var2 from 1 to var0 ( both inclusive ) and return the result . 
you are given a number var0 and a number var1 . you have to return the factorial of the minimum between var0 and var1 . 
you are given 0 - based array var0 of integer type . return the sorted array var0 . 
given integers var1 , var2 , var3 and var4 . set var9 to ( 2 * ( ( ( abs ( ( var1 - var3 ) ) + 1 ) + abs ( ( var2 - var4 ) ) ) + 1 ) ) . increase var9 by 2 if var1 is equal to var3 or var2 is equal to var4 . return ans . 
given integers var0 , var1 , var2 . create 0 - based , 13 sized array var3 at var4 th position containing the factorial of var4 . return the factorial of the minimum of var1 and var2 . 
given integers var0 , var1 , var2 and var3 , set var8 to absolute value of var2 - var0 , increased by 1 , set var9 to absolute value of var3 - var1 , increased by 1 , add 1 to var8 if var0 = var2 , add 1 to var9 if var1 = var3 . return ( var8 + var9 ) * 2 . 
given a string var1 , initialize var2 to length of var1 and var3 to false . for each integer var4 from 0 to var2 - 1 ( both inclusive ) set var3 to true if there exists an integer var5 such that 1 < = var5 < = var2 / 4 ( rounded down ) , var4 + 4 * var5 < var2 , var1 [ var4 ] = " * " , var1 [ var4 + var5 ] = " * " , var1 [ var4 + 2 * var5 ] = " * " , var1 [ var4 + 3 * var5 ] = " * " and var1 [ var4 + 4 * var5 ] = " * " . return " yes " if var3 = true , return " no " otherwise . 
you are given integers var0 , var1 , var2 . return the factorial of the minimum of var1 and var2 . 
given an integer array var0 of size var1 . create two dimensional array var7 of chars . sort var0 in ascending order . copy elements of the array var0 to the array var7 . return var7 . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to return array var0 sorted from lowest to highest . 
you are given the numbers var0 , var1 , var2 , var3 . you have to set var4 to ( 8 + ( 2 * ( the absolute value of ( var0 - var2 ) - 1 ) ) ) + ( 2 * ( the absolute value of ( var1 - var3 ) - 1 ) ) . if var0 is equal to var2 you have to set var4 to 8 + ( 2 * ( the absolute value of ( var1 - var3 ) - 1 ) ) . if var1 is equal to var3 you have to set var4 to 8 + ( 2 * ( the absolute value of ( var0 - var2 ) - 1 ) ) . you have to return var4 . 
given a string var2 , initialize var3 to 1 . for each character var1 in var2 initialize var4 to var1 - 48 if " 0 " < = var1 < = " 9 " , initialize var4 to var1 - 55 if " A " < = var1 < = " Z " , initialize var4 to var1 - 61 if " a " < = var1 < = " z " , initialize var4 to 62 if var1 = " - " , initialize var4 to 63 if var1 = " _ " , and for each var5 from 0 to 5 ( both inclusive ) set var3 to ( 3 * var3 ) % 1000000007 if var5 - th bit ( 0 - based from least significant ) of var4 is equal to 0 . return var3 . 
given arrays var1 , var2 , var3 of char type . assign the value var3 [ var5 ] to var6 . if var6 is digit value then add var6 to the end of var4 . otherwise , if var6 is uppercase value then add the result of function func3 ( var2 [ string _ find ( first , func2 ( var6 ) ) ] ) to the end of var4 . otherwise , add the value in var2 standing at the same position at which var6 stands in var1 , to the end of var4 . after the loop is ended , return var4 . 
you are given an integer var0 . if var0 % 10 is less than 5 then decrement var0 by the value var0 % 10 . otherwise , increment var0 by the value 10 - var0 % 10 . return var0 . 
given an array of integers var0 , and an array of integers var1 . create a set of integers var3 . create a set of integers var4 . add the numbers in var0 to var3 . add the numbers in var1 to var4 . set the value of var7 to the number of ways we can choose a number var8 from var3 , and a number var9 from var4 , such that ( var8 xor var9 ) exists in var3 or var4 . return " Karen " if var7 is even , return " Koyomi " otherwise . 
given integer array var0 . create integer array var2 of size 101 . for each var3 from 0 to n - 1 and for each var4 from var0 [ var3 ] downto 0 , increment var2 [ tmp + 1 ] . for each var3 from 0 to n - 1 , initialize var6 to the number of elements of var2 with positions from 1 to 100 , which equal to n - i , decrement each of these elements and add var6 to the end of var9 . return var9 . 
given array var0 of integer type . return var0 , sorted in increasing order . 
given an array of strings var1 , an integer var8 , an array var9 and an index var10 into var1 ( 0 - based ) . initialize var2 to the suffix of string var1 [ var10 ] of length 4 . initialize var3 to 1 and var4 to 1989 . make the following operations 3 times : multiply var3 by 10 and add the current value of var3 to var4 . multiply var3 by 10 . initialize var6 to the value of var4 . initialize var7 to the concatenation of prefix of var6 having length of var6 - 3 and var2 . initialize var8 to var7 . while var8 is less than var4 , add the value of var3 to var8 . push the value of var8 into var9 . return var9 . 
given strings var1 , var2 , var3 , initialize var4 to var1 , var5 to var2 , var6 to var3 , var7 to empty string . for each position var8 in var6 if var6 [ var8 ] is not a letter , then append var6 [ var8 ] to the end of var7 , otherwise if var6 [ var8 ] is a lowercase letter , then append var5 [ j ] ( where j denotes the position of var6 [ var8 ] in var4 ) to the end of var7 , otherwise append var5 [ j ] , converted to uppercase , ( where j denotes the position of var6 [ var8 ] , converted to lowercase , in var4 ) to the end of var7 . return var7 . 
given an integer array var1 , var2 is equal to length of var1 , array var3 is equal to var1 , empty string array var11 . sort var3 . given an empty integer array var8 , integer arary var3 , integers var5 is equal to 0 , var0 , var7 is equal to 1 , var6 . while var5 is less than var0 : var6 is equal to first number var7 tha is not presented in array var3 . if var5 increased by var7 . if var5 is less than or equal to var0 , then add into var8 var7 . add length of var8 into var11 . add all var8 into var11 . return var11 . 
given three integers var4 , var5 and var6 , set new variables var0 , var7 and var1 to var4 , var5 and var6 respectively , and set var8 to - 1 . as long as var1 is greater than zero , repeat the following two steps : first , store the gcd of var0 and var1 into var9 . if var9 is not greater than var1 , set var1 to the difference of var1 and var9 , and if the result is equal to 0 , set var8 to 0 . otherwise set var8 to 1 and break from the enclosing loop . second , set var9 to the gcd of var7 and var1 . if var9 is not greater than var1 , set var1 to the difference of var1 and var9 , and if the result is equal to 0 , set var8 to 1 . otherwise set var8 to 0 and break from the enclosing loop . return the final value of var8 . 
given integers var1 , var2 , var3 . create integer typed arrays var4 , var5 both consisting of n + 1 zeros . assign 1 to var4 [ 0 ] and to var5 [ 0 ] . for all var6 s from 1 to var1 do following operations . for all var7 s from i - 1 downto 0 while i - j does not exceed var2 , assign to var4 [ var6 ] the sum of var4 [ var6 ] and var4 [ var7 ] modulo 10 ^ 9 + 7 . when the loops are ended , assign d - 1 to var2 . for all var6 s from 1 to var1 do following loop . for all var7 s from i - 1 downto 0 while i - j does not exceed var2 , assign to var5 [ var6 ] the sum of var5 [ var6 ] and var5 [ var7 ] modulo 10 ^ 9 + 7 . when the loops are ended , return the value var4 [ var1 ] - var5 [ var1 ] + 10 ^ 9 + 7 modulo 10 ^ 9 + 7 . 
given an array of integers var0 , initialize var10 to empty array of strings , var2 to array of integers of length 101 , var1 to length of var0 . for each position var3 in var0 add 1 to first var0 [ var3 ] elements of array var2 . for each integer var6 from 0 to var1 - 1 ( both inclusive ) count the number of positions var8 such that var1 - var2 [ var8 ] < = var6 and append a string , obtained by concatenation of string representation of the result , " " and " \ t " , to the end of var10 . return var10 . 
you are given a number var0 and a number var1 . set var2 to zero . for each var3 between 0 and var1 you have to , set var4 to ( var1 - var3 ) * var0 , store in var2 the maximum between ( var4 * ( var4 + 1 ) * ( var3 + 1 ) ) divided by 2 ( rounded down ) + ( var3 * ( var3 + 1 ) * ( var4 + 1 ) ) divided by 2 ( rounded down ) , and var2 . you have to return var2 . 
given a number var0 , initialize an integer array var1 to a new array of length 10 . store the digits of var0 from right to left in var1 and save the amount of digits in var2 . initialize var3 and var4 to 0 . for every digit in var1 if var1 [ var5 ] > var3 or var1 [ var5 ] > = 2 then store var1 [ var5 ] in var3 and store var5 in var4 . if var3 is equal to zero then store var4 * 2 in var6 else store ( var4 + 1 ) * 2 - 1 in var6 . for every number var7 between var4 + 1 and var2 if var1 [ var7 ] > 0 then add var7 * 2 to var6 . return var6 . 
given an array var0 . sort the given array and return it . 
given integers var0 , var1 . return the factorial of the minimum between var0 and var1 . 
given arrays var0 , var1 . initialize var3 to the concatenation of var0 and var1 . return " Karen " . 
you are given an integer var0 . let var1 be the last digit in var0 . if var1 is less than 5 then decrement var0 by var1 . otherwise , increment var0 by the value 10 - var1 . return var0 . 
given an integer var0 . initialize var1 to var0 modulo 10 . if var1 is greater than 5 , add 10 - var1 to var0 ; else divide var0 by 10 and multiply var0 by 10 . return var0 . 
you are given integers var0 and var1 . set var2 to var0 and var3 to var1 - 1 . set var4 to 0 , set var5 to true . iterate from var2 down to 1 , in each iteration increment var4 , set var6 to true , if 2 raised to the power of var2 and the bitwise and with var3 is equal to 0 , otherwise set it to false . if var6 doesn ' t equal to var5 , increase var4 by ( 2 raised to the power of ( var2 + 1 ) ) - 1 . set var5 to the opposite boolean value of var6 . return var4 . 
given integers var0 , var1 , var2 . if at least one integer among var1 , var2 , var0 equals 1 then return an array consisting of one string " YES " . if at least two integers among var1 , var2 , var0 equal 2 then return an array consisting of one string " YES " . if all integers among var1 , var2 , var0 equal 3 then return an array consisting of one string " YES " . if two integers among var1 , var2 , var0 equal 4 and the remaining integer equals 2 then return an array consisting of one string " YES " . return an array consisting of one string " NO " . 
given an array of integers var0 , initialize var7 to empty array of strings and copy var0 into a new array var2 . sort var2 in non - decreasing order . for each position var5 in var2 append a string , obtained by concatenation of var2 [ var5 ] , converted to string , and " " , to the end of var7 . return var7 . 
given integers var0 , var1 . for all var2 s from 1 to var0 do following operations . if var1 is not less than var2 then substract var2 from var1 . otherwise , exit from the loop . if var0 equals var2 then assign 0 to var2 . when the loop is ended , return var1 . 
you are given an array of numbers var1 and an array of numbers var0 ( indexing is 0 - based ) . you have to store in array of numbers var4 each element in var1 , minus 1 , in order . you have to store in array of numbers var5 each different element in var1 , minus 1 , in order . you have to set var9 to zero . for each position var10 in var4 , you have to iterate var11 between 0 and length of var5 minus 1 , inside the loop you have to set var12 to var5 [ var11 ] , if var12 is equal to var4 [ var10 ] , you have to remove the element at index var11 in var5 , you have to add the number var12 at the beginning of var5 , you have to break from the enclosing loop ; otherwise you have to add var0 [ var5 [ var11 ] ] to var9 . you have to return var9 . 
you are given a number var0 . you have to return the sum of the powers of two from 1 to var0 . 
given an integer var0 , find the product of all integers from 1 to var0 ( both inclusive ) and store the result in var1 . return var1 . 
given an integer var0 , find the product of all integers between 1 and var0 ( both inclusive ) . return the result . 
given integer var0 . initialize var2 to 1 . while var2 is less than var0 subtract var2 from var0 and increase var2 by 1 . return var0 . 
you are given a number var0 and a number var1 . you have to return the factorial of the minimum between var0 and var1 . 
given integers var1 and var2 , initialize var5 to 0 . for as long as var2 > = var5 + 1 , substract var5 + 1 from var2 and set var5 to ( var5 + 1 ) % var1 . return var2 . 
given integers var0 , var1 . assign to var2 the value sum - 1 . if var1 equals 0 and var0 does not equal 1 or if var1 exceeds 9 * len then return the string " - 1 - 1 " . create char arrays var3 , var4 . for each var5 from 9 to len - 1 , add to the end of var4 , the minimum of 9 and var1 , substract from var1 the minimum of 9 and var1 . for each var5 from 0 to len - 2 , add to the beginning of var3 the minimum of 9 and var2 , substract from var2 the minimum of 9 and var2 . assign to var3 the minimum of sum1 + 1 and var3 . return the resultant var3 and var4 . 
given integer var0 . assign 1 < < var0 to var1 . create a matrix var2 of sizes var1 , var1 and of boolean type . assign true to var2 [ 0 ] [ 0 ] . for all var3 s from 1 to var3 < var1 , by multiplying var3 by 2 , do following loops . for all var4 s from 0 to var4 < var3 do following loop . for all var5 s from 0 to var5 < var3 do following operations . set the value of var2 [ var4 ] [ var5 ] to var2 [ var3 + var4 ] [ var5 ] , var2 [ var4 ] [ var3 + var5 ] . set the opposite value of var2 [ var4 ] [ var5 ] to var2 [ var3 + var4 ] [ var3 + var5 ] . after all loops are ended , create an array var6 of char type . for all var8 s from 0 to var8 < var1 , if var2 [ var7 ] [ var8 ] is true then add 43 to the end of var6 . otherwise , add 42 to the end of var6 . after the loop is ended , add 10 to the end of var6 . after all loops are ended , return var6 . 
given arrays of integers var0 and var1 , initialize var3 to empty set of integers . insert each element of var0 into var3 . insert each element of var1 into var3 . count the number of pairs ( var7 ; var8 ) such that var3 contains the bitwise xor of var0 [ var7 ] and var1 [ var8 ] . store the result in var6 . return " Karen " if var6 is even , return " Koyomi " otherwise . 
you are given an array of numbers var0 and an array of numbers var1 . you have to store in var4 the maximum of the difference of the sum of the first var6 values in var1 with the sum of the first var6 values in var0 for each var6 between 1 and length of var0 . you have to return var4 . 
you are given an array of integers var0 , and an array of integers var1 . set the value of var4 to the number of ways we can choose a number x from var0 and a number y from var1 such that ( x xor y ) is equal to either x or y . return " Karen " if var4 is even , return " Koyomi " otherwise . 
given an integer array var0 of size var1 , create a new integer array var2 of size var1 and copy the contents of var0 to var2 . sort the array var2 . create a string var6 with space separated elements of var2 . return var6 . 
given integers var0 , var1 , var2 and var3 , add 8 * var2 to var0 . if var0 > = var1 , then return an array containing one element , which is equal to 0 , otherwise if var2 < = var3 , then return an array containing one element , which is equal to - 1 , otherwise add the rounded up result of division of var1 - var0 by 12 * ( var2 - var3 ) to var4 and return an array containing one element , which is equal to var4 . 
given a string var0 , initialize the result to 0 . for each character in var0 , if the character is uppercase , add the 1 - based index of the character in the english alphabet to the result , otherwise subtract it from the result . return the result . 
given integers var1 , var2 , and var3 . initialize var7 to the maximal value among var1 + var2 + var3 and var1 * var2 * var3 . if var1 equals to 1 and ( var1 + var2 ) * var3 is greater than var7 then update var7 with this value . if var2 equals to 1 and maximal value among ( var1 + var2 ) * var3 and var1 * ( var2 + var3 ) is greater than var7 then update var7 with this value . if var3 equals to 1 and var1 * ( var2 + var3 ) is greater than var7 then update var7 with this value . return var7 . 
given array var0 of integer type . return the characters from var0 , sorted in increasing order and separated by spaces . 
you are given a number var1 . you have to store in var3 the minimum divisor of var1 greater than 1 . if var3 * var3 is greater than var1 or var1 divided by var3 is less than var2 you have to return " Marsel " , otherwise you have to return " Timur " . 
you are given an array of numbers var0 ( indexing is 0 - based ) . you have to return the elements of array var0 sorted from lowest to highest . 
given integers var0 and var1 , initialize var4 to 1 . for as long as var4 < = var1 , substract var4 from var1 , increase var4 by 1 , set var4 to 1 if var4 > var0 . return var1 . 
given an array of integers var0 , initialize var6 to empty array of strings and copy the array var0 into a new array var2 . sort the array var2 . for each position var4 in var2 append a string representation of var2 [ var4 ] and " " to the end of var6 . return var6 . 
given an array var0 . initialize var2 to var0 . sort elements of var2 in increasing order . return var2 . 
given integers var0 , var1 . return the factorial of the minimum between var0 and var1 . 
given integers var0 , var1 , var2 . return the factorial of minimum of var3 and var4 . 
you are given a number var0 , a number var1 , a number var2 . you have to create an array of numbers var3 of length 101 and an array of numbers var4 of length 101 . you have to set var3 [ 0 ] to 1 . for each var6 between 1 and var0 you have to , set var7 to 1 , while var7 is less than or equal to var6 and var7 is less than or equal to var1 you have to , set var3 [ var6 ] to var3 [ var6 ] + var3 [ var6 - var7 ] modulo 1000000007 , add 1 to var7 . after the loop in var6 ends set var4 [ 0 ] to 1 . for each var8 between 1 and var0 , you have to iterate var9 from 1 , and while var9 is less than or equal to var8 and var9 is less than var2 , inside the loop you have to set var4 [ var8 ] to var4 [ var8 ] + var4 [ var8 - var9 ] modulo 1000000007 . after the loop in var8 ends you have to return ( 1000000007 + var3 [ var0 ] - var4 [ var0 ] ) modulo 1000000007 . 
you are given a number var1 and a number var2 . you have to return the factorial of the minimum between var1 and var2 . 
given arrays var0 , var1 . initialize var2 to the length of var0 , var3 to a set of elements in var0 and var1 . initialize var6 to 0 . for each var7 from 0 to var2 exclusive and var8 from 0 to var2 exclusive , if var3 contains the value of ( var0 [ var7 ] xor var1 [ var8 ] ) , increase var6 by 1 . if var6 is even , return " Karen " ; else return " Koyomi " . 
you are given a number var4 and a number var5 . you have to create an array of strings var6 . you have to set __globals__.diplomaandcertificate . n to var4 , __globals__.diplomaandcertificate . k to var5 , __globals__.diplomaandcertificate . m to var4 . if var4 is not divisible by 2 you have to set __globals__.diplomaandcertificate . m to var4 - 1 . you have to divide __globals__.diplomaandcertificate . m by 2 . you have to set __globals__.diplomaandcertificate . a to ( ( __globals__.diplomaandcertificate . m - ( __globals__.diplomaandcertificate . m modulo ( __globals__.diplomaandcertificate . k + 1 ) ) ) divided by ( __globals__.diplomaandcertificate . k + 1 ) ) . if __globals__.diplomaandcertificate . a is equal to zero you have to insert in var6 the string formed by concatenating " 0 " , " 0 " and the decimal representation of __globals__.diplomaandcertificate . n , otherwise you have to insert in var6 the string formed by concatenating the decimal representation of __globals__.diplomaandcertificate . a with a space at the end , the decimal representation of __globals__.diplomaandcertificate . a * __globals__.diplomaandcertificate . k with a space at the end and the decimal representation of __globals__.diplomaandcertificate . n - ( __globals__.diplomaandcertificate . a * ( __globals__.diplomaandcertificate . k + 1 ) ) . you have to return var6 . 
given an integer var0 . initialize var2 to the value of var0 modulo 10 . if var2 is less than 5 , initialize var1 to var0 - var2 . otherwise , if var2 is greater than 5 , set var1 to var0 - var2 + 10 ; else set var1 to var0 - var2 . return var1 . 
you are given a number var1 . if the last digit in var1 is less than or equal to 5 you have to return var1 minus the last digit in var1 , otherwise you have to return var1 plus ( 10 minus the last digit in var1 ) . 
you are given a structure this of type struct0 , a string var0 , a string var1 , a string var3 . you have to set this . a to var0 . you have to concatenate the string this . a in uppercase to this . a . you have to set this . b to var1 . you have to concatenate the string this . b in uppercase to this . b . you have to set var5 to var3 . for each position var6 in var5 , set var5 [ var6 ] to the value of the function func1 at the arguments this and var5 [ var6 ] . you have to return var5 . 
given char typed arrays var0 , var1 , var2 . create integer typed array var3 of size 26 . create char typed array var4 . for all var5 s from 0 to assign the integer representation of var0 [ var5 ] minus 97 to var6 and assign var5 to var3 [ var6 ] . for all var7 s from 0 to length of var2 minus 1 do following operations . if var2 [ var7 ] is uppercase letter then assign the integer representation of var8 minus 65 to var9 and add to the end of var4 , the uppercase value var1 [ var3 [ var9 ] ] . if var2 [ var7 ] is lowercase letter then assign the integer representation of var8 minus 97 to var9 and add to the end of var4 , the uppercase value var1 [ var3 [ var9 ] ] . if var2 [ var7 ] is not a letter then add var8 to the end of var4 . when the loop is ended , return var4 . 
you are given a number var0 . if the last digit in var0 is less than or equal to 5 you have to return var0 minus the last digit in var0 ; otherwise you have to return var0 minus the last digit in var0 plus 10 . 
given integers var0 and var1 . return the product of integers from 1 to minimal value among var0 and var1 inclusive . 
given an integer var0 , round it to the nearest integer , which is divisible by 10 ( in case of tie round it down ) . return the result . 
you are given two arrays of integers var0 , var1 . create an empty set of integers var3 and push all the integers from var0 and var1 to var3 . initialize var6 to 0 . for each possible pair of integers a and b from arrays var0 and var1 respectively : if var3 contains an element ( a ^ b ) , increment var6 . if var6 is even number , return " Karen " , otherwise return " Koyomi " . 
given integers var1 and var2 , find the factorial of min ( var1 , var2 ) and store it in var6 . return var6 in its string form . 
given integers var0 and var1 , swap var0 and var1 if var0 < var1 . find the product of all positive integers var3 from 1 to var1 ( both inclusive ) , and return the result . 
given array var5 you need to calculate its elements using formula var5 [ var6 ] = ( var5 [ var6 ] + ( var5 [ ( var6 - var7 ) ] % var4 ) ) if var6 more or equal to var7 for var7 = 1 . . var1 and var6 = 1 . . var0 you need to save last element of var5 and set var5 to zero then set var5 [ 0 ] to 1 you need to calculate elements of var5 using formula var5 [ var6 ] = ( var5 [ var8 ] + ( var5 [ ( var8 - var9 ) ] % var4 ) ) if var8 more or equal to var9 for var9 = 1 . . var2 - 1 and var8 = 1 . . var0 you need to update saved value by minus last element of var5 mod var4 return result 
you are given a number var1 . you have to create a matrix of numbers __globals__.d . comb with var1 rows and var1 columns . set __globals__.d . comb [ 0 ] [ 0 ] to 1 . for each var2 between 1 and var1 - 1 set __globals__.d . comb [ var2 ] [ 0 ] to 1 , for each var3 between 1 and var2 set __globals__.d . comb [ var2 ] [ var3 ] to __globals__.d . comb [ var2 - 1 ] [ var3 ] + __globals__.d . comb [ var2 - 1 ] [ var3 - 1 ] . 
you are given a number var0 . you have to set var2 to var0 modulo 10 . if var2 is greater than or equal to 5 you have to set var1 to var0 + 10 - var2 , otherwise you have to set var1 to var0 - var2 . you have to return var1 . 
an array of numbers a is given . sort all elements of a . 
given integer typed arrays var0 , var1 . let var6 be the number of such values var0 [ var7 ] ^ var1 [ var8 ] which appear in var0 or var1 where both var7 and var8 obtain values from 0 to num - 1 . if var6 is even value then return " Karen " . otherwise , return " Koyomi " . 
you are given a string var2 . you have to set var4 to 1000000007 . you have to create an array of numbers var5 of length 64 initializated with zeros . you have to set var6 to 1 . for each var8 between 0 and 63 and each var7 between 0 and 63 you have to add 1 to var5 [ ( var8 bitwise and var7 ) ] . for each position var8 in var2 you have to set var6 to var6 * var5 [ the value of the function func0 at the argument var2 [ var8 ] ] modulo var4 . youi have to return var6 . 
given integers var1 , var2 . initialize var3 to var1 , var4 to var2 , var5 , var6 to 0 , var7 to var4 . while var7 is not less than 0 , perform the following operations . set var5 to the maximum between var5 and ( var7 + 1 ) * ( var6 * ( var6 + 1 ) / 2 ) + ( var6 + 1 ) * ( var7 * ( var7 + 1 ) / 2 ) , decrease var7 by 1 and add var3 to var6 . return var5 . 
given two integers var1 , var2 . initialize var3 to var1 , var4 to var2 and var5 to 0 . for each var6 from 0 to var4 , initialize var7 to var3 * ( var4 - var6 ) and set var5 to the maximum between var5 and the value of ( var7 * ( var7 + 1 ) / 2 ) * ( var6 + 1 ) + ( var6 * ( var6 + 1 ) / 2 ) * ( var7 + 1 ) . return var5 . 
given integers var1 and var2 , initialize var3 to array of integers of length var1 + 1 , filled with zeroes , and set var3 [ 0 ] to 1 . for each integer var4 from 0 to var1 ( both inclusive ) iterate over all integers var5 such that 1 < = var5 < = var2 and var5 < = var4 and for each such integer set var3 [ var4 ] to ( var3 [ var4 ] + var3 [ var4 - var5 ] ) % 1000000007 . return var3 [ var1 ] . 
